// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=unchecked -O -module-name UnifiedVideoEditorSDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import Accelerate
import BNBLicenseUtils
import CloudKit
import Combine
import CoreGraphics
import CoreMedia
import CoreVideo
import Foundation
import ImageIO
import MetalKit
import MobileCoreServices
import Photos
import QuartzCore
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
@_exported import UnifiedVideoEditorSDK
import VideoToolbox
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
import os.signpost
public class EffectItem {
  public var effect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`
  public var icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var text: UnifiedVideoEditorSDK.TextConfiguration
  public var isSelected: Swift.Bool
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var selectedColor: UIKit.UIColor
  public init(choosedEffect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, text: UnifiedVideoEditorSDK.TextConfiguration, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, selectedColor: UIKit.UIColor)
  @objc deinit
}
public class PreviewExtractor {
  final public let asset: AVFoundation.AVAsset
  final public let thumbnailHeight: CoreFoundation.CGFloat
  final public let imageGenerator: AVFoundation.AVAssetImageGenerator
  public init(asset: AVFoundation.AVAsset, thumbnailHeight: CoreFoundation.CGFloat)
  @objc deinit
  public func extractPreview(at time: CoreMedia.CMTime) -> UIKit.UIImage?
  #if compiler(>=5.3) && $AsyncAwait
  public func extractPreview(at time: CoreMedia.CMTime) async -> UIKit.UIImage?
  #endif
}
public struct CustomSDKVideoCompositionConfig {
  public static let renderingQueueName: Swift.String
}
public enum TransitionType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case normal
  case whipDown
  case whipUp
  case whipRight
  case whipLeft
  case scrollDown
  case scrollUp
  case scrollRight
  case scrollLeft
  case spinRight
  case fade
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.TransitionType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.TransitionType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension CoreFoundation.CGSize {
  public func swap() -> CoreFoundation.CGSize
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class FullscreenActivityView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var text: Swift.String? {
    get
    set
  }
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var additionalButton: UIKit.UIButton?
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.FullScreenActivityConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) public func applyVisibility(_ visible: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public static func loadFromNib() -> UnifiedVideoEditorSDK.FullscreenActivityView
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct BorderButtonConfiguration {
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: CoreGraphics.CGColor
  public init(borderWidth: CoreFoundation.CGFloat, borderColor: CoreGraphics.CGColor)
}
public class VideoTrimData {
  public var start: CoreMedia.CMTime {
    get
  }
  public var end: CoreMedia.CMTime {
    get
  }
  public var duration: CoreMedia.CMTime {
    get
  }
  public init(start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  @objc deinit
}
@objc public protocol AppStateObserverDelegate {
  @objc func applicationWillResignActive(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc func applicationDidBecomeActive(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc optional func applicationWillEnterForeground(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc optional func applicationWillTerminateNotification(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc optional func applicationDidEnterBackgroundNotification(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
}
@_inheritsConvenienceInitializers @objc public class AppStateObserver : ObjectiveC.NSObject {
  weak public var delegate: (any UnifiedVideoEditorSDK.AppStateObserverDelegate)?
  public var appWillResignActive: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  convenience public init(delegate: (any UnifiedVideoEditorSDK.AppStateObserverDelegate)?)
  @objc deinit
}
extension UnifiedVideoEditorSDK.AppStateObserver {
  public func subscribeToNotifications()
  public func unsubscribeFromNotifications()
  @objc dynamic public func handleApplicationWillResignActiveNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleApplicationDidBecomeActiveNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleWillEnterForegroundNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleWillTerminateNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleDidEnterBackgroundNotification(_ notification: Foundation.Notification)
}
final public class ApplicationInformation {
  required public init(bundle: Foundation.Bundle)
  final public var version: Swift.String {
    get
  }
  final public var build: Swift.String {
    get
  }
  final public var fullVersion: Swift.String {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers public class PixelationStaticEffectRenderer : UnifiedVideoEditorSDK.EffectMetalRenderer {
  override public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String, additionalParameters: [Swift.String : Any]?)
  required public init()
  @objc deinit
}
@objc public class VideoEditorLaunchConfig : ObjectiveC.NSObject {
  public var entryPoint: UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint
  public var hostController: UIKit.UIViewController
  public var videoItems: [Foundation.URL]?
  public var shouldCopyVideo: Swift.Bool
  public var draftedLaunchConfig: UnifiedVideoEditorSDK.VideoEditorLaunchConfig.DraftedLaunchConfig?
  public var pipVideoItem: Foundation.URL?
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack?
  public var animated: Swift.Bool
  public struct DraftedLaunchConfig {
    public var externalDraft: UnifiedVideoEditorSDK.ExternalDraft
    public var draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig
    public init(externalDraft: UnifiedVideoEditorSDK.ExternalDraft, draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig)
  }
  public init(entryPoint: UnifiedVideoEditorSDK.BanubaVideoEditorEntryPoint, hostController: UIKit.UIViewController, videoItems: [Foundation.URL]? = nil, shouldCopyVideo: Swift.Bool = false, pipVideoItem: Foundation.URL? = nil, draftedLaunchConfig: UnifiedVideoEditorSDK.VideoEditorLaunchConfig.DraftedLaunchConfig? = nil, musicTrack: UnifiedVideoEditorSDK.MediaTrack? = nil, animated: Swift.Bool)
  @objc deinit
}
public struct ExportCoverImages {
  public var coverImage: UIKit.UIImage?
  public var gifFileUrl: Foundation.URL?
}
public protocol BanubaVideoEditorDelegate : AnyObject {
  func videoEditorDidCancel(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor)
  func videoEditorDone(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor)
  func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, shouldProcessMediaUrls urls: [Foundation.URL]) -> Swift.Bool
  func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, didSaveDraft draft: UnifiedVideoEditorSDK.ExternalDraft)
}
extension UnifiedVideoEditorSDK.BanubaVideoEditorDelegate {
  public func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, shouldProcessMediaUrls urls: [Foundation.URL]) -> Swift.Bool
  public func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, didSaveDraft draft: UnifiedVideoEditorSDK.ExternalDraft)
}
public class BanubaVideoEditor {
  weak public var delegate: (any UnifiedVideoEditorSDK.BanubaVideoEditorDelegate)?
  public var musicMetadata: UnifiedVideoEditorSDK.MusicEditorMetadata? {
    get
  }
  public var metadata: UnifiedVideoEditorSDK.VideoEditorMetadata? {
    get
  }
  public var videoMetadata: UnifiedVideoEditorSDK.VideoMetadata? {
    get
  }
  public var blurEffectsList: UnifiedVideoEditorSDK.BlurList? {
    get
  }
  public var asset: AVFoundation.AVAsset? {
    get
  }
  public var externalAnalyticsEventListener: (any UnifiedVideoEditorSDK.ExternalSDKAnalyticsEventsListener)? {
    get
    set
  }
  public var externalLogListener: (any UnifiedVideoEditorSDK.ExternalLogListener)? {
    get
    set
  }
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack? {
    get
  }
  public var draftsService: UnifiedVideoEditorSDK.DraftsService {
    get
  }
  public var imageGenerator: AVFoundation.AVAssetImageGenerator? {
    get
  }
  public var currentConfiguration: UnifiedVideoEditorSDK.VideoEditorConfig {
    get
  }
  public var draftActionType: UnifiedVideoEditorSDK.DraftActionType {
    get
  }
  public init?(token: Swift.String, arguments: [Swift.String : Any] = [:], isCameraEnabled: Swift.Bool = true, configuration: UnifiedVideoEditorSDK.VideoEditorConfig, externalViewControllerFactory: (any UnifiedVideoEditorSDK.ExternalViewControllerFactory)? = nil)
  public func export(using configuration: UnifiedVideoEditorSDK.ExportConfiguration, exportProgress: ((Swift.Float) -> Swift.Void)?, completion: @escaping ((_ error: (any Swift.Error)?, _ exportCoverImages: UnifiedVideoEditorSDK.ExportCoverImages?) -> Swift.Void))
  public func stopExport()
  public func isExporting() -> Swift.Bool
  public func exportAudio(fileUrl: Foundation.URL, audioSettings: [Swift.String : Any] = VESettings.audio, completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func clearSessionData()
  public func dismissVideoEditor(animated: Swift.Bool, completion: (() -> Swift.Void)?)
  public func getVideoEditorNavigationController(withLaunchConfiguration configuration: UnifiedVideoEditorSDK.VideoEditorLaunchConfig) -> UIKit.UINavigationController?
  public func presentVideoEditor(withLaunchConfiguration configuration: UnifiedVideoEditorSDK.VideoEditorLaunchConfig, completion: (() -> Swift.Void)?)
  public func updateVideoEditorConfig(_ config: UnifiedVideoEditorSDK.VideoEditorConfig)
  public func updateVideoEditorArgs(_ arguments: [Swift.String : Any])
  @objc deinit
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public static func presentSharingViewController(from hostController: UIKit.UIViewController, configuration: UnifiedVideoEditorSDK.SharingScreenConfiguration, mainVideoUrl: Foundation.URL, videoUrls: [Foundation.URL], previewImage: UIKit.UIImage, animated: Swift.Bool, completion: (() -> Swift.Void)?)
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public func exportExternalDraft(_ externalDraft: UnifiedVideoEditorSDK.ExternalDraft) throws -> Foundation.URL
  public func importExternalDraft(fromZipUrl url: Foundation.URL) throws -> UnifiedVideoEditorSDK.ExternalDraft
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public struct TextLink : UnifiedVideoEditorSDK.ReflectedStringConvertible {
    public let title: Swift.String
    public let link: Swift.String
    public let start: Foundation.TimeInterval
    public let end: Foundation.TimeInterval
  }
  public var textLinks: [UnifiedVideoEditorSDK.BanubaVideoEditor.TextLink] {
    get
  }
}
public protocol AlertViewControllerFactory : AnyObject {
  func getAlertViewController() -> UnifiedVideoEditorSDK.AlertViewController?
  func getPopoverAlertViewController() -> UnifiedVideoEditorSDK.PopoverAlertViewController?
}
extension UnifiedVideoEditorSDK.AlertViewControllerFactory where Self : UIKit.UIViewController {
  public func getPopoverAlertViewController() -> UnifiedVideoEditorSDK.PopoverAlertViewController?
}
public protocol AlertPresentable : UnifiedVideoEditorSDK.AlertViewControllerFactory {
  func presentAlertViewController(alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String?, disagreeButtonTitle: Swift.String?, animated: Swift.Bool, completion: @escaping ((_ success: Swift.Bool, _ buttonType: UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void))
  func presentPopoverAlert(position: UnifiedVideoEditorSDK.OverlayPopoverActionsPosition, actions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType) -> Swift.Void))
}
extension UnifiedVideoEditorSDK.AlertPresentable where Self : UIKit.UIViewController {
  public func presentAlertViewController(alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentAlert(alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool = false, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String? = nil, disagreeButtonTitle: Swift.String? = nil, animated: Swift.Bool = false, completion: @escaping ((_ success: Swift.Bool, _ buttonType: UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void))
  public func presentPopoverAlert(position: UnifiedVideoEditorSDK.OverlayPopoverActionsPosition, actions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType) -> Swift.Void))
}
public protocol EffectRenderer {
  func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String, additionalParameters: [Swift.String : Any]?)
}
public struct BackButtonConfiguration {
  public var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var position: UnifiedVideoEditorSDK.BackButtonConfiguration.Position?
  public var menuActions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType]
  @frozen public enum Position {
    case left
    case right
    public static func == (a: UnifiedVideoEditorSDK.BackButtonConfiguration.Position, b: UnifiedVideoEditorSDK.BackButtonConfiguration.Position) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? = nil, position: UnifiedVideoEditorSDK.BackButtonConfiguration.Position? = nil, menuActions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType] = [])
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class NibView : UIKit.UIView, UnifiedVideoEditorSDK.NibLoadable {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func commonInit()
  @objc deinit
}
public protocol TransformEffectsSDKServicing {
  var effectsApplicator: any UnifiedVideoEditorSDK.EffectsApplicatorServicing { get }
}
public protocol EffectsSDKServicing : UnifiedVideoEditorSDK.TransformEffectsSDKServicing {
  var watermarkApplicator: any UnifiedVideoEditorSDK.WatermarkApplicatorServicing { get }
  var effectsConfigHolder: any UnifiedVideoEditorSDK.EffectsHolderServicing { get }
}
public struct VESettings {
  public static var audio: [Swift.String : Any] {
    get
  }
}
public class TextEditSelectionBorderAnimationBehavior : UnifiedVideoEditorSDK.TextEditSelectionColorBehavior {
  final public let defaultBorderWidth: CoreFoundation.CGFloat
  final public let selectedBorderWidth: CoreFoundation.CGFloat
  public init(defaultBorderWidth: CoreFoundation.CGFloat, selectedBorderWidth: CoreFoundation.CGFloat)
  public func setColorView(_ colorView: UIKit.UIView, selected: Swift.Bool, animated: Swift.Bool)
  @objc deinit
}
extension CoreFoundation.CGPoint {
  public mutating func transformToGradientSpace()
  public func oppositePoint() -> CoreFoundation.CGPoint
  public static func gradientPointForAngle(_ angle: CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
}
public struct VideoAspectRatio {
  public static var minFillAspectRatio: CoreFoundation.CGFloat {
    get
  }
  public static var maxFillAspectRatio: CoreFoundation.CGFloat {
    get
  }
  public static var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> {
    get
  }
}
public struct VideoEditorDurationConfig {
  public var maximumVideoDuration: Foundation.TimeInterval
  public var videoDurations: [Foundation.TimeInterval]
  public var minimumDurationFromCamera: Foundation.TimeInterval
  public var minimumDurationFromGallery: Foundation.TimeInterval
  public var minimumVideoDuration: Foundation.TimeInterval
  public var minimumTrimmedPartDuration: Foundation.TimeInterval
  public var slideshowDuration: Foundation.TimeInterval
  public init(maximumVideoDuration: Foundation.TimeInterval, videoDurations: [Foundation.TimeInterval], minimumDurationFromCamera: Foundation.TimeInterval, minimumDurationFromGallery: Foundation.TimeInterval, minimumVideoDuration: Foundation.TimeInterval, minimumTrimmedPartDuration: Foundation.TimeInterval, slideshowDuration: Foundation.TimeInterval)
  public static var `default`: UnifiedVideoEditorSDK.VideoEditorDurationConfig {
    get
  }
  public func validateTrimRecorderVideoSupporting(supportsTrimRecordedVideo: Swift.Bool)
}
public protocol VEExportServicing : UnifiedVideoEditorSDK.ImageSlideshow {
  func exportVideo(to fileURL: Foundation.URL, using exportVideoInfo: UnifiedVideoEditorSDK.ExportVideoInfo, watermarkFilterModel: UnifiedVideoEditorSDK.VideoEditorFilterModel?, exportProgress: ((Swift.Float) -> Swift.Void)?, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  func exportAudio(to fileURL: Foundation.URL, asset: AVFoundation.AVAsset?, audioSettings: [Swift.String : Any], completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
}
public struct SharingServiceModel {
  public enum SharingType {
    case facebookReels
    case facebookStories
    case instagramStories
    case other
    public static func == (a: UnifiedVideoEditorSDK.SharingServiceModel.SharingType, b: UnifiedVideoEditorSDK.SharingServiceModel.SharingType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let sharingType: UnifiedVideoEditorSDK.SharingServiceModel.SharingType
  public let sharingTitle: Swift.String
  public let sharingImage: UIKit.UIImage
  public init(sharingType: UnifiedVideoEditorSDK.SharingServiceModel.SharingType, sharingTitle: Swift.String, sharingImage: UIKit.UIImage)
}
extension UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.TextConfiguration, with text: Swift.String)
}
public protocol PlayableViewController : AnyObject {
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func playRange(_ range: CoreMedia.CMTimeRange, loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func pause()
  func smoothlySeek(to time: CoreMedia.CMTime)
  func seek(to time: CoreMedia.CMTime)
  func reloadPreview(shouldAutoStart: Swift.Bool)
  func didVideoPlay(atTime time: CoreMedia.CMTime)
  var currentTime: CoreMedia.CMTime { get }
  var videoDuration: CoreMedia.CMTime { get }
  var player: (any UnifiedVideoEditorSDK.VideoEditorPlayable)? { get }
  var isPlaying: Swift.Bool { get }
  var previewVideoView: (any UnifiedVideoEditorSDK.VideoPlayableView)? { get }
}
@objc public class AlbumsConfiguration : ObjectiveC.NSObject {
  public var textButton: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var arrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var backButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var albumItemConfiguration: UnifiedVideoEditorSDK.AlbumItemConfiguration
  public var backgroundColor: UIKit.UIColor
  public init(textButton: UnifiedVideoEditorSDK.TextButtonConfiguration, arrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, backButton: UnifiedVideoEditorSDK.BackButtonConfiguration, albumItemConfiguration: UnifiedVideoEditorSDK.AlbumItemConfiguration, backgroundColor: UIKit.UIColor)
  @objc deinit
}
@objc public class AlbumItemConfiguration : ObjectiveC.NSObject {
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var numberOfAlbumItemsConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var coverCornerRadius: CoreFoundation.CGFloat
  public init(titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration, numberOfAlbumItemsConfiguration: UnifiedVideoEditorSDK.TextConfiguration, coverCornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
public enum ExportQuality {
  case videoConfiguration(UnifiedVideoEditorSDK.ExportVideoInfo)
  case auto
}
public struct GifSettings {
  public var duration: Foundation.TimeInterval
  public var width: CoreFoundation.CGFloat
  public var fps: Foundation.TimeInterval
  public var isReversed: Swift.Bool
  public init(duration: Foundation.TimeInterval, width: CoreFoundation.CGFloat = 240, fps: Foundation.TimeInterval = 15.0, isReversed: Swift.Bool = true)
}
public struct ExportConfiguration {
  public let videoConfigurations: [UnifiedVideoEditorSDK.ExportVideoConfiguration]
  public let isCoverEnabled: Swift.Bool
  public var gifSettings: UnifiedVideoEditorSDK.GifSettings?
  public static func defaultConfiguration(fileURL: Foundation.URL) -> UnifiedVideoEditorSDK.ExportConfiguration
  public init(videoConfigurations: [UnifiedVideoEditorSDK.ExportVideoConfiguration], isCoverEnabled: Swift.Bool, gifSettings: UnifiedVideoEditorSDK.GifSettings?)
}
public struct ExportVideoConfiguration {
  public let fileURL: Foundation.URL
  public let quality: UnifiedVideoEditorSDK.ExportQuality
  public let useHEVCCodecIfPossible: Swift.Bool
  public let audioSettings: [Swift.String : Any]?
  public let watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?
  public init(fileURL: Foundation.URL, quality: UnifiedVideoEditorSDK.ExportQuality, useHEVCCodecIfPossible: Swift.Bool, audioSettings: [Swift.String : Any]? = VESettings.audio, watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?)
}
extension CoreFoundation.CGFloat {
  public var gradientPoints: (CoreFoundation.CGPoint, CoreFoundation.CGPoint) {
    get
  }
}
public class BanubaCancelHandler {
  public init(handler: @escaping () -> Swift.Void)
  public func cancel()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class BanubaAsyncOperation : Foundation.Operation {
  @objc override dynamic open var isReady: Swift.Bool {
    @objc get
  }
  @objc final override public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc final override public var isFinished: Swift.Bool {
    @objc get
  }
  @objc final override public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic open class func keyPathsForValuesAffectingValue(forKey key: Swift.String) -> Swift.Set<Swift.String>
  @objc final override public func start()
  @objc override dynamic open func main()
  final public func finish()
  @objc override dynamic public init()
  @objc deinit
}
extension Swift.Double {
  public func formatted(isMiliSecondsEnabled: Swift.Bool = true, isMinutesInFullFormat: Swift.Bool = false) -> Swift.String
  public func stringFromTimeInterval() -> Swift.String
}
@_hasMissingDesignatedInitializers public class ExportScaledTimeline : UnifiedVideoEditorSDK.EffectStack {
  public var composition: AVFoundation.AVMutableComposition? {
    get
  }
  public init(with composition: AVFoundation.AVMutableComposition?, allowOverlappingVisualEffects: Swift.Bool = false)
  public func scaleAndArrange(with effects: [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol])
  public func canBeIntersected(effectType: UnifiedVideoEditorSDK.EditorEffectType) -> Swift.Bool
  @objc deinit
}
extension UnifiedVideoEditorSDK.ExportScaledTimeline : UnifiedVideoEditorSDK.SDKVideoCompositionInstructionDataSource {
  public func getEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  public func getEffectsBefore(time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
}
public protocol AudioItem {
  var uuid: Foundation.UUID { get }
  var url: Foundation.URL { get }
  var coverURL: Foundation.URL? { get }
  var title: Swift.String? { get set }
  var additionalTitle: Swift.String? { get set }
  var isEditable: Swift.Bool { get set }
}
extension ObjectiveC.NSObject {
  public func performSync(onThread: Foundation.Thread?, block: @escaping @convention(block) () -> Swift.Void)
  public func performAsync(onThread: Foundation.Thread?, block: @escaping @convention(block) () -> Swift.Void)
}
public protocol ImageSlideshow {
  @discardableResult
  func exportSlideshowImages(_ images: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol], to fileUrl: Foundation.URL?, videoResolution: UnifiedVideoEditorSDK.VideoResolution, completion: ((Foundation.URL, (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler
}
extension UnifiedVideoEditorSDK.ImageSlideshow {
  public func exportSlideshowImages(_ images: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol], to fileUrl: Foundation.URL? = nil, videoResolution: UnifiedVideoEditorSDK.VideoResolution, completion: ((Foundation.URL, (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler
}
public enum OutputServiceError : Swift.Error {
  case notEnoughSpace
  public static func == (a: UnifiedVideoEditorSDK.OutputServiceError, b: UnifiedVideoEditorSDK.OutputServiceError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol VideoSequenceServicing {
  var videoSequences: [UnifiedVideoEditorSDK.VideoSequence] { get }
  var currentSequence: UnifiedVideoEditorSDK.VideoSequence? { get }
  func setupCurrentSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence?)
  @discardableResult
  func startNewSequence() -> UnifiedVideoEditorSDK.VideoSequence
  func cancelCurrentSequence()
  func duplicateSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> UnifiedVideoEditorSDK.VideoSequence
  func replaceSequence(_ videoSequenceToReplace: UnifiedVideoEditorSDK.VideoSequence, withSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  @discardableResult
  func removeSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> Swift.Bool
  func removeAllSequences()
}
public class VideoSequenceService {
  public var videoSequences: [UnifiedVideoEditorSDK.VideoSequence] {
    get
  }
  public var currentSequence: UnifiedVideoEditorSDK.VideoSequence?
  public init()
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoSequenceService : UnifiedVideoEditorSDK.VideoSequenceServicing {
  public func setupCurrentSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence?)
  @discardableResult
  public func startNewSequence() -> UnifiedVideoEditorSDK.VideoSequence
  public func cancelCurrentSequence()
  @discardableResult
  public func removeSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> Swift.Bool
  @discardableResult
  public func duplicateSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> UnifiedVideoEditorSDK.VideoSequence
  public func replaceSequence(_ videoSequenceToReplace: UnifiedVideoEditorSDK.VideoSequence, withSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  public func removeAllSequences()
}
public struct ColorPair : Swift.Equatable {
  public let background: UIKit.UIColor
  public let foreground: UIKit.UIColor
  public init(background: UIKit.UIColor, foreground: UIKit.UIColor)
  public static func == (lhs: UnifiedVideoEditorSDK.ColorPair, rhs: UnifiedVideoEditorSDK.ColorPair) -> Swift.Bool
}
public struct VideoTextColorPair : Swift.Equatable {
  public let foreground: UnifiedVideoEditorSDK.ColorPair
  public let background: UnifiedVideoEditorSDK.ColorPair
  public init(colors: (UIKit.UIColor, UIKit.UIColor, UIKit.UIColor, UIKit.UIColor))
  public init(foreground: UnifiedVideoEditorSDK.ColorPair, background: UnifiedVideoEditorSDK.ColorPair)
  public static func == (lhs: UnifiedVideoEditorSDK.VideoTextColorPair, rhs: UnifiedVideoEditorSDK.VideoTextColorPair) -> Swift.Bool
}
public struct VideoTextFont : Swift.Equatable {
  public var font: UIKit.UIFont?
  public var name: Swift.String
  public init(font: UIKit.UIFont?, name: Swift.String)
  public static func == (a: UnifiedVideoEditorSDK.VideoTextFont, b: UnifiedVideoEditorSDK.VideoTextFont) -> Swift.Bool
}
public protocol ExternalSDKAnalyticsEventsListener : AnyObject {
  func onVideoEditorSDKEvent(_ event: Swift.String)
}
public enum SDKEventScreen : Swift.String, Swift.Codable {
  case camera
  case editor
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SDKEventName : Swift.String {
  case maskDownloaded
  case maskApplied
  case maskCancelled
  case exportVideo
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SDKEffectEvent : Swift.Codable {
  public let name: Swift.String
  public let data: UnifiedVideoEditorSDK.SDKEventEffectData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SDKEventEffectData : Swift.Codable, Swift.Hashable {
  public let name: Swift.String
  public let screen: UnifiedVideoEditorSDK.SDKEventScreen?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UnifiedVideoEditorSDK.SDKEventEffectData, b: UnifiedVideoEditorSDK.SDKEventEffectData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct SDKExportEvent : Swift.Codable {
  public let name: Swift.String
  public let data: UnifiedVideoEditorSDK.SDKExportEvent.SDKExportEventData
  public struct SDKExportEventData : Swift.Codable {
    public let masks: [Swift.String]
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RevokedTokenError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
  public init()
}
public enum BackgroundViewStyle : Swift.Equatable {
  case blur(style: UIKit.UIBlurEffect.Style)
  case dim
  case none
  public static func == (a: UnifiedVideoEditorSDK.BackgroundViewStyle, b: UnifiedVideoEditorSDK.BackgroundViewStyle) -> Swift.Bool
}
@objc public class TextConfiguration : ObjectiveC.NSObject {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var alignment: UIKit.NSTextAlignment
  public var text: Swift.String?
  public var shadow: UnifiedVideoEditorSDK.TextShadowConfiguration?
  public var lineBreakMode: UIKit.NSLineBreakMode
  public init(kern: Swift.Double = 0, font: UIKit.UIFont, color: UIKit.UIColor, alignment: UIKit.NSTextAlignment = .center, text: Swift.String? = nil, shadow: UnifiedVideoEditorSDK.TextShadowConfiguration? = nil, lineBreakMode: UIKit.NSLineBreakMode = .byWordWrapping)
  @objc override dynamic public func copy() -> Any
  @objc deinit
}
public struct TextShadowConfiguration {
  public var shadowColor: UIKit.UIColor
  public var shadowOffset: CoreFoundation.CGSize
  public var shadowBlurRadius: CoreFoundation.CGFloat
  public init(shadowColor: UIKit.UIColor = UIColor.black.withAlphaComponent(0.4), shadowOffset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), shadowBlurRadius: CoreFoundation.CGFloat = 2.0)
  public func shadow() -> UIKit.NSShadow
}
extension Swift.Error {
  public var errorMessage: Swift.String {
    get
  }
}
public enum EffectSpeed : Swift.Float {
  case normal
  case slowmo
  case rapid
  public init?(rawValue: Swift.Float)
  public typealias RawValue = Swift.Float
  public var rawValue: Swift.Float {
    get
  }
}
@_hasMissingDesignatedInitializers public class EditorCompositionFactory {
  public static func createEditorEffect(start: CoreMedia.CMTime, end: CoreMedia.CMTime, model: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, additionalParameters: [Swift.String : Any]?) -> any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol
  public static func createEditorEffect(start: CoreMedia.CMTime, end: CoreMedia.CMTime, type: UnifiedVideoEditorSDK.EditorEffectType, renderer: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)?, path: Swift.String, speed: UnifiedVideoEditorSDK.EffectSpeed, transition: UnifiedVideoEditorSDK.TransitionType = .normal, uuid: Swift.String, id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, additionalParameters: [Swift.String : Any]?) -> any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol
  public static func zeroTimeEffect() -> any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol
  @objc deinit
}
public protocol EditorCompositionEffectProtocol : AnyObject {
  var additionalParameters: [Swift.String : Any]? { get }
  var startTime: CoreMedia.CMTime { get }
  var endTime: CoreMedia.CMTime { get }
  var id: Swift.UInt { get }
  var tokenId: Swift.String { get set }
  var path: Swift.String { get }
}
public protocol EditorCompositionEditableEffectProtocol : Foundation.NSCopying, UnifiedVideoEditorSDK.EditorCompositionEffectProtocol {
  var startTime: CoreMedia.CMTime { get set }
  var endTime: CoreMedia.CMTime { get set }
  var filterType: UnifiedVideoEditorSDK.EditorEffectType { get }
  var speed: UnifiedVideoEditorSDK.EffectSpeed { get }
  var transitionType: UnifiedVideoEditorSDK.TransitionType { get }
  var uuid: Swift.String { get }
  var rendererClass: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)? { get }
  var rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)? { get }
  var additionalParameters: [Swift.String : Any]? { get }
  func isInTime(_ time: CoreMedia.CMTime) -> Swift.Bool
  func isEqual(to: any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol) -> Swift.Bool
}
public class VEPlayback {
  public init?(videoEditorService: UnifiedVideoEditorSDK.VideoEditorService)
  public func getPlayer(forExternalAsset asset: AVFoundation.AVAsset? = nil, delegate: (any UnifiedVideoEditorSDK.VideoEditorPlayerDelegate)?) -> any UnifiedVideoEditorSDK.VideoEditorPlayable
  public func getPlayableView(thumbnailSettings: UnifiedVideoEditorSDK.VEPlayback.ThumbnailSettings? = nil, forExternalAsset asset: AVFoundation.AVAsset? = nil, delegate: (any UnifiedVideoEditorSDK.VideoEditorPlayerDelegate)?) -> any UnifiedVideoEditorSDK.VideoPlayableView
  public struct ThumbnailSettings {
    public let playerTime: CoreMedia.CMTime
    public init(playerTime: CoreMedia.CMTime)
  }
  @objc deinit
}
public enum AspectRatio : Swift.UInt8, Swift.Codable {
  case original
  case aspect16x9
  case aspect9x16
  case aspect4x3
  case aspect4x5
  public func getVideoAspectRatio(withVideoSize videoSize: CoreFoundation.CGSize? = nil) -> CoreFoundation.CGFloat
  public init(videoAspectRatio: CoreFoundation.CGFloat)
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct CameraSessionMetadata : Swift.Codable {
  public var isFrontCamera: Swift.Bool
  public init(isFrontCamera: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VideoEditorTrimMetadata : Swift.Codable {
  public var sequenceItemsMetadata: [UnifiedVideoEditorSDK.VideoSequenceItemMetadata]
  public init(sequenceItemsMetadata: [UnifiedVideoEditorSDK.VideoSequenceItemMetadata])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VideoSequenceItemMetadata : Swift.Codable {
  public var videoName: Swift.String
  public var order: Swift.Int
  public var imageData: Foundation.Data?
  public var trimTimeRange: UnifiedVideoEditorSDK.TrimTimeRangeMetadata
  public let isGalleryAsset: Swift.Bool
  public let isSlideShow: Swift.Bool
  public let isPIP: Swift.Bool
  public var transition: UnifiedVideoEditorSDK.TransitionEffectMetadata
  public var aspectRatio: UnifiedVideoEditorSDK.AspectRatio
  public init(videoName: Swift.String, order: Swift.Int, imageData: Foundation.Data? = nil, trimTimeRange: UnifiedVideoEditorSDK.TrimTimeRangeMetadata, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool = false, transition: UnifiedVideoEditorSDK.TransitionEffectMetadata, aspectRatio: UnifiedVideoEditorSDK.AspectRatio)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct TransitionEffectMetadata : Swift.Codable {
  public struct Defaults {
    public static let transitionDuration: Swift.Double
    public static let timescale: CoreMedia.CMTimeScale
  }
  public let type: UnifiedVideoEditorSDK.TransitionType
  public init(type: UnifiedVideoEditorSDK.TransitionType)
  public static func startTime(fromTime: CoreMedia.CMTime) -> CoreMedia.CMTime
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TrimTimeRangeMetadata : Swift.Codable {
  public let start: UnifiedVideoEditorSDK.TimeMetadata
  public let duration: UnifiedVideoEditorSDK.TimeMetadata
  public func getCMTimeRange() -> CoreMedia.CMTimeRange
  public init(start: UnifiedVideoEditorSDK.TimeMetadata, duration: UnifiedVideoEditorSDK.TimeMetadata)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MusicEditorMetadata : Swift.Codable {
  public var tracks: [UnifiedVideoEditorSDK.MusicEditorTrack]
  public var pipVolume: Swift.Float?
  public var videoVolume: Swift.Float
  public init(tracks: [UnifiedVideoEditorSDK.MusicEditorTrack], pipVolume: Swift.Float?, videoVolume: Swift.Float)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MusicEditorTrack : Swift.Codable {
  public var url: Foundation.URL
  public var coverURL: Foundation.URL?
  public var originalURL: Foundation.URL
  public var title: Swift.String
  public var additionalTitle: Swift.String?
  public var id: Swift.Int32
  public let uuid: Foundation.UUID
  public var volume: Swift.Float
  public var position: Swift.Int
  public var timeScale: Foundation.TimeInterval
  public var compositionStart: Foundation.TimeInterval
  public var timeRangeStart: Foundation.TimeInterval
  public var timeRangeEnd: Foundation.TimeInterval
  public var isAudioRecord: Swift.Bool
  public var isEditable: Swift.Bool
  public var applyedFilterId: Swift.Int?
  public var isCameraTrack: Swift.Bool
  public init(url: Foundation.URL, coverURL: Foundation.URL?, originalURL: Foundation.URL, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, id: Swift.Int32, volume: Swift.Float, position: Swift.Int, timeScale: Foundation.TimeInterval, compositionStart: Foundation.TimeInterval, timeRangeStart: Foundation.TimeInterval, timeRangeEnd: Foundation.TimeInterval, isAudioRecord: Swift.Bool, isEditable: Swift.Bool, applyedFilterId: Swift.Int? = nil, isCameraTrack: Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct VideoEditorMetadata : Swift.Codable {
  public var effectsOnVideoMetadata: [UnifiedVideoEditorSDK.EffectOnVideoMetadata]?
  public var colorOnVideoMetadata: UnifiedVideoEditorSDK.ColorOnVideoMetadata?
  public var textOnVideoMetadata: [UnifiedVideoEditorSDK.TextOnVideoMetadata]?
  public var gifOnVideoMetadata: [UnifiedVideoEditorSDK.GIFOnVideoMetadata]?
  public var blurOnVideoMetadata: [UnifiedVideoEditorSDK.BlurOnVideoMetadata]?
  public var filtersOnVideoMetadata: [UnifiedVideoEditorSDK.FilterOnVideoMetadata]?
  public var analyticsMetadataJSON: Swift.String?
  public static var empty: UnifiedVideoEditorSDK.VideoEditorMetadata {
    get
  }
  public func adjustBlurEffectMetadata() -> UnifiedVideoEditorSDK.BlurList?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ColorOnVideoMetadata : Swift.Codable {
  public let title: Swift.String
  public init(title: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct FilterOnVideoMetadata : Swift.Codable {
  public let title: Swift.String
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public init(title: Swift.String, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CaptionsMetadata : Swift.Codable {
  public let existingCaptionIds: [Swift.String]
  public let styleParams: UnifiedVideoEditorSDK.TextParams
  public let styleTextColorDestinationId: Swift.Int
  public let languageCode: Swift.String?
  public let predefinedStyleId: Swift.Int?
  public init(existingCaptionIds: [Swift.String], styleParams: UnifiedVideoEditorSDK.TextParams, styleTextColorDestinationId: Swift.Int, languageCode: Swift.String?, predefinedStyleId: Swift.Int?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EffectOnVideoMetadata : Swift.Codable {
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let effectId: Swift.UInt
  public let tokenId: Swift.String
  public init(startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, effectId: Swift.UInt, tokenId: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TextOnVideoMetadata : Swift.Codable {
  public let id: Swift.String
  public let textParams: UnifiedVideoEditorSDK.TextParams
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams
  public let order: Swift.Int
  public let textColorDestinationId: Swift.Int
  public let linePositionOrderNumber: Swift.Int?
  public let predefinedStyleId: Swift.Int?
  public init(id: Swift.String, textParams: UnifiedVideoEditorSDK.TextParams, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams, order: Swift.Int, textColorDestinationId: Swift.Int, linePositionOrderNumber: Swift.Int?, predefinedStyleId: Swift.Int?)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum VideoSequenceEditingStep : Swift.Int, Swift.Codable {
  case trimmer
  case editor
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct VideoMetadata : Swift.Codable {
  public var name: Swift.String
  public var isDrafted: Swift.Bool
  public var aspect: UnifiedVideoEditorSDK.AspectRatio
  public var modificationDate: Foundation.Date
  public var maxVideoDuration: Foundation.TimeInterval?
  public let isSlideShow: Swift.Bool
  public var parentSequenceId: Swift.String?
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack?
  public var editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep
  public init(isSlideShow: Swift.Bool = false, isDrafted: Swift.Bool = false, name: Swift.String, maxVideoDuration: Foundation.TimeInterval?, sequenceParentName: Swift.String? = nil, editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep = .trimmer, musicTrack: UnifiedVideoEditorSDK.MediaTrack? = nil, aspect: UnifiedVideoEditorSDK.AspectRatio, modificationDate: Foundation.Date = Date())
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct BlurOnVideoMetadata : Swift.Codable {
  public let id: Swift.String
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let blurCoordinateParams: UnifiedVideoEditorSDK.BlurCoordinateParams
  public let coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams
  public let blurFigure: UnifiedVideoEditorSDK.DrawableFigure
  public let titleIndex: Swift.Int
  public let order: Swift.Int
  public init(id: Swift.String, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, blurCoordinateParams: UnifiedVideoEditorSDK.BlurCoordinateParams, coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams, blurFigure: UnifiedVideoEditorSDK.DrawableFigure, titleIndex: Swift.Int, order: Swift.Int)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct GIFOnVideoMetadata : Swift.Codable {
  public let id: Swift.String
  public let imageDataName: Swift.String
  public let imageData: Foundation.Data?
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams
  public let order: Swift.Int
  public init(id: Swift.String, imageDataName: Swift.String, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams, order: Swift.Int)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CoordinatesParams : Swift.Codable {
  public let transform: CoreFoundation.CGAffineTransform
  public let frame: CoreFoundation.CGRect
  public init(transform: CoreFoundation.CGAffineTransform, frame: CoreFoundation.CGRect)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ColorParams : Swift.Codable {
  public let red: CoreFoundation.CGFloat?
  public let green: CoreFoundation.CGFloat?
  public let blue: CoreFoundation.CGFloat?
  public let alpha: CoreFoundation.CGFloat?
  public init(red: CoreFoundation.CGFloat?, green: CoreFoundation.CGFloat?, blue: CoreFoundation.CGFloat?, alpha: CoreFoundation.CGFloat?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TextParams : Swift.Codable {
  public init(text: Swift.String?, link: Swift.String?, textFont: Swift.String?, fontName: Swift.String?, fontSize: CoreFoundation.CGFloat?, textAlignment: Swift.Int?, textColor: UnifiedVideoEditorSDK.ColorParams?, backgroundColor: UnifiedVideoEditorSDK.ColorParams?)
  public let text: Swift.String?
  public let link: Swift.String?
  public let textFont: Swift.String?
  public let fontName: Swift.String?
  public let fontSize: CoreFoundation.CGFloat?
  public let textAlignment: Swift.Int?
  public let textColor: UnifiedVideoEditorSDK.ColorParams?
  public let backgroundColor: UnifiedVideoEditorSDK.ColorParams?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VideoCoverMetadata : Swift.Codable {
  public var image: UIKit.UIImage? {
    get
  }
  public let imageData: Foundation.Data?
  public let coverIndent: UnifiedVideoEditorSDK.TimeMetadata
  public init(imageData: Foundation.Data?, coverIndent: UnifiedVideoEditorSDK.TimeMetadata)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TimeMetadata : Swift.Codable {
  public let seconds: Swift.Double
  public let timescale: CoreMedia.CMTimeScale
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension UnifiedVideoEditorSDK.TimeMetadata {
  public init(cmTime: CoreMedia.CMTime)
  public func getCMTime() -> CoreMedia.CMTime
}
public struct BlurList : Swift.Codable {
  public let blurMask: [UnifiedVideoEditorSDK.BlurMask]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct BlurMask : Swift.Codable {
  public let id: Swift.String
  public let type: Swift.String
  public let startTime: Swift.Int, endTime: Swift.Int
  public let params: UnifiedVideoEditorSDK.Params
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Params : Swift.Codable {
  public let x: Swift.Float
  public let y: Swift.Float
  public let radius: Swift.Float
  public let width: Swift.Float
  public let height: Swift.Float
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension UnifiedVideoEditorSDK.EffectOnVideoMetadata {
  public init(from editorCompositionEffect: any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol)
}
public class VideoEditorAssetTrackInfo : Swift.Hashable, Swift.Equatable {
  final public let uuidString: Swift.String
  public var url: Foundation.URL {
    get
  }
  public var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>
  final public let videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var videoCurentSize: CoreFoundation.CGFloat?
  public var thumbnail: UIKit.UIImage?
  public var thumbnails: [UIKit.UIImage]
  public var trimTimeRange: CoreMedia.CMTimeRange
  public var rotation: UnifiedVideoEditorSDK.AssetRotation {
    get
    set
  }
  public var videoName: Swift.String {
    get
  }
  public var isGalleryAsset: Swift.Bool
  public var isSlideShow: Swift.Bool
  public var composition: AVFoundation.AVComposition! {
    get
  }
  public var instructions: [any AVFoundation.AVVideoCompositionInstructionProtocol]? {
    get
  }
  public var error: (any Swift.Error)? {
    get
  }
  public var timeRange: CoreMedia.CMTimeRange {
    get
  }
  public var urlAsset: AVFoundation.AVAsset {
    get
  }
  public var timeRangeInGlobal: CoreMedia.CMTimeRange
  final public let originalAssetResolution: CoreFoundation.CGSize?
  public var transitionEffectType: UnifiedVideoEditorSDK.TransitionType
  public init(uuidString: Swift.String, url: Foundation.URL, rotation: UnifiedVideoEditorSDK.AssetRotation, thumbnail: UIKit.UIImage?, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>, videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, transitionEffectType: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize?)
  public func copy() -> UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo
  public func replaceAssetUrl(_ url: Foundation.URL)
  public func rotate(clockwise: Swift.Bool)
  public func getTimeRangeWithSpeedExtension() -> CoreMedia.CMTimeRange
  public func updatePreview()
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo {
  public static func == (lhs: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo, rhs: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
extension UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo {
  public func isTimeInGlobalTimeRange(_ time: CoreMedia.CMTime) -> Swift.Bool
}
@objc public protocol TimeLineDataSourceDelegate {
  @objc optional func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource)
}
@objc public protocol TimeLineDataSource {
  @objc var delegate: (any UnifiedVideoEditorSDK.TimeLineDataSourceDelegate)? { get set }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var duration: CoreMedia.CMTime { get }
  @objc var thumbnails: [UIKit.UIImage] { get }
  @objc var isAllThumbnailsFetched: Swift.Bool { get }
  @objc var thumbnailsCount: Swift.Int { get }
  @objc var thumbnailHeight: CoreFoundation.CGFloat { get }
  @objc func loadPreview(completion: @escaping (UIKit.UIImage?) -> Swift.Void, at second: Swift.Double)
  @objc func getImage(at index: Swift.Int) -> UIKit.UIImage?
  @objc func loadTimelineThumbs(completion: (() -> Swift.Void)?)
}
public protocol ProgressViewControllerFactory {
  func makeProgressViewController() -> any UnifiedVideoEditorSDK.BanubaProgressViewController
}
@_hasMissingDesignatedInitializers public class EditorEffectsFilter {
  public static func filterAddedEffects(effects: [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
public struct CollectionInfoHeaderConfiguration {
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var hideButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol
  public var height: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var underlinedTextColor: UIKit.UIColor
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, hideButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol, height: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, underlinedTextColor: UIKit.UIColor)
}
@_inheritsConvenienceInitializers @objc public class ZipArchive : ObjectiveC.NSObject {
  public static func zip(to destinationUrl: Foundation.URL, folderUrl: Foundation.URL) -> Swift.Bool
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) throws
  #if compiler(>=5.3) && $AsyncAwait
  @discardableResult
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) async throws -> Swift.String
  #endif
  @objc override dynamic public init()
  @objc deinit
}
@objc public class VideoImagesComposition : ObjectiveC.NSObject {
  public init(sequence: UnifiedVideoEditorSDK.VideoEditorImagesSequence, videoResolution: UnifiedVideoEditorSDK.VideoResolution)
  public func exportVideo(to file: Foundation.URL, quality: Swift.String, completion: (((any Swift.Error)?) -> Swift.Void)?)
  public func cancelExport()
  @objc deinit
}
public enum BNBInformerEventType {
  case `init`(any UnifiedVideoEditorSDK.BasicEventOptions)
  case present(any UnifiedVideoEditorSDK.BasicEventOptions)
  case export(any UnifiedVideoEditorSDK.BasicEventOptions)
}
public protocol BasicEventOptions : Swift.Decodable, Swift.Encodable {
  var sdkVersion: Swift.String { get }
  var iOSVersion: Swift.String { get }
  func adjustStringJson() -> Swift.String?
}
extension UnifiedVideoEditorSDK.BasicEventOptions {
  public func adjustStringJson() -> Swift.String?
}
public struct VideoSources : Swift.Codable {
  public let camera: Swift.Int
  public let gallery: Swift.Int
  public let pip: Swift.Int
  public let slideshow: Swift.Int
  public let audio: Swift.Int
  public init(camera: Swift.Int, gallery: Swift.Int, pip: Swift.Int, slideshow: Swift.Int, audio: Swift.Int)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExportEventOptions : UnifiedVideoEditorSDK.BasicEventOptions {
  public let exportSuccess: Swift.Bool
  public let videoResolutions: [Swift.String]
  public let postProcessingEffects: UnifiedVideoEditorSDK.PostProcessingOptions?
  public let cameraEffects: [Swift.String]?
  public let sdkVersion: Swift.String
  public let iOSVersion: Swift.String
  public let exportDuration: Swift.Double
  public let videoDuration: Swift.Double
  public let videoCount: Swift.UInt8
  public let videoSources: UnifiedVideoEditorSDK.VideoSources
  public let aspectRatio: Swift.String
  public init(exportSuccess: Swift.Bool, videoResolutions: [Swift.String], postProcessingEffects: UnifiedVideoEditorSDK.PostProcessingOptions?, cameraEffects: [Swift.String]?, exportDuration: Foundation.TimeInterval, videoDuration: Foundation.TimeInterval, videoCount: Swift.UInt8, videoSources: UnifiedVideoEditorSDK.VideoSources, aspectRatio: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PostProcessingOptions : Swift.Codable {
  public init(visual: Swift.Int, speed: Swift.Int, color: Swift.Int, text: Swift.Int, sticker: Swift.Int, blur: Swift.Int)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InitEventOptions : UnifiedVideoEditorSDK.BasicEventOptions {
  public var sdkVersion: Swift.String
  public var iOSVersion: Swift.String
  public init()
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias BanubaVideoEditorEntryPoint = UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint
public struct PresentEventOptions : UnifiedVideoEditorSDK.BasicEventOptions {
  public var sdkVersion: Swift.String
  public var iOSVersion: Swift.String
  public enum EntryPoint : Swift.String, Swift.Codable {
    case trimmer
    case editor
    case drafts
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init(entryPoint: UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Error {
  public var isCancelled: Swift.Bool {
    get
  }
  public var isNetworkUnavailable: Swift.Bool {
    get
  }
}
extension Foundation.NSError {
  public static func makeCancelledError(domain: Swift.String) -> Foundation.NSError
}
public protocol VideoEditorTrackServicing {
  var preferredTrackId: CoreMedia.CMPersistentTrackID { get }
  func hasVideoAudio() -> Swift.Bool
  func isAudioTrackVolumeChanged() -> Swift.Bool
  func videoVolume() -> Swift.Float
  func setVideoVolume(_ volume: Swift.Float)
  func setVideoVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  func hasPiPAudio() -> Swift.Bool
  func isPiPAudioTrackVolumeChanged() -> Swift.Bool
  func getPiPAudioVolume() -> Swift.Float
  func setPiPAudioVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  func setPiPAudioVolume(_ volume: Swift.Float)
  func addMusicTrack(didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, preferredTrackID: CoreMedia.CMPersistentTrackID?, start: CoreMedia.CMTime, duration: CoreMedia.CMTime?, trimmedStart: Foundation.TimeInterval?) -> (id: CoreMedia.CMPersistentTrackID, asset: AVFoundation.AVURLAsset, timeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, compositionStart: CoreMedia.CMTime, avAssetTrack: AVFoundation.AVAssetTrack)?
  func changeMusicTrackPosition(currentTime: Swift.Double, durationInSeconds: Swift.Double, compositionTimeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack, audioTrackId: CoreMedia.CMPersistentTrackID, audioServiceItem: UnifiedVideoEditorSDK.AudioServiceItem) -> CoreMedia.CMTimeRange?
  func getTrackVolume(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  func setTrack(trackId: CoreMedia.CMPersistentTrackID, volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  func removeTrack(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  func removeAllMusicTracks()
}
public protocol WatermarkApplicatorServicing : AnyObject {
  func adjustWatermarkEffect(configuration: UnifiedVideoEditorSDK.WatermarkConfiguration, videoSize: CoreFoundation.CGSize) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
}
public protocol VideoEditorServicing : UnifiedVideoEditorSDK.EffectsManagement, UnifiedVideoEditorSDK.VideoEditorTrackServicing {
  var asset: AVFoundation.AVAsset? { get }
  var videoAsset: UnifiedVideoEditorSDK.VideoEditorAsset? { get set }
  var exportFrameDuration: CoreMedia.CMTime { get set }
  var videoSize: CoreFoundation.CGSize { get set }
  var audioMixer: UnifiedVideoEditorSDK.AudioMixer? { get set }
  func getEditorEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [UnifiedVideoEditorSDK.VideoEditorFilterModel]
  func setCurrentAsset(_ asset: UnifiedVideoEditorSDK.VideoEditorAsset?)
  func setEditorEffects(_ effects: [UnifiedVideoEditorSDK.VideoEditorFilterModel])
  func getImageGenerator() -> AVFoundation.AVAssetImageGenerator?
  func videoPartsCount() -> Swift.Int
  func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
  init?(token: Swift.String)
  init(license: UnifiedVideoEditorSDK.License)
}
final public class VideoEditorService {
  final public func getVideoPlayerItem(forExternalAsset asset: AVFoundation.AVAsset?) -> AVFoundation.AVPlayerItem?
  final public func getMusicPlayerItem(forExternalAsset asset: AVFoundation.AVAsset?) -> AVFoundation.AVPlayerItem?
  final public var videoAsset: UnifiedVideoEditorSDK.VideoEditorAsset? {
    get
    set
  }
  final public var asset: AVFoundation.AVAsset? {
    get
  }
  final public var videoSize: CoreFoundation.CGSize
  final public var exportFrameDuration: CoreMedia.CMTime
  final public var audioMixer: UnifiedVideoEditorSDK.AudioMixer?
  final public var effects: UnifiedVideoEditorSDK.AppliedEffectsStack {
    get
  }
  final public var autoCutEffects: UnifiedVideoEditorSDK.AutoCutEffectsStack {
    get
  }
  final public let license: UnifiedVideoEditorSDK.License
  convenience public init?(token: Swift.String)
  public init(license: UnifiedVideoEditorSDK.License)
  @objc deinit
  final public func createExportComposition(asset: AVFoundation.AVAsset, dataSource: (any UnifiedVideoEditorSDK.SDKVideoCompositionInstructionDataSource)?, renderSize: CoreFoundation.CGSize) -> AVFoundation.AVVideoComposition?
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.EffectsManagement {
  final public func changeEffectTimeRange(with uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  final public func applyEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime, removeSameType: Swift.Bool, isAutoCutEffect: Swift.Bool)
  final public func getSpeed(at time: CoreMedia.CMTime) -> Swift.Float
  @discardableResult
  final public func undoEffect(uuid: Swift.String) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  @discardableResult
  final public func undoLast(type: UnifiedVideoEditorSDK.EditorEffectType) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  final public func undoAll(type: UnifiedVideoEditorSDK.EditorEffectType)
  final public func undoAll(except type: UnifiedVideoEditorSDK.EditorEffectType)
  final public func undoAll()
  final public func startCurrentEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, at: CoreMedia.CMTime)
  final public func endCurrentEffect(at: CoreMedia.CMTime)
  final public func getCurrentAppliedEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getStoredEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getCurrentAppliedEffects() -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func storeStack()
  final public func restoreStack()
  final public func hasChangesInAppliedEffects() -> Swift.Bool
  final public func hasAutoCutEffects() -> Swift.Bool
  final public func undoAutoCutEffects()
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.SDKVideoCompositionInstructionDataSource {
  final public func getEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getEffectsBefore(time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.VideoEditorServicing {
  final public func getImageGenerator() -> AVFoundation.AVAssetImageGenerator?
  final public func reattachMusicTracks(_ mutableAsset: AVFoundation.AVMutableComposition)
  final public func getEditorEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [UnifiedVideoEditorSDK.VideoEditorFilterModel]
  final public func setCurrentAsset(_ asset: UnifiedVideoEditorSDK.VideoEditorAsset?)
  final public func setEditorEffects(_ effects: [UnifiedVideoEditorSDK.VideoEditorFilterModel])
  final public func videoPartsCount() -> Swift.Int
  final public func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.VideoEditorTrackServicing {
  final public var preferredTrackId: CoreMedia.CMPersistentTrackID {
    get
  }
  final public func hasVideoAudio() -> Swift.Bool
  final public func isAudioTrackVolumeChanged() -> Swift.Bool
  final public func videoVolume() -> Swift.Float
  final public func setVideoVolume(_ volume: Swift.Float)
  final public func setVideoVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  final public func hasPiPAudio() -> Swift.Bool
  final public func isPiPAudioTrackVolumeChanged() -> Swift.Bool
  final public func getPiPAudioVolume() -> Swift.Float
  final public func setPiPAudioVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  final public func setPiPAudioVolume(_ volume: Swift.Float)
  final public func hasPiPAudioTrack() -> Swift.Bool
  final public func changeMusicTrackPosition(currentTime: Swift.Double, durationInSeconds: Swift.Double, compositionTimeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack, audioTrackId: CoreMedia.CMPersistentTrackID, audioServiceItem: UnifiedVideoEditorSDK.AudioServiceItem) -> CoreMedia.CMTimeRange?
  final public func addMusicTrack(didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, preferredTrackID: CoreMedia.CMPersistentTrackID?, start: CoreMedia.CMTime, duration: CoreMedia.CMTime?, trimmedStart: Foundation.TimeInterval?) -> (id: CoreMedia.CMPersistentTrackID, asset: AVFoundation.AVURLAsset, timeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, compositionStart: CoreMedia.CMTime, avAssetTrack: AVFoundation.AVAssetTrack)?
  final public func getTrackVolume(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  final public func setTrack(trackId: CoreMedia.CMPersistentTrackID, volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  final public func removeTrack(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  final public func removeAllMusicTracks()
}
public protocol BanubaProgressViewController : UIKit.UIViewController {
  var message: Swift.String { get set }
  var tooltipMessage: Swift.String { get set }
  var configuration: UnifiedVideoEditorSDK.ProgressViewConfiguration? { get set }
  var cancelHandler: (() -> Swift.Void)? { get set }
  func updateProgressView(with progress: Swift.Float)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ProgressViewController : UIKit.UIViewController, UnifiedVideoEditorSDK.BanubaProgressViewController {
  @_Concurrency.MainActor(unsafe) public var message: Swift.String {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var tooltipMessage: Swift.String {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.ProgressViewConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var cancelHandler: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var slideInTransitioningDelegate: (any UIKit.UIViewControllerTransitioningDelegate)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UnifiedVideoEditorSDK.ProgressViewController {
  @_Concurrency.MainActor(unsafe) public func updateProgressView(with progress: Swift.Float)
}
extension UnifiedVideoEditorSDK.ProgressViewController {
  @_Concurrency.MainActor(unsafe) public static func makeViewController(presentationManager: UnifiedVideoEditorSDK.SlideInPresentationManager? = nil) -> UnifiedVideoEditorSDK.ProgressViewController
}
public struct OverlayEditorConfiguration {
  public var mainOverlayViewControllerConfig: UnifiedVideoEditorSDK.MainOverlayViewControllerConfig
}
public struct MainOverlayViewControllerConfig {
  public var addButtons: [UnifiedVideoEditorSDK.OverlayAddButtonConfig]
  public var editButtonsHeight: CoreFoundation.CGFloat
  public var editButtonsInteritemSpacing: CoreFoundation.CGFloat
  public var editCompositionButtons: [UnifiedVideoEditorSDK.OverlayEditButtonConfig]
  public var controlButtons: [UnifiedVideoEditorSDK.OverlayControlButtonConfig]
  public var playerControlsHeight: CoreFoundation.CGFloat
  public var mainLabelColors: UIKit.UIColor
  public var additionalLabelColors: UIKit.UIColor
  public var additionalLabelFonts: UIKit.UIFont
  public var cursorColor: UIKit.UIColor
  public var overlayItemConfiguration: UnifiedVideoEditorSDK.OverlayItemConfiguration
  public var resizeImageName: Swift.String
  public var draggersHorizontalInset: CoreFoundation.CGFloat
  public var draggersWidth: CoreFoundation.CGFloat?
  public var draggersHeight: CoreFoundation.CGFloat?
  public var draggersImageHeight: CoreFoundation.CGFloat?
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var playerControlsBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var defaultLinesCount: Swift.Int
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public var draggerBackgroundColor: UIKit.UIColor
  public var draggerCornerRadius: CoreFoundation.CGFloat?
  public var timeLabelsOffset: CoreFoundation.CGFloat
  public var itemsTopOffset: CoreFoundation.CGFloat
  public var previewViewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
}
public struct OverlayAddButtonConfig {
  public enum `Type` : Swift.String {
    case text
    case sticker
    case blur
    public var editorEffectType: UnifiedVideoEditorSDK.EditorEffectType {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type`
  public let title: Swift.String
  public var titleColor: UIKit.UIColor
  public var font: UIKit.UIFont
  public var imageName: Swift.String
  public var drawableFigure: UnifiedVideoEditorSDK.DrawableFigure?
  public var tintColor: UIKit.UIColor?
  public init(type: UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type`, title: Swift.String, titleColor: UIKit.UIColor, font: UIKit.UIFont, imageName: Swift.String, drawableFigure: UnifiedVideoEditorSDK.DrawableFigure? = nil, tintColor: UIKit.UIColor? = nil)
}
public struct OverlayEditButtonConfig {
  public enum `Type` : Swift.String {
    case edit
    case style
    case delete
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type`
  public let title: Swift.String
  public var titleColor: UIKit.UIColor
  public var font: UIKit.UIFont
  public let imageName: Swift.String
  public let selectedImageName: Swift.String?
  public var tintColor: UIKit.UIColor?
  public init(type: UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type`, title: Swift.String, titleColor: UIKit.UIColor, font: UIKit.UIFont, imageName: Swift.String, selectedImageName: Swift.String?, tintColor: UIKit.UIColor? = nil)
}
public struct OverlayControlButtonConfig {
  public enum `Type` : Swift.String {
    case reset
    case play
    case done
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type`
  public var image: UIKit.UIImage?
  public var selectedImage: UIKit.UIImage?
  public let imageName: Swift.String?
  public let selectedImageName: Swift.String?
  public let imageEdgeInsets: UIKit.UIEdgeInsets?
  public var style: UnifiedVideoEditorSDK.TextConfiguration?
  public var tintColor: UIKit.UIColor?
  public init(type: UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type`, imageName: Swift.String? = nil, selectedImageName: Swift.String? = nil, imageEdgeInsets: UIKit.UIEdgeInsets? = nil, style: UnifiedVideoEditorSDK.TextConfiguration? = nil, tintColor: UIKit.UIColor? = nil)
}
public struct OverlayItemConfiguration {
  public var borderColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var borderWidth: CoreFoundation.CGFloat
  public var borderInset: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var titleFont: UIKit.UIFont?
  public var titleColor: UIKit.UIColor?
  public var imageInset: UIKit.UIEdgeInsets
  public init(borderColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, borderWidth: CoreFoundation.CGFloat, borderInset: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, titleFont: UIKit.UIFont? = nil, titleColor: UIKit.UIColor? = nil, imageInset: UIKit.UIEdgeInsets)
}
public struct VideoSequenceNameFormatter {
  public init()
  public func formattedNameFromDate(_ date: Foundation.Date) -> Swift.String
  public func formattedDraftSubtitleFromTime(_ time: Foundation.TimeInterval) -> Swift.String
}
public struct GalleryItemPreviewViewConfiguration {
  public var backgroundViewBlurStyle: UIKit.UIBlurEffect.Style
  public var selectionButtonView: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var selectionButtonSelectText: UnifiedVideoEditorSDK.TextConfiguration
  public var selectionButtonDeselectText: UnifiedVideoEditorSDK.TextConfiguration
  public var selectionButtonSelectImageName: Swift.String
  public var selectionButtonDeselectImageName: Swift.String
  public var previewContainerView: UnifiedVideoEditorSDK.BackgroundConfiguration
  public init(backgroundViewBlurStyle: UIKit.UIBlurEffect.Style, selectionButtonView: UnifiedVideoEditorSDK.BackgroundConfiguration, selectionButtonSelectText: UnifiedVideoEditorSDK.TextConfiguration, selectionButtonDeselectText: UnifiedVideoEditorSDK.TextConfiguration, selectionButtonSelectImageName: Swift.String, selectionButtonDeselectImageName: Swift.String, previewContainerView: UnifiedVideoEditorSDK.BackgroundConfiguration)
}
public enum DraftActionType {
  case save
  case update
  case cancel
  case none
  public var isSaveOrUpdate: Swift.Bool {
    get
  }
  public static func == (a: UnifiedVideoEditorSDK.DraftActionType, b: UnifiedVideoEditorSDK.DraftActionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol BlurApplicatorServicing : AnyObject {
  func changeTextureLocation(drawableFigure: UnifiedVideoEditorSDK.DrawableFigure, shapeRenderer: UnifiedVideoEditorSDK.ShapeDrawer, coordinates: UnifiedVideoEditorSDK.BlurCoordinateParams, completion: (() -> Swift.Void)?)
}
@_hasMissingDesignatedInitializers public class BlurApplicator : UnifiedVideoEditorSDK.BlurApplicatorServicing {
  public func changeTextureLocation(drawableFigure: UnifiedVideoEditorSDK.DrawableFigure, shapeRenderer: UnifiedVideoEditorSDK.ShapeDrawer, coordinates: UnifiedVideoEditorSDK.BlurCoordinateParams, completion: (() -> Swift.Void)?)
  @objc deinit
}
public enum EditorEffectKey : Swift.String {
  case name
  case type
  case warpType
  case speed
  case renderer
  case path
  case id
  case effectType
  case additionalParameters
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum OverlayEffectApplicatorType {
  case gif
  case text
  case blur(drawableFigure: UnifiedVideoEditorSDK.DrawableFigure, coordinates: UnifiedVideoEditorSDK.BlurCoordinateParams)
}
public enum VisualEffectApplicatorType : Swift.String, Swift.CaseIterable {
  case acid
  case cathode
  case dvCam
  case flash
  case glitch
  case glitchEffect2
  case glitch3
  case heatmap
  case lumeire
  case kaleidoscope
  case dslrKaleidoscope
  case pixelationDynamic
  case pixelationStatic
  case polaroid
  case rave
  case soul
  case stars
  case tvFoam
  case transition4
  case twitch
  case vhs
  case vhs2
  case zoom
  case zoom2
  case transitionDiagonal
  case transitionDefocus
  case transitionTunnelVision
  case transitionTunnelMirrored
  public var id: Swift.Int {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.VisualEffectApplicatorType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.VisualEffectApplicatorType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum SpeedEffectType : Swift.String, Swift.CaseIterable {
  case slowmo
  case rapid
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.SpeedEffectType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.SpeedEffectType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum TransitionEffectType : Swift.String, Swift.CaseIterable {
  case normal
  case whipDown
  case whipUp
  case whipRight
  case whipLeft
  case scrollDown
  case scrollUp
  case scrollRight
  case scrollLeft
  case spinRight
  case fade
  public var id: Swift.Int {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.TransitionEffectType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.TransitionEffectType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension UnifiedVideoEditorSDK.TransitionEffectType {
  public static func type(from type: UnifiedVideoEditorSDK.TransitionType) -> UnifiedVideoEditorSDK.TransitionEffectType
}
public protocol VideoPlayableView : UIKit.UIImageView {
  var previewLayer: AVFoundation.AVPlayerLayer { get }
  var imageGenerator: AVFoundation.AVAssetImageGenerator? { get set }
  var videoEditorPlayer: (any UnifiedVideoEditorSDK.VideoEditorPlayable)? { get set }
  var player: AVFoundation.AVPlayer? { get }
  func setPlayer(_ player: (any UnifiedVideoEditorSDK.VideoEditorPlayable)?, isThumbnailNeeded: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class PlayablePreview : UIKit.UIImageView, UnifiedVideoEditorSDK.VideoPlayableView {
  @_Concurrency.MainActor(unsafe) public var videoEditorPlayer: (any UnifiedVideoEditorSDK.VideoEditorPlayable)?
  @_Concurrency.MainActor(unsafe) public var imageGenerator: AVFoundation.AVAssetImageGenerator?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public var previewLayer: AVFoundation.AVPlayerLayer {
    get
  }
  @_Concurrency.MainActor(unsafe) public var player: AVFoundation.AVPlayer? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func setPlayer(_ player: (any UnifiedVideoEditorSDK.VideoEditorPlayable)?, isThumbnailNeeded: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public class TextButtonConfiguration : ObjectiveC.NSObject {
  public var style: UnifiedVideoEditorSDK.TextConfiguration
  public var text: Swift.String?
  public init(style: UnifiedVideoEditorSDK.TextConfiguration, text: Swift.String? = nil)
  @objc deinit
}
public enum AVAudioEngineUnit {
  case timePitch
  case reverb
  case delay
  public static func == (a: UnifiedVideoEditorSDK.AVAudioEngineUnit, b: UnifiedVideoEditorSDK.AVAudioEngineUnit) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum AVAudioEngineUnitParameter {
  case pitch
  case rate
  case wetDryMix
  case delayTime
  case feedback
  public static func == (a: UnifiedVideoEditorSDK.AVAudioEngineUnitParameter, b: UnifiedVideoEditorSDK.AVAudioEngineUnitParameter) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias AVAudioEngineFilterSetting = [UnifiedVideoEditorSDK.AVAudioEngineUnit : UnifiedVideoEditorSDK.AVAudioEngineUnitSettings]
public typealias AVAudioEngineUnitSettings = [UnifiedVideoEditorSDK.AVAudioEngineUnitParameter : Swift.Float]
extension UIKit.UITouch {
  @_Concurrency.MainActor(unsafe) public var id: Swift.Int64 {
    get
  }
}
public struct VideoEditorColorsPalette {
  public let primaryColor: UIKit.UIColor
  public let secondaryColor: UIKit.UIColor
  public let accentColor: UIKit.UIColor
  public let effectButtonColorsPalette: UnifiedVideoEditorSDK.EffectButtonColorsPalette
  public let addGalleryItemBackgroundColor: UIKit.UIColor
  public let addGalleryItemIconColor: UIKit.UIColor
  public let timelineEffectColorsPalette: UnifiedVideoEditorSDK.TimelineEffectColorsPalette
  public init(primaryColor: UIKit.UIColor, secondaryColor: UIKit.UIColor, accentColor: UIKit.UIColor, effectButtonColorsPalette: UnifiedVideoEditorSDK.EffectButtonColorsPalette, addGalleryItemBackgroundColor: UIKit.UIColor, addGalleryItemIconColor: UIKit.UIColor, timelineEffectColorsPalette: UnifiedVideoEditorSDK.TimelineEffectColorsPalette)
}
public struct EffectButtonColorsPalette {
  public let defaultIconColor: UIKit.UIColor
  public let defaultBackgroundColor: UIKit.UIColor
  public let selectedIconColor: UIKit.UIColor
  public let selectedBackgroundColor: UIKit.UIColor
  public init(defaultIconColor: UIKit.UIColor, defaultBackgroundColor: UIKit.UIColor, selectedIconColor: UIKit.UIColor, selectedBackgroundColor: UIKit.UIColor)
}
public struct TimelineEffectColorsPalette {
  public let stickersColor: UIKit.UIColor
  public let textsColor: UIKit.UIColor
  public let captionsColor: UIKit.UIColor
  public let pixelationColor: UIKit.UIColor
  public let audioTracksColor: UIKit.UIColor
  public let voiceOversColor: UIKit.UIColor
  public init(stickersColor: UIKit.UIColor, textsColor: UIKit.UIColor, captionsColor: UIKit.UIColor, pixelationColor: UIKit.UIColor, audioTracksColor: UIKit.UIColor, voiceOversColor: UIKit.UIColor)
  public static var `default`: UnifiedVideoEditorSDK.TimelineEffectColorsPalette {
    get
  }
}
public class WatermarkApplicator : UnifiedVideoEditorSDK.WatermarkApplicatorServicing {
  public init()
  public func adjustWatermarkEffect(configuration: UnifiedVideoEditorSDK.WatermarkConfiguration, videoSize: CoreFoundation.CGSize) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  @objc deinit
}
extension CoreMedia.CMTime : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class VideoDurationFormatter {
  public static func format(_ timeInterval: Foundation.TimeInterval) -> Swift.String
  @objc deinit
}
public enum Connection : Swift.CustomStringConvertible {
  case none, wifi, cellular
  public var description: Swift.String {
    get
  }
  public static func == (a: UnifiedVideoEditorSDK.Connection, b: UnifiedVideoEditorSDK.Connection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct AudioContext {
  public static let averagePeak: Swift.Float
  public static func averagePowers(audioFileURL: Foundation.URL, forChannel channelNumber: Swift.Int, compositionStart: Foundation.TimeInterval, compositionEnd: Foundation.TimeInterval?, duration: Foundation.TimeInterval, numberOfPeaks: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int) -> [Swift.Float]
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var keyboardLayoutGuide: UIKit.UILayoutGuide {
    get
  }
  @_Concurrency.MainActor(unsafe) public var keyboardLayoutGuideNoSafeArea: UIKit.UILayoutGuide {
    get
  }
}
@objc @_Concurrency.MainActor(unsafe) open class KeyboardLayoutGuide : UIKit.UILayoutGuide {
  @_Concurrency.MainActor(unsafe) public var usesSafeArea: Swift.Bool {
    get
    set
  }
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(notificationCenter: Foundation.NotificationCenter = NotificationCenter.default)
  @objc deinit
}
public protocol ImagesSequence {
  var relativeScreenPoints: UnifiedVideoEditorSDK.ImagePoints { get }
  func getImage(at time: Foundation.TimeInterval) -> CoreGraphics.CGImage
}
public struct VideoEditorConfig {
  public var videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var recorderEffectsConfiguration: UnifiedVideoEditorSDK.RecorderEffectsConfiguration
  public var editorConfiguration: UnifiedVideoEditorSDK.EditorConfiguration
  public var textEditorConfiguration: UnifiedVideoEditorSDK.TextEditorConfiguration
  public var toastConfiguration: UnifiedVideoEditorSDK.ToastConfiguration
  public var fullScreenActivityConfiguration: UnifiedVideoEditorSDK.FullScreenActivityConfiguration
  public var smallActivityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public var albumsConfiguration: UnifiedVideoEditorSDK.AlbumsConfiguration
  public var videoOverlayConfiguration: UnifiedVideoEditorSDK.VideoOverlayConfiguration
  public var videoDurationConfiguration: UnifiedVideoEditorSDK.VideoEditorDurationConfig
  public var gifPickerConfiguration: UnifiedVideoEditorSDK.GifPickerConfiguration
  public var combinedGalleryConfiguration: UnifiedVideoEditorSDK.GalleryConfiguration
  public var trimVideosConfiguration: UnifiedVideoEditorSDK.TrimVideosConfiguration
  public var trimVideoConfiguration: UnifiedVideoEditorSDK.TrimVideoConfiguration
  public var filterConfiguration: UnifiedVideoEditorSDK.FilterConfiguration
  public var extendedVideoCoverSelectionConfiguration: UnifiedVideoEditorSDK.VideoCoverSelectionConfiguration
  public var overlayEditorConfiguration: UnifiedVideoEditorSDK.OverlayEditorConfiguration
  public var watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?
  public var alertViewConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration
  public var popoverAlertViewConfiguration: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration
  public var handsfreeConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration?
  public var sharingScreenConfiguration: UnifiedVideoEditorSDK.SharingScreenConfiguration
  public var featureConfiguration: UnifiedVideoEditorSDK.FeatureConfiguration
  public var isHandfreeEnabled: Swift.Bool
  public var draftsConfiguration: UnifiedVideoEditorSDK.DraftsConfiguration
  public var aspectsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration
  public var transitionsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration
  public var progressViewConfiguration: UnifiedVideoEditorSDK.ProgressViewConfiguration
  public var beautyIntensityConfiguration: UnifiedVideoEditorSDK.BeautyIntensityConfiguration
  public init()
  public init(videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration, recorderEffectsConfiguration: UnifiedVideoEditorSDK.RecorderEffectsConfiguration, editorConfiguration: UnifiedVideoEditorSDK.EditorConfiguration, textEditorConfiguration: UnifiedVideoEditorSDK.TextEditorConfiguration, toastConfiguration: UnifiedVideoEditorSDK.ToastConfiguration, fullScreenActivityConfiguration: UnifiedVideoEditorSDK.FullScreenActivityConfiguration, smallActivityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration, albumsConfiguration: UnifiedVideoEditorSDK.AlbumsConfiguration, videoOverlayConfiguration: UnifiedVideoEditorSDK.VideoOverlayConfiguration, videoDurationConfiguration: UnifiedVideoEditorSDK.VideoEditorDurationConfig, gifPickerConfiguration: UnifiedVideoEditorSDK.GifPickerConfiguration, combinedGalleryConfiguration: UnifiedVideoEditorSDK.GalleryConfiguration, trimVideosConfiguration: UnifiedVideoEditorSDK.TrimVideosConfiguration, trimVideoConfiguration: UnifiedVideoEditorSDK.TrimVideoConfiguration, filterConfiguration: UnifiedVideoEditorSDK.FilterConfiguration, extendedVideoCoverSelectionConfiguration: UnifiedVideoEditorSDK.VideoCoverSelectionConfiguration, overlayEditorConfiguration: UnifiedVideoEditorSDK.OverlayEditorConfiguration, featureConfiguration: UnifiedVideoEditorSDK.FeatureConfiguration, watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?, alertViewConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration, popoverAlertViewConfiguration: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration, handsfreeConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration?, sharingScreenConfiguration: UnifiedVideoEditorSDK.SharingScreenConfiguration, draftsConfiguration: UnifiedVideoEditorSDK.DraftsConfiguration, aspectsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration, transitionsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration, progressViewConfiguration: UnifiedVideoEditorSDK.ProgressViewConfiguration, beautyIntensityConfiguration: UnifiedVideoEditorSDK.BeautyIntensityConfiguration)
  public mutating func setupColorsPalette(_ colorsPalette: UnifiedVideoEditorSDK.VideoEditorColorsPalette)
  public mutating func applyFont(_ font: UIKit.UIFont)
  public mutating func updateAlertFonts(_ font: UIKit.UIFont)
  public mutating func updateProgressViewFonts(_ font: UIKit.UIFont)
  public mutating func updateEditorFonts(_ font: UIKit.UIFont)
  public mutating func updateToastFonts(_ font: UIKit.UIFont)
  public mutating func updateFullScreenActivityFonts(_ font: UIKit.UIFont)
  public mutating func updateAlbumsFonts(_ font: UIKit.UIFont)
  public mutating func updateTextEditorFonts(_ font: UIKit.UIFont)
  public mutating func updateSlideShowFonts(_ font: UIKit.UIFont)
  public mutating func updateTrimVideosFonts(_ font: UIKit.UIFont)
  public mutating func updateTrimVideoFonts(_ font: UIKit.UIFont)
  public mutating func updateFilterFonts(_ font: UIKit.UIFont)
  public mutating func updateExtendedVideoCoverSelectionFonts(_ font: UIKit.UIFont)
  public mutating func updateFeatureConfiguration(featureConfiguration: UnifiedVideoEditorSDK.FeatureConfiguration)
}
public struct TextEditorConfiguration {
  public var doneButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var fontButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var colorButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var textBackgroundButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var alignmentImages: [UnifiedVideoEditorSDK.VideoTextAlignment : UnifiedVideoEditorSDK.ImageButtonConfiguration]
  public var palette: [UnifiedVideoEditorSDK.VideoTextColorPair]
  public var fonts: [UnifiedVideoEditorSDK.VideoTextFont]
  public var additionalPaletteBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var palleteInsets: UIKit.UIEdgeInsets
  public var fontInsets: UIKit.UIEdgeInsets
  public var selectionColorBehavior: any UnifiedVideoEditorSDK.TextEditSelectionColorBehavior
  public var colorItemConfiguration: UnifiedVideoEditorSDK.TextEditColorItemConfiguration
  public var fontItemConfiguration: UnifiedVideoEditorSDK.TextEditFontItemConfiguration
  public var cursorColor: UIKit.UIColor
  public var isTextBackgroundColorAppliedByDefault: Swift.Bool
}
public struct TextEditColorItemConfiguration {
  public var borderColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public init(borderColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat)
}
public struct TextEditFontItemConfiguration {
  public var titleColor: UIKit.UIColor
  public let fontSize: CoreFoundation.CGFloat
  public let cornerRadius: CoreFoundation.CGFloat
  public let backgroundColor: UIKit.UIColor
  public let borderSelectionColor: UIKit.UIColor
  public let borderSelectionWidth: CoreFoundation.CGFloat
  public init(titleColor: UIKit.UIColor, fontSize: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, borderSelectionColor: UIKit.UIColor = .clear, borderSelectionWidth: CoreFoundation.CGFloat = .zero)
}
public struct VideoOverlayConfiguration {
  public var deleteImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var videoOverlayItemViewBlurConfiguration: UnifiedVideoEditorSDK.VideoOverlayItemViewConfiguration?
  public init(deleteImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, videoOverlayItemViewBlurConfiguration: UnifiedVideoEditorSDK.VideoOverlayItemViewConfiguration)
}
public struct FullScreenActivityConfiguration {
  public var labelFont: UIKit.UIFont
  public var cornerRadius: CoreFoundation.CGFloat
  public var activityEffectsViewAlpha: CoreFoundation.CGFloat
  public var activityIndicator: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public init(labelFont: UIKit.UIFont, cornerRadius: CoreFoundation.CGFloat, activityEffectsViewAlpha: CoreFoundation.CGFloat, activityIndicator: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration)
}
public struct RecordButtonConfiguration {
  public var strokeColor: CoreGraphics.CGColor
  public var gradientColors: [CoreGraphics.CGColor]
  public var circularTimeLineIdleWidth: CoreFoundation.CGFloat
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var defaultVideoRecordButtonColor: UIKit.UIColor
  public var defaultTakePhotoButtonColor: UIKit.UIColor
  public var videoRecordButtonColor: UIKit.UIColor
  public var takePhotoButtonColor: UIKit.UIColor
  public var externalCircleFullColor: CoreGraphics.CGColor
  public var externalCircleStrokeColor: CoreGraphics.CGColor
}
public enum RecorderPreviewScalingMode {
  case aspectFill
  case aspectFit
  public static func == (a: UnifiedVideoEditorSDK.RecorderPreviewScalingMode, b: UnifiedVideoEditorSDK.RecorderPreviewScalingMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TrimVideoConfiguration {
  public var saveButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var backButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var trimTimeLineConfiguration: UnifiedVideoEditorSDK.TrimTimeLineConfiguration
  public var trimTimeLineHeight: CoreFoundation.CGFloat
  public var playerControlConfiguration: UnifiedVideoEditorSDK.PlayerControlConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var controlsPanelBackgroundColor: UIKit.UIColor
  public var trimmerPanelBackgroundColor: UIKit.UIColor
  public var timeLabelsConfiguration: UnifiedVideoEditorSDK.TextConfiguration
}
public struct TimeLineConfiguration {
  public var isTimeLineHidden: Swift.Bool
  public var timeLineBackgroundColor: UIKit.UIColor
  public var progressBarColor: UIKit.UIColor
  public var progressBarSelectColor: UIKit.UIColor
  public var itemsCornerRadius: CoreFoundation.CGFloat
  public var separatorWidth: CoreFoundation.CGFloat
  public var separatorColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
}
public struct TransitionActionConfiguration {
  public let imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public let height: CoreFoundation.CGFloat
  public let clickableWidth: CoreFoundation.CGFloat
  public let backgroundColor: UIKit.UIColor
  public let cornerRadius: CoreFoundation.CGFloat
  public let shadowColor: UIKit.UIColor
  public init(imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, height: CoreFoundation.CGFloat, clickableWidth: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, shadowColor: UIKit.UIColor)
}
@objc public class TrimTimeLineConfiguration : ObjectiveC.NSObject {
  public var controlsColor: UIKit.UIColor
  public var cursorColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var trimContentCornerRadius: CoreFoundation.CGFloat
  public var timelineTopBottomInset: CoreFoundation.CGFloat
  public var draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration
  public var transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]?
  public init(controlsColor: UIKit.UIColor, cursorColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat, trimContentCornerRadius: CoreFoundation.CGFloat, timelineTopBottomInset: CoreFoundation.CGFloat, draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration, transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]? = nil)
  @objc deinit
}
@objc public class CompositionTimelineConfiguration : ObjectiveC.NSObject {
  public var controlsColor: UIKit.UIColor
  public var cursorColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var contentCornerRadius: CoreFoundation.CGFloat
  public var timelineTopBottomInset: CoreFoundation.CGFloat
  public var draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration
  public var transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]?
  public init(controlsColor: UIKit.UIColor, cursorColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat, contentCornerRadius: CoreFoundation.CGFloat, timelineTopBottomInset: CoreFoundation.CGFloat, draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration, transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]? = nil)
  @objc deinit
}
public struct DraggerConfiguration {
  public var backgroundConfiguraiton: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var numberOfLinesInDraggers: Swift.Int
  public var draggerLineSize: CoreFoundation.CGSize
  public var draggerLineBackgroundConfiguraion: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var draggerImageName: Swift.String?
  public var draggerSize: CoreFoundation.CGSize
  public init(backgroundConfiguraiton: UnifiedVideoEditorSDK.BackgroundConfiguration, draggerImageName: Swift.String?, draggerSize: CoreFoundation.CGSize, numberOfLinesInDraggers: Swift.Int, draggerLineSize: CoreFoundation.CGSize, draggerLineBackgroundConfiguraion: UnifiedVideoEditorSDK.BackgroundConfiguration)
}
public struct EditorConfiguration {
  public var additionalEffectsButtons: [UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration]
  public var additionalEffectsButtonsBottomOffset: CoreFoundation.CGFloat
  public var videoResolution: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var saveButton: UnifiedVideoEditorSDK.BanubaButtonConfiguration
  public var backButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var editDraftBackButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var openTrimButton: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration
  public var musicPanelConfiguration: UnifiedVideoEditorSDK.MusicPanelConfiguration
  public enum AddToDraftsFlow {
    case alert
    case button(_: UnifiedVideoEditorSDK.RoundedButtonConfiguration)
  }
  public var addToDraftsFlow: UnifiedVideoEditorSDK.EditorConfiguration.AddToDraftsFlow
  public var isVideoAspectFillEnabled: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
}
public struct SharingScreenConfiguration {
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var videoImageViewCornerRadius: CoreFoundation.CGFloat
  public var sharingVideoTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var closeButtonConfiguration: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var sharingModels: [UnifiedVideoEditorSDK.SharingServiceModel]
  public var sharingCellConfiguration: UnifiedVideoEditorSDK.SharingCellConfiguration
  public var facebookId: Swift.String
  public init(sharingModels: [UnifiedVideoEditorSDK.SharingServiceModel], videoImageViewCornerRadius: CoreFoundation.CGFloat, sharingVideoTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, sharingCellConfiguration: UnifiedVideoEditorSDK.SharingCellConfiguration, closeButtonConfiguration: UnifiedVideoEditorSDK.RoundedButtonConfiguration, facebookId: Swift.String)
}
public struct SharingCellConfiguration {
  public let titleTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public init(titleTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct GifPickerConfiguration {
  public var dragIndicatorColor: UIKit.UIColor
  public var regularFont: UIKit.UIFont
  public var boldFont: UIKit.UIFont
  public var activityConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public var cursorColor: UIKit.UIColor
  public var searchBarTextColor: UIKit.UIColor
  public var gifResolution: UnifiedVideoEditorSDK.GiphyResolution
  public var giphyAPIKey: Swift.String?
  public var preferredRating: Swift.String?
  public var tryAgainButtonColor: UIKit.UIColor
  public var mode: UnifiedVideoEditorSDK.GifPickerMode
}
public enum GifPickerMode : Swift.Equatable {
  case search
  case list([Swift.String])
  public static func == (a: UnifiedVideoEditorSDK.GifPickerMode, b: UnifiedVideoEditorSDK.GifPickerMode) -> Swift.Bool
}
public struct TrimVideosConfiguration {
  public var videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var backButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var nextButtonConfiguration: UnifiedVideoEditorSDK.ImageTextButtonConfiguration
  public var controlsPanelBackgroundColor: UIKit.UIColor
  public var playerControlConfiguration: UnifiedVideoEditorSDK.PlayerControlConfiguration
  public var videoPartsBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var aspectsButton: UnifiedVideoEditorSDK.ImageButtonConfiguration?
  public var timeLabelsConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var editVideoItemTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var editVideoItems: [UnifiedVideoEditorSDK.TrimVideoCompositionEditItem]
  public var videoPartConfiguration: UnifiedVideoEditorSDK.TrimVideoPartConfiguration
  public var reorderingVideoToolTipLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var trimTimelineConfiguration: UnifiedVideoEditorSDK.TrimTimeLineConfiguration
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
}
public struct TrimVideoPartConfiguration {
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var timeLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public init(borderWidth: CoreFoundation.CGFloat, borderColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, timeLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct TrimVideoCompositionEditItem {
  public enum TrimVideoCompositionEditItemType : Swift.CaseIterable {
    case rotate
    case split
    case delete
    case trim
    public static func == (a: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType, b: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType]
    public static var allCases: [UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public let title: Swift.String
  public let icon: UnifiedVideoEditorSDK.ImageConfiguration
  public let type: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType
  public init(title: Swift.String, icon: UnifiedVideoEditorSDK.ImageConfiguration, type: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType)
}
public struct FilterConfiguration {
  public var controlButtons: [UnifiedVideoEditorSDK.FilterControlButtonConfig]
  public var controlsPanelBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var resetButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var toolTipLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var cursorButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public var effectItemConfiguration: UnifiedVideoEditorSDK.EffectItemConfiguration
  public var doneButtonHeight: CoreFoundation.CGFloat?
  public var timelineHeight: CoreFoundation.CGFloat
  public var timelineLeftOffset: CoreFoundation.CGFloat
  public var timelineRightOffset: CoreFoundation.CGFloat
  public var filtersHeight: CoreFoundation.CGFloat
  public var preferredLutsOrder: [Swift.String]
  public var preferredMasksOrder: [Swift.String]
  public var preferredVideoEffectOrderAndSet: [UnifiedVideoEditorSDK.VisualEffectApplicatorType]
  public var colorEffectsURL: Foundation.URL
}
public typealias TimerOptionBarConfiguration = UnifiedVideoEditorSDK.HandsfreeConfiguration.TimerOptionBarConfiguration
public struct HandsfreeConfiguration {
  public struct TimerOptionBarConfiguration {
    public var selectorColor: UIKit.UIColor
    public var selectorTextColor: UIKit.UIColor
    public var selectorTextFont: UIKit.UIFont
    public var selectorBorderWidth: CoreFoundation.CGFloat
    public var selectorBorderColor: CoreGraphics.CGColor
    public var optionBackgroundColor: UIKit.UIColor
    public var optionCornerRadius: CoreFoundation.CGFloat
    public var optionTextColor: UIKit.UIColor
    public var optionTextFont: UIKit.UIFont
    public var backgroundColor: UIKit.UIColor
    public var backgroundViewColor: UIKit.UIColor
    public var cornerRadius: CoreFoundation.CGFloat
    public var sliderCornerRadius: CoreFoundation.CGFloat
    public var barCornerRadius: CoreFoundation.CGFloat
    public var selectorEdgeInsets: UIKit.UIEdgeInsets
    public var activeThumbAndLineColor: UIKit.UIColor
    public var inactiveThumbAndLineColor: UIKit.UIColor
    public var minVideoDuration: Swift.Double
    public var buttonCornerRadius: CoreFoundation.CGFloat
    public var buttonBackgroundColor: UIKit.UIColor
    public var modeTitleColor: UIKit.UIColor
    public var dragTitleColor: UIKit.UIColor
    public var dragTitleFont: UIKit.UIFont
    public var buttonTitleColor: UIKit.UIColor
    public var buttonTitleFont: UIKit.UIFont
    public var currentValueTextColor: UIKit.UIColor
    public var minimumValueTextColor: UIKit.UIColor
    public var maximumValueTextColor: UIKit.UIColor
    public var currentValueTextFont: UIKit.UIFont
    public var minimumValueTextFont: UIKit.UIFont
    public var maximumValueTextFont: UIKit.UIFont
    public var thumbLineViewColor: UIKit.UIColor
    public var thumbLineViewBackgroundColor: UIKit.UIColor
    public var cursorViewColor: UIKit.UIColor
    public init(selectorColor: UIKit.UIColor, selectorTextColor: UIKit.UIColor, selectorTextFont: UIKit.UIFont, selectorBorderWidth: CoreFoundation.CGFloat, selectorBorderColor: CoreGraphics.CGColor, optionBackgroundColor: UIKit.UIColor, optionCornerRadius: CoreFoundation.CGFloat, optionTextColor: UIKit.UIColor, optionTextFont: UIKit.UIFont, backgroundColor: UIKit.UIColor, backgroundViewColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, sliderCornerRadius: CoreFoundation.CGFloat, barCornerRadius: CoreFoundation.CGFloat, selectorEdgeInsets: UIKit.UIEdgeInsets, activeThumbAndLineColor: UIKit.UIColor, inactiveThumbAndLineColor: UIKit.UIColor, minVideoDuration: Swift.Double, buttonCornerRadius: CoreFoundation.CGFloat, buttonBackgroundColor: UIKit.UIColor, modeTitleColor: UIKit.UIColor, dragTitleColor: UIKit.UIColor, dragTitleFont: UIKit.UIFont, buttonTitleColor: UIKit.UIColor, buttonTitleFont: UIKit.UIFont, currentValueTextColor: UIKit.UIColor, minimumValueTextColor: UIKit.UIColor, maximumValueTextColor: UIKit.UIColor, currentValueTextFont: UIKit.UIFont, minimumValueTextFont: UIKit.UIFont, maximumValueTextFont: UIKit.UIFont, thumbLineViewColor: UIKit.UIColor, thumbLineViewBackgroundColor: UIKit.UIColor, cursorViewColor: UIKit.UIColor)
  }
  public var timerOptionBarConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration.TimerOptionBarConfiguration
  public init(timerOptionBarConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration.TimerOptionBarConfiguration)
}
public class ProgressViewConfiguration {
  public var messageConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var tooltipMessageConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var cancelButtonTextConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var cancelButtonBorderConfiguration: UnifiedVideoEditorSDK.BorderButtonConfiguration
  public var cancelButtonBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundViewBlurStyle: UIKit.UIBlurEffect.Style
  public var progressBarColor: UIKit.UIColor
  public var progressBarHeight: CoreFoundation.CGFloat
  public var progressBarCornerRadius: CoreFoundation.CGFloat
  public init(messageConfiguration: UnifiedVideoEditorSDK.TextConfiguration, tooltipMessageConfiguration: UnifiedVideoEditorSDK.TextConfiguration, cancelButtonTextConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration, cancelButtonBorderConfiguration: UnifiedVideoEditorSDK.BorderButtonConfiguration, cancelButtonBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, backgroundViewBlurStyle: UIKit.UIBlurEffect.Style, progressBarColor: UIKit.UIColor, progressBarHeight: CoreFoundation.CGFloat, progressBarCornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
public struct BeautyIntensityConfiguration {
  public var sliderThumbSize: CoreFoundation.CGFloat
  public var sliderTintColor: UIKit.UIColor
  public init(sliderThumbSize: CoreFoundation.CGFloat, sliderTintColor: UIKit.UIColor)
}
public struct AudioPartSelectionViewConfiguration {
  public static var musicLibraryDark: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration {
    get
  }
  public static var musicLibraryLight: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration {
    get
  }
  public static var soundstripe: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class AudioPartSelectionView : UIKit.UIView, UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) final public var didScrollHandler: ((CoreMedia.CMTimeRange) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) final public func set(audioStartOffset: Foundation.TimeInterval = .zero, audioDuration: Foundation.TimeInterval, videoDuration: Foundation.TimeInterval)
  @_Concurrency.MainActor(unsafe) final public func set(playbackProgress: Swift.Double)
  @_Concurrency.MainActor(unsafe) final public func showAudioAmplitude(samples: [Swift.Float])
  @_Concurrency.MainActor(unsafe) final public func apply(configuration: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration)
  @_Concurrency.MainActor(unsafe) final public func stopSelectionAnimationIfNeeded()
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) final public func setPlayedRangeOverlayViewHidden(_ isHidden: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func updatePlayedRangeOverlayViewLayer(completion: (() -> Swift.Void)? = nil)
  @objc deinit
}
public protocol ExternalViewControllerFactory {
  var progressViewControllerFactory: (any UnifiedVideoEditorSDK.ProgressViewControllerFactory)? { get set }
}
extension UnifiedVideoEditorSDK.ExternalViewControllerFactory {
  public var progressViewControllerFactory: (any UnifiedVideoEditorSDK.ProgressViewControllerFactory)? {
    get
    set
  }
}
public enum DrawableFigure : Swift.String, Swift.Codable {
  case circle
  case square
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Combine.Publisher {
  public func map<T>(to value: T) -> Combine.Publishers.Map<Self, T>
  public func convertToResult() -> Combine.AnyPublisher<Swift.Result<Self.Output, Self.Failure>, Swift.Never>
  public func mapSuccess<T, U, E>(_ transform: @escaping (T) -> Swift.Result<U, any Swift.Error>) -> Combine.Publishers.Map<Self, Swift.Result<U, any Swift.Error>> where E : Swift.Error, Self.Failure == Swift.Never, Self.Output == Swift.Result<T, E>
}
extension Combine.AnyPublisher {
  public static func just(_ output: Output) -> Combine.AnyPublisher<Output, Failure>
}
extension Dispatch.DispatchQueue.SchedulerTimeType.Stride {
  public static var searchFieldDebouncingTime: Dispatch.DispatchQueue.SchedulerTimeType.Stride {
    get
  }
}
public class EditorEffectModelBuilder {
  public init()
  public func gifModel(id: Swift.UInt, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  public func textModel(id: Swift.UInt, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  public func blurModel(id: Swift.UInt, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, rendererTexture: (any Metal.MTLTexture)?) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  public func makeModels(configs: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]], startId: Swift.UInt) -> [UnifiedVideoEditorSDK.VideoEditorFilterModel]
  public func makeModel(config: [UnifiedVideoEditorSDK.EditorEffectKey : Any], id: Swift.UInt) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  @objc deinit
}
public struct RoundedButtonConfiguration {
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration?
  public var borderWidth: CoreFoundation.CGFloat?
  public var borderColor: CoreGraphics.CGColor?
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var titleSpacing: CoreFoundation.CGFloat?
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration?, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat? = nil, borderColor: CoreGraphics.CGColor? = nil, width: CoreFoundation.CGFloat = 70.0, height: CoreFoundation.CGFloat = 30.0, titleSpacing: CoreFoundation.CGFloat? = 2.0)
}
public enum DeviceModel : Swift.String {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPhoneSE2
  case iPhone12
  case iPhone12Mini
  case iPhone12Pro
  case iPhone12ProMax
  case iPhone13
  case iPhone13Mini
  case iPhone13Pro
  case iPhone13ProMax
  case iPhoneSE3
  case iPhone14
  case iPhone14Plus
  case iPhone14Pro
  case iPhone14ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPad8
  case iPad9
  case iPad10
  case iPadAir4
  case iPadAir5
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadMini6
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case iPadPro11Inch2
  case iPadPro12Inch4
  case iPadPro11Inch3
  case iPadPro12Inch5
  case iPadPro11Inch4
  case iPadPro12Inch6
  case simulator
  case unknown
  public static var current: UnifiedVideoEditorSDK.DeviceModel {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> UnifiedVideoEditorSDK.DeviceModel
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) public func addArrangedSubviews(_ subviews: [UIKit.UIView])
  @_Concurrency.MainActor(unsafe) public func removeAllArrangedSubviews()
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) public func addBackground(color: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat)
}
@_inheritsConvenienceInitializers public class RotateEffectDrawer : UnifiedVideoEditorSDK.VideoEditorEffectDrawer {
  required public init(rotation: UnifiedVideoEditorSDK.AssetRotation, isVideoFitsAspect: Swift.Bool)
  required public init()
  @objc deinit
}
extension UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.PlayerControlConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: any UnifiedVideoEditorSDK.ImageTextButtonConfigurationProtocol)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.BackButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.RoundedButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.RoundedButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.SaveButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.TextButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.TextConfiguration?, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, forState controlState: UIKit.UIControl.State)
}
public enum AssetRotation : Swift.UInt8, Swift.Codable {
  case none
  case rotate90
  case rotate180
  case rotate270
  public init?(withAngle angle: CoreFoundation.CGFloat)
  public var angle: CoreFoundation.CGFloat {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func roundCorners(cornerMask: QuartzCore.CACornerMask, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func roundCorners(radius: CoreFoundation.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class VideoEditorActivityIndicator : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func startAnimating()
  @_Concurrency.MainActor(unsafe) public func stopAnimating()
  @objc deinit
}
public enum EditorEffectType : Swift.Int {
  case transition
  case blur
  case gif
  case text
  case time
  case color
  case visual
  case transform
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol RenderEffect {
  @objc var name: Swift.String { get }
  @objc var isLoaded: Swift.Bool { get }
  @objc var isActive: Swift.Bool { get set }
  @objc func load()
  @objc func unload()
  @objc func apply(pixelBuffer: CoreVideo.CVPixelBuffer)
}
public struct MediaTrackTimeRange : Swift.Codable {
  public let startTime: CoreMedia.CMTime
  public let playingTimeRange: CoreMedia.CMTimeRange
  public init(startTime: CoreMedia.CMTime, playingTimeRange: CoreMedia.CMTimeRange)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public class MediaTrack : Swift.Codable {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var timeRange: UnifiedVideoEditorSDK.MediaTrackTimeRange
  final public let title: Swift.String?
  final public let additionalTitle: Swift.String?
  final public let isEditable: Swift.Bool
  public var id: CoreMedia.CMPersistentTrackID?
  public init(uuid: Foundation.UUID, id: CoreMedia.CMPersistentTrackID?, url: Foundation.URL, coverURL: Foundation.URL?, timeRange: UnifiedVideoEditorSDK.MediaTrackTimeRange, isEditable: Swift.Bool, title: Swift.String? = nil, additionalTitle: Swift.String? = nil)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
public protocol ReusableView : AnyObject {
}
extension UnifiedVideoEditorSDK.ReusableView {
  public static var reuseIdentifier: Swift.String {
    get
  }
}
public struct AutoCutGalleryConfiguration {
  public let normalApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration
  public let disabledApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration
  public let normalNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration
  public let disabledNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration
  public let maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval
  public init(normalApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration, disabledApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration, normalNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration, disabledNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration, maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval)
}
public struct ApplyAutoCutButtonConfiguration {
  public let borderColor: UIKit.UIColor
  public let iconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public let textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public init(borderColor: UIKit.UIColor, iconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, textConfiguration: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct GalleryNextButtonConfiguration {
  public let textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public let backgroundColor: UIKit.UIColor
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, backgroundColor: UIKit.UIColor)
}
extension Swift.Encodable {
  public func toDictionary(_ encoder: Foundation.JSONEncoder = JSONEncoder()) throws -> [Swift.String : Any]
  public func toString() throws -> Swift.String
}
public class ToastPresenter {
  public init(configuration: UnifiedVideoEditorSDK.ToastConfiguration, toastLifeTime: Foundation.TimeInterval? = nil)
  @objc deinit
  public func showToast(message: Swift.String)
}
public struct SpeedBarButtonsConfiguration {
  public var imageHalf: UnifiedVideoEditorSDK.ImageConfiguration?
  public var imageNormal: UnifiedVideoEditorSDK.ImageConfiguration?
  public var imageDouble: UnifiedVideoEditorSDK.ImageConfiguration?
  public var imageTriple: UnifiedVideoEditorSDK.ImageConfiguration?
  public var selectedTitleColor: UIKit.UIColor
  public var titleColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat?
  public init(imageHalf: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageNormal: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageDouble: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageTriple: UnifiedVideoEditorSDK.ImageConfiguration? = nil, selectedTitleColor: UIKit.UIColor, titleColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat?)
}
public struct AdditionalEffectsButtonConfiguration {
  public enum Position : Swift.Int {
    case top
    case bottom
    case center
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var identifier: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType
  public var imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?
  public var title: UnifiedVideoEditorSDK.TextButtonConfiguration?
  public var titlePosition: UnifiedVideoEditorSDK.TitlePosition?
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var position: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position?
  public var imageTitleSpacing: CoreFoundation.CGFloat?
  public var defaultTitleAlpha: CoreFoundation.CGFloat?
  public var selectedTitleAlpha: CoreFoundation.CGFloat?
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var contentInsets: CoreFoundation.CGFloat
  public init(identifier: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType, imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?, title: UnifiedVideoEditorSDK.TextButtonConfiguration? = nil, titlePosition: UnifiedVideoEditorSDK.TitlePosition? = nil, width: CoreFoundation.CGFloat = 50, height: CoreFoundation.CGFloat = 50, position: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position? = nil, imageTitleSpacing: CoreFoundation.CGFloat? = nil, defaultTitleAlpha: CoreFoundation.CGFloat? = nil, selectedTitleAlpha: CoreFoundation.CGFloat? = nil, cornerRadius: CoreFoundation.CGFloat = .zero, backgroundColor: UIKit.UIColor = .clear, contentInsets: CoreFoundation.CGFloat = 8.5)
  public enum ButtonType : Swift.String {
    case link
    case color
    case sticker
    case text
    case time
    case effects
    case toggle
    case flashlight
    case timer
    case speed
    case beauty
    case muteSound
    case blur
    case trimDraft
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum TitlePosition {
  case top
  case left
  case right
  case bottom
  public static func == (a: UnifiedVideoEditorSDK.TitlePosition, b: UnifiedVideoEditorSDK.TitlePosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public enum DraftsFeatureConfig : Swift.Int, Swift.CaseIterable {
  case enabled = 0
  case enabledSaveToDraftsByDefault = 1
  case disabled = 2
  case enabledAskIfSaveNotExport = 3
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UnifiedVideoEditorSDK.DraftsFeatureConfig]
  public typealias RawValue = Swift.Int
  public static var allCases: [UnifiedVideoEditorSDK.DraftsFeatureConfig] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public struct FeatureConfiguration {
  public var isBlurEnabled: Swift.Bool
  public var isBlurEffectsExportable: Swift.Bool
  public var isOverlayEditorEnabled: Swift.Bool
  public var isDoubleTapForToggleCameraEnabled: Swift.Bool
  public var isMuteCameraAudioEnabled: Swift.Bool
  public var isVideoCoverSelectionEnabled: Swift.Bool
  public var supportsTrimRecordedVideo: Swift.Bool
  public var draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig
  public var isAspectsEnabled: Swift.Bool
  public var isSpeedBarEnabled: Swift.Bool
  public var isVideoFitsAspect: Swift.Bool
  public var openAutomaticallyPIPSettingsDropdown: Swift.Bool
  public var useTransitions: Swift.Bool
  public var isDraftSavedToastEnabled: Swift.Bool
  public static let `default`: UnifiedVideoEditorSDK.FeatureConfiguration
  public init(isOverlayEditorEnabled: Swift.Bool, isDoubleTapForToggleCameraEnabled: Swift.Bool, isMuteCameraAudioEnabled: Swift.Bool, isVideoCoverSelectionEnabled: Swift.Bool, supportsTrimRecordedVideo: Swift.Bool, draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig, isAspectsEnabled: Swift.Bool, isSpeedBarEnabled: Swift.Bool, isVideoFitsAspect: Swift.Bool, isBlurEnabled: Swift.Bool, isBlurEffectsExportable: Swift.Bool, openAutomaticallyPIPSettingsDropdown: Swift.Bool, useTransitions: Swift.Bool, isDraftSavedToastEnabled: Swift.Bool)
}
public struct RecorderEffectsConfiguration {
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var effectsHeight: CoreFoundation.CGFloat
  public var effectItemConfiguration: UnifiedVideoEditorSDK.EffectItemConfiguration
  public var effectAdditionalMediaPickerConfiguration: UnifiedVideoEditorSDK.EffectAdditionalMediaPickerConfiguration
  public var preferredLutsOrder: [Swift.String]
  public var preferredMasksOrder: [Swift.String]
  public init(cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, effectsHeight: CoreFoundation.CGFloat, effectItemConfiguration: UnifiedVideoEditorSDK.EffectItemConfiguration, effectAdditionalMediaPickerConfiguration: UnifiedVideoEditorSDK.EffectAdditionalMediaPickerConfiguration, preferredLutsOrder: [Swift.String], preferredMasksOrder: [Swift.String])
}
public struct EffectAdditionalMediaPickerConfiguration {
  public var galleryAssetItemConfiguration: UnifiedVideoEditorSDK.GalleryAssetItemConfiguration
  public var infoLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var allowGalleryAccessButtonConfiguration: UnifiedVideoEditorSDK.BanubaButtonConfiguration
  public var noMediaLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var openGalleryButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public init(galleryAssetItemConfiguration: UnifiedVideoEditorSDK.GalleryAssetItemConfiguration, infoLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, allowGalleryAccessButtonConfiguration: UnifiedVideoEditorSDK.BanubaButtonConfiguration, noMediaLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, openGalleryButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration)
}
public struct GalleryAssetItemConfiguration {
  public var durationConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var cornerRadius: CoreFoundation.CGFloat
  public var selectionColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var normalImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var activityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
}
public struct MusicPanelConfiguration {
  public var floatingLineViewConfiguration: UnifiedVideoEditorSDK.TextConfiguration?
  public var floatingLineViewWidth: CoreFoundation.CGFloat?
  public var backroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration?
  public var removeMusicButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var musicPanelImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
}
public struct TimerConfiguration {
  public struct TimerOptionConfiguration : Swift.Equatable {
    public var button: UnifiedVideoEditorSDK.ImageButtonConfiguration
    public var startingTimerSeconds: Swift.Int
    public var stoppingTimerSeconds: Swift.Int
    public var description: Swift.String?
    public static func == (lhs: UnifiedVideoEditorSDK.TimerConfiguration.TimerOptionConfiguration, rhs: UnifiedVideoEditorSDK.TimerConfiguration.TimerOptionConfiguration) -> Swift.Bool
    public init(button: UnifiedVideoEditorSDK.ImageButtonConfiguration, startingTimerSeconds: Swift.Int, stoppingTimerSeconds: Swift.Int, description: Swift.String? = nil)
  }
  public var defaultButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var options: [UnifiedVideoEditorSDK.TimerConfiguration.TimerOptionConfiguration]
  public var soundPath: Swift.String?
}
public struct GalleryVideoPartsConfiguration {
  public var addGalleryVideoPartImageName: Swift.String
  public var videoPartConfiguration: UnifiedVideoEditorSDK.GalleryVideoPartsConfiguration.GalleryVideoPartConfiguration
  public init(addGalleryVideoPartImageName: Swift.String, videoPartConfiguration: UnifiedVideoEditorSDK.GalleryVideoPartsConfiguration.GalleryVideoPartConfiguration)
  public struct GalleryVideoPartConfiguration {
    public var selectionColor: UIKit.UIColor
    public var durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
    public var cornerRadius: CoreFoundation.CGFloat
    public var imageCornerRadius: CoreFoundation.CGFloat
    public var imageInsets: UIKit.UIEdgeInsets
    public var scissorsImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?
    public init(selectionColor: UIKit.UIColor, durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, cornerRadius: CoreFoundation.CGFloat, imageCornerRadius: CoreFoundation.CGFloat, imageInsets: UIKit.UIEdgeInsets, scissorsImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?)
  }
}
public struct EffectItemConfiguration {
  public var noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var titleStyle: UnifiedVideoEditorSDK.TextConfiguration
  public var defaultStateTitleAlpha: CoreFoundation.CGFloat
  public var selectionColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var borderWidth: CoreFoundation.CGFloat
  public var selectWhenHighlight: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var imageInsets: UIKit.UIEdgeInsets
  public var imageCornerRadius: CoreFoundation.CGFloat
  public var imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration?
  public var alwaysShowTitle: Swift.Bool
  public var showMasksTitle: Swift.Bool
  public var showEffectsTitle: Swift.Bool
  public var downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration?
  public var progressViewFactory: (any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory)?
  public init(noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration, titleStyle: UnifiedVideoEditorSDK.TextConfiguration, defaultStateTitleAlpha: CoreFoundation.CGFloat, selectionColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, borderWidth: CoreFoundation.CGFloat, selectWhenHighlight: Swift.Bool, backgroundColor: UIKit.UIColor, imageInsets: UIKit.UIEdgeInsets, imageCornerRadius: CoreFoundation.CGFloat, imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration? = nil, alwaysShowTitle: Swift.Bool, showMasksTitle: Swift.Bool, showEffectsTitle: Swift.Bool, downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration? = nil, progressViewFactory: (any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory)? = nil)
}
public struct BanubaButtonConfiguration {
  public var imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?
  public var title: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var titlePosition: UnifiedVideoEditorSDK.TitlePosition
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var background: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var imageTitleSpacing: CoreFoundation.CGFloat
  public init(title: UnifiedVideoEditorSDK.TextButtonConfiguration, titlePosition: UnifiedVideoEditorSDK.TitlePosition = .bottom, width: CoreFoundation.CGFloat = 50, height: CoreFoundation.CGFloat = 50, background: UnifiedVideoEditorSDK.BackgroundConfiguration, imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageTitleSpacing: CoreFoundation.CGFloat = 0.0)
}
public struct TimeLabelConfiguration {
  public var textInsets: UIKit.UIEdgeInsets
  public var cornerRadius: CoreFoundation.CGFloat
  public var defaultColor: UIKit.UIColor
  public var errorColor: UIKit.UIColor
  public var style: UnifiedVideoEditorSDK.TextConfiguration
  public init(textInsets: UIKit.UIEdgeInsets, cornerRadius: CoreFoundation.CGFloat, defaultColor: UIKit.UIColor, errorColor: UIKit.UIColor, style: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct VideoCoverSelectionConfiguration {
  public var cancelButton: UnifiedVideoEditorSDK.BanubaButtonConfiguration
  public var doneButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var titleLabel: UnifiedVideoEditorSDK.TextConfiguration?
  public var toolTipLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var selectGalleryImageButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var deleteGalleryImageConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var previewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var thumbnailsCursorConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var numberOfThumbnails: Swift.Int
  public var galleryImageCompressionQuality: CoreFoundation.CGFloat
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var isGalleryButtonHidden: Swift.Bool
  public var bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public init(cancelButton: UnifiedVideoEditorSDK.BanubaButtonConfiguration, doneButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration, titleLabel: UnifiedVideoEditorSDK.TextConfiguration?, toolTipLabel: UnifiedVideoEditorSDK.TextConfiguration, selectGalleryImageButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration, deleteGalleryImageConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, previewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, thumbnailsCursorConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration, numberOfThumbnails: Swift.Int, galleryImageCompressionQuality: CoreFoundation.CGFloat, preferredStatusBarStyle: UIKit.UIStatusBarStyle, isGalleryButtonHidden: Swift.Bool, bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, timelineCornerRadius: CoreFoundation.CGFloat)
}
public struct FilterControlButtonConfig {
  public enum `Type` : Swift.String {
    case cancel
    case play
    case done
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type`
  public let imageName: Swift.String
  public let selectedImageName: Swift.String?
  public let imageEdgeInsets: UIKit.UIEdgeInsets?
  public var tintColor: UIKit.UIColor?
  public var image: UIKit.UIImage?
  public var selectedImage: UIKit.UIImage?
  public init(type: UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type`, imageName: Swift.String, selectedImageName: Swift.String?, imageEdgeInsets: UIKit.UIEdgeInsets? = nil, tintColor: UIKit.UIColor? = nil)
}
@objc public class ImageConfiguration : ObjectiveC.NSObject, UnifiedVideoEditorSDK.ImageConfigurationProtocol {
  public var imageName: Swift.String
  @objc public var tintColor: UIKit.UIColor?
  @objc public var image: UIKit.UIImage? {
    @objc get
  }
  public init(imageName: Swift.String, tintColor: UIKit.UIColor? = nil)
  public init(image: UIKit.UIImage, tintColor: UIKit.UIColor? = nil)
  @objc deinit
}
public struct ImageButtonConfiguration : UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol {
  public var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public init(imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil)
  public mutating func setTintColor(_ tintColor: UIKit.UIColor)
}
public struct ImageTextButtonConfiguration : UnifiedVideoEditorSDK.ImageTextButtonConfigurationProtocol {
  public var imageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var style: UnifiedVideoEditorSDK.TextConfiguration?
  public init(imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil, selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil, style: UnifiedVideoEditorSDK.TextConfiguration? = nil)
  public mutating func setTintColor(_ tintColor: UIKit.UIColor)
}
public struct DraftsConfiguration {
  public var backButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var title: UnifiedVideoEditorSDK.TextConfiguration
  public var draftItem: UnifiedVideoEditorSDK.DraftItemConfiguration
  public var backgroundColor: UIKit.UIColor
  public var emptyDraftsImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var emptyDraftsLabel: UnifiedVideoEditorSDK.TextConfiguration
}
public struct ActionMenuConfiguration {
  public var dragIndicatorColor: UIKit.UIColor
  public var bacgroundViewCornerRadius: CoreFoundation.CGFloat
  public var previewImageViewCornerRadius: CoreFoundation.CGFloat
}
public struct DraftItemConfiguration {
  public var infoLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var subinfoLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var menuButtonImage: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var menuButtonBackgroundColor: UIKit.UIColor
  public var menuButtonImageEdgeInsets: UIKit.UIEdgeInsets
  public var cornerRadius: CoreFoundation.CGFloat
  public var menuItems: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType]
  public init(infoLabel: UnifiedVideoEditorSDK.TextConfiguration, subinfoLabel: UnifiedVideoEditorSDK.TextConfiguration, menuButtonImage: UnifiedVideoEditorSDK.ImageButtonConfiguration, menuButtonBackgroundColor: UIKit.UIColor, menuButtonImageEdgeInsets: UIKit.UIEdgeInsets, cornerRadius: CoreFoundation.CGFloat, menuItems: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType])
}
public enum DraftMenuItemType {
  case edite
  case remove
  public static func == (a: UnifiedVideoEditorSDK.DraftMenuItemType, b: UnifiedVideoEditorSDK.DraftMenuItemType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct DraftMenuItem {
  public var type: UnifiedVideoEditorSDK.DraftMenuItemType
  public var name: UnifiedVideoEditorSDK.TextConfiguration
  public var image: UnifiedVideoEditorSDK.ImageConfiguration?
  public init(type: UnifiedVideoEditorSDK.DraftMenuItemType, name: UnifiedVideoEditorSDK.TextConfiguration, image: UnifiedVideoEditorSDK.ImageConfiguration?)
}
public struct EffectListItemConfiguration {
  public enum `Type` : Swift.Equatable {
    case aspect(UnifiedVideoEditorSDK.AspectRatio)
    case transition(UnifiedVideoEditorSDK.TransitionType)
    public static func == (a: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, b: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`) -> Swift.Bool
  }
  public var effect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`
  public var icon: UnifiedVideoEditorSDK.ImageConfiguration?
  public var title: UnifiedVideoEditorSDK.TextConfiguration
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var selectedColor: UIKit.UIColor
  public init(effect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, icon: UnifiedVideoEditorSDK.ImageConfiguration?, title: UnifiedVideoEditorSDK.TextConfiguration, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, selectedColor: UIKit.UIColor)
}
public struct EffectsListConfiguration {
  public var cancelButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var doneButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var playPauseButton: UnifiedVideoEditorSDK.PlayerControlConfiguration?
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundControlsViewColor: UIKit.UIColor
  public var effects: [UnifiedVideoEditorSDK.EffectListItemConfiguration]
  public var defaultEffect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`
  public var primaryAspect: UnifiedVideoEditorSDK.AspectRatio?
  public init(cancelButton: UnifiedVideoEditorSDK.ImageButtonConfiguration, doneButton: UnifiedVideoEditorSDK.ImageButtonConfiguration, playPauseButton: UnifiedVideoEditorSDK.PlayerControlConfiguration?, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, backgroundControlsViewColor: UIKit.UIColor, effects: [UnifiedVideoEditorSDK.EffectListItemConfiguration], defaultEffect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, primaryAspect: UnifiedVideoEditorSDK.AspectRatio? = nil)
}
public struct VideoOverlayItemViewConfiguration {
  public var scaleIconWidth: CoreFoundation.CGFloat
  public var scaleIconHeight: CoreFoundation.CGFloat
  public var overlaySelectedBorderWidth: CoreFoundation.CGFloat
  public var overlaySelectedBorderColor: CoreGraphics.CGColor
  public var scaleIconImageName: Swift.String
  public var blurItemMinSize: CoreFoundation.CGSize
  public init(scaleIconWidth: CoreFoundation.CGFloat, scaleIconHeight: CoreFoundation.CGFloat, overlaySelectedBorderWidth: CoreFoundation.CGFloat, overlaySelectedBorderColor: CoreGraphics.CGColor, scaleIconImageName: Swift.String, blurItemMinSize: CoreFoundation.CGSize)
}
public struct VideoEditorEffectItemConfiguration {
  public var noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var defaultTitleStyle: UnifiedVideoEditorSDK.TextConfiguration
  public var selectedTitleStyle: UnifiedVideoEditorSDK.TextConfiguration
  public var selectionColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration?
  public var downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration?
  public var progressViewFactory: any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory
  public init(noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration, defaultTitleStyle: UnifiedVideoEditorSDK.TextConfiguration, selectedTitleStyle: UnifiedVideoEditorSDK.TextConfiguration, selectionColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration? = nil, downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration? = nil, progressViewFactory: any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory = CircularProgressViewFactory())
}
@objc @_inheritsConvenienceInitializers public class VideoImageEffectDrawersFactory : ObjectiveC.NSObject {
  public static let normalDrawer: any UnifiedVideoEditorSDK.VideoImageEffectDrawable
  public static func drawer(for image: CoreGraphics.CGImage) -> any UnifiedVideoEditorSDK.VideoImageEffectDrawable
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class AlertViewController : UIKit.UIViewController, UnifiedVideoEditorSDK.NibLoadable {
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var contextView: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var backgroundView: UIKit.UIView!
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  public enum AlertType {
    case info
    case selection(_: Swift.String?, _: Swift.String?)
    case reset(_: Swift.String?, _: Swift.String?, _: Swift.String?)
    case missedPermission
    case recordingWithoutMask
  }
  public enum ButtonType {
    case agreeButton
    case refuseButton
    case additionalButton
    public static func == (a: UnifiedVideoEditorSDK.AlertViewController.ButtonType, b: UnifiedVideoEditorSDK.AlertViewController.ButtonType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var titleText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var messageText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.AlertViewConfiguration?
  @_Concurrency.MainActor(unsafe) public var actionHandler: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class AutoCutEffectsStack {
  final public var isEmpty: Swift.Bool {
    get
  }
  final public func addEffect(_ effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
  final public func getAllEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getAllEffects() -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
extension Swift.Double {
  public func rounded(toPlaces places: Swift.Int, rule: Swift.FloatingPointRoundingRule? = nil) -> Swift.Double
}
extension Swift.CaseIterable where Self : Swift.Equatable {
  public var next: Self {
    get
  }
}
@objc public protocol AREffect {
  @objc var title: Swift.String { get }
  @objc var previewImage: Foundation.URL { get }
  @objc var downloadLink: Foundation.URL { get }
  @objc var isDownloaded: Swift.Bool { get }
  @objc var localURL: Foundation.URL? { get set }
  @objc var type: Swift.String? { get }
}
public protocol EffectsApplicatorServicing : AnyObject {
  var blurApplicatorService: any UnifiedVideoEditorSDK.BlurApplicatorServicing { get }
  init(editor: any UnifiedVideoEditorSDK.VideoEditorServicing, effectConfigHolder: any UnifiedVideoEditorSDK.EffectsHolderServicing)
  func applyVisualEffectApplicatorType(_ type: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
  func applyAutoCutVisualEffect(applicatorType: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, effectId: Swift.UInt)
  func applySpeedEffectType(_ type: UnifiedVideoEditorSDK.SpeedEffectType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
  func applyOverlayEffectType(_ type: UnifiedVideoEditorSDK.OverlayEffectApplicatorType, effectInfo: UnifiedVideoEditorSDK.VideoEditorEffectInfo)
  func addTransformEffect(atStartTime start: CoreMedia.CMTime, end: CoreMedia.CMTime, rotation: UnifiedVideoEditorSDK.AssetRotation, isVideoFitsAspect: Swift.Bool)
  func applyTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, effectInfo: UnifiedVideoEditorSDK.TransitionEffectInfo)
  func applyAutoCutTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
}
public class EffectApplicator : UnifiedVideoEditorSDK.EffectsApplicatorServicing {
  final public let blurApplicatorService: any UnifiedVideoEditorSDK.BlurApplicatorServicing
  required public init(editor: any UnifiedVideoEditorSDK.VideoEditorServicing, effectConfigHolder: any UnifiedVideoEditorSDK.EffectsHolderServicing)
  @objc deinit
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyVisualEffectApplicatorType(_ type: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
  public func applyAutoCutVisualEffect(applicatorType: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, effectId: Swift.UInt)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applySpeedEffectType(_ type: UnifiedVideoEditorSDK.SpeedEffectType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyOverlayEffectType(_ type: UnifiedVideoEditorSDK.OverlayEffectApplicatorType, effectInfo: UnifiedVideoEditorSDK.VideoEditorEffectInfo)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyColorEffect(name: Swift.String, lutUrl: Foundation.URL, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func addTransformEffect(atStartTime start: CoreMedia.CMTime, end: CoreMedia.CMTime, rotation: UnifiedVideoEditorSDK.AssetRotation, isVideoFitsAspect: Swift.Bool)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, effectInfo: UnifiedVideoEditorSDK.TransitionEffectInfo)
  public func applyAutoCutTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
}
public protocol NibLoadable : AnyObject {
  static var nib: UIKit.UINib { get }
}
extension UnifiedVideoEditorSDK.NibLoadable {
  public static var nib: UIKit.UINib {
    get
  }
}
extension UnifiedVideoEditorSDK.NibLoadable where Self : UIKit.UIView {
  public static func loadFromNib() -> Self
}
@_inheritsConvenienceInitializers public class ColorEffectDrawer : UnifiedVideoEditorSDK.VideoEditorEffectDrawer {
  required public init()
  @objc deinit
}
public protocol VideoEditorImageAssetProtocol : AnyObject {
  var duration: Foundation.TimeInterval { get }
  var image: CoreGraphics.CGImage? { get }
  var shouldUseImageEffect: Swift.Bool { get }
  func getOrPreloadImage() -> CoreGraphics.CGImage?
  func unloadImage()
}
public class VideoEditorFilterModel {
  public var id: Swift.UInt {
    get
  }
  public var tokenId: Swift.String {
    get
  }
  final public let filterType: UnifiedVideoEditorSDK.EditorEffectType
  final public let name: Swift.String
  final public let path: Swift.String
  final public let contentLocationType: UnifiedVideoEditorSDK.ContentLocationType
  public var preview: Foundation.URL?
  public var additionalParameters: [Swift.String : Any]?
  public var rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)? {
    get
  }
  convenience public init(name: Swift.String, type: UnifiedVideoEditorSDK.EditorEffectType, contentLocationType: UnifiedVideoEditorSDK.ContentLocationType = .local, renderer: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)?, path: Swift.String = "", id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, preview: Foundation.URL? = nil, additionalParameters: [Swift.String : Any]?)
  public init(name: Swift.String, type: UnifiedVideoEditorSDK.EditorEffectType, contentLocationType: UnifiedVideoEditorSDK.ContentLocationType = .local, renderer: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)?, path: Swift.String = "", speed: UnifiedVideoEditorSDK.EffectSpeed = .normal, transition: UnifiedVideoEditorSDK.TransitionType = .normal, id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, preview: Foundation.URL? = nil, additionalParameters: [Swift.String : Any]?)
  @objc deinit
}
public func BNBLocalizedString(_ key: Swift.String) -> Swift.String
public enum VideoResolution : Swift.String {
  case uhd3840x2160
  case qhd2560x1440
  case hd1920x1080
  case hd1280x720
  case md960x540
  case default854x480
  public var isFullHDEnabled: Swift.Bool {
    get
  }
  public var сaptureSessionPreset: AVFoundation.AVCaptureSession.Preset {
    get
  }
  public var assetExportPreset: Swift.String {
    get
  }
  public var size: CoreFoundation.CGSize {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CameraVideoResolution {
  case auto
  case vga854x480
  case hd1280x720
  case hd1920x1080
  public var сaptureSessionPreset: AVFoundation.AVCaptureSession.Preset? {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  public static func == (a: UnifiedVideoEditorSDK.CameraVideoResolution, b: UnifiedVideoEditorSDK.CameraVideoResolution) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct VideoResolutionConfiguration {
  public var `default`: UnifiedVideoEditorSDK.VideoResolution
  public var cameraVideoResolution: UnifiedVideoEditorSDK.CameraVideoResolution
  public let resolutions: [UnifiedVideoEditorSDK.DeviceModel : UnifiedVideoEditorSDK.VideoResolution]
  public let thumbnailHeights: [UnifiedVideoEditorSDK.DeviceModel : CoreFoundation.CGFloat]
  public let defaultThumbnailHeight: CoreFoundation.CGFloat
  public var current: UnifiedVideoEditorSDK.VideoResolution {
    get
  }
  public var currentThumbnailHeight: CoreFoundation.CGFloat {
    get
  }
  public init(default: UnifiedVideoEditorSDK.VideoResolution, cameraVideoResolution: UnifiedVideoEditorSDK.CameraVideoResolution = .auto, resolutions: [UnifiedVideoEditorSDK.DeviceModel : UnifiedVideoEditorSDK.VideoResolution], thumbnailHeights: [UnifiedVideoEditorSDK.DeviceModel : CoreFoundation.CGFloat], defaultThumbnailHeight: CoreFoundation.CGFloat)
}
extension AVFoundation.AVCaptureSession.Preset {
  public mutating func downgrade()
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func dropShadow(_ offset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), blur: CoreFoundation.CGFloat = 1, opacity: Swift.Float = 1)
}
public struct ToastConfiguration {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var cornerRadius: CoreFoundation.CGFloat
  public var textColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: UIKit.UIColor
  public var contentInsets: UIKit.UIEdgeInsets
  public var insets: UIKit.UIEdgeInsets
  public var icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public init(kern: Swift.Double, font: UIKit.UIFont, cornerRadius: CoreFoundation.CGFloat, textColor: UIKit.UIColor = .white, backgroundColor: UIKit.UIColor = .black, borderWidth: CoreFoundation.CGFloat = .zero, borderColor: UIKit.UIColor = .clear, contentInsets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 15.0,
      left: 15.0,
      bottom: 15.0,
      right: 15.0
    ), insets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 70.0,
      left: 16.0,
      bottom: .zero,
      right: 16.0
    ), icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? = nil)
}
extension UnifiedVideoEditorSDK.ToastConfiguration {
  public static var `default`: UnifiedVideoEditorSDK.ToastConfiguration {
    get
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public class func loadFromNib() -> Self
}
public protocol AspectsServicing {
  func setupWithVideoResolution(_ videoResolution: UnifiedVideoEditorSDK.VideoResolution)
  func getAspectedVideoSize(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> CoreFoundation.CGSize
  func getAspectRatio(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> Swift.Double
}
public class AspectsService : UnifiedVideoEditorSDK.AspectsServicing {
  public var videoResolution: UnifiedVideoEditorSDK.VideoResolution
  public init()
  public func setupWithVideoResolution(_ videoResolution: UnifiedVideoEditorSDK.VideoResolution)
  public func getAspectedVideoSize(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> CoreFoundation.CGSize
  public func getAspectRatio(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> Swift.Double
  @objc deinit
}
public enum SharedLocalizedStrings {
  public enum Errors {
    public static let noInternetConnection: Swift.String
  }
  public enum Common {
    public static let ok: Swift.String
    public static let yes: Swift.String
    public static let no: Swift.String
  }
  public enum Alert {
    public static let settings: Swift.String
    public static let refuseSettings: Swift.String
  }
  public enum Gallery {
    public static let damagedFile: Swift.String
    public static let exportVideoFailed: Swift.String
  }
  public enum AutoCut {
  }
}
extension Swift.String {
  public func height(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
  public func width(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
}
extension Swift.Array where Element : Swift.Hashable {
  public func uniqued() -> [Element]
}
@_hasMissingDesignatedInitializers public class MetalVerticesAndUVData {
  public static let quadVertexData: [Swift.Float]
  public static func quadVertexData(scale: Swift.Float) -> [Swift.Float]
  public static let defaultTextureCoordinates: [Swift.Float]
  @objc deinit
}
public struct ImagePoints {
  public init(leftTop: CoreFoundation.CGPoint, rightTop: CoreFoundation.CGPoint, leftBottom: CoreFoundation.CGPoint, rightBottom: CoreFoundation.CGPoint)
  public var leftTop: CoreFoundation.CGPoint
  public var rightTop: CoreFoundation.CGPoint
  public var leftBottom: CoreFoundation.CGPoint
  public var rightBottom: CoreFoundation.CGPoint
  public func applying(_ t: CoreFoundation.CGAffineTransform) -> UnifiedVideoEditorSDK.ImagePoints
}
public class ImageEffectInfo {
  public enum ImageSource {
    case `static`(_: CoreGraphics.CGImage)
    case dynamic(_: any UnifiedVideoEditorSDK.VideoEditorEffectImageProvider)
  }
  final public let imageSource: UnifiedVideoEditorSDK.ImageEffectInfo.ImageSource
  final public let imagePoints: UnifiedVideoEditorSDK.ImagePoints
  public init(imageSource: UnifiedVideoEditorSDK.ImageEffectInfo.ImageSource, imagePoints: UnifiedVideoEditorSDK.ImagePoints)
  @objc deinit
}
@objc public class CameraLutStage : ObjectiveC.NSObject {
  @objc public var name: Swift.String
  @objc public var isActive: Swift.Bool
  public init(file url: Foundation.URL)
  @objc deinit
}
extension UnifiedVideoEditorSDK.CameraLutStage : UnifiedVideoEditorSDK.RenderEffect {
  @objc dynamic public var isLoaded: Swift.Bool {
    @objc get
  }
  @objc dynamic public func load()
  @objc dynamic public func unload()
  @objc dynamic public func apply(pixelBuffer: CoreVideo.CVPixelBuffer)
}
public struct MetalBlendingParameters {
  public init(isBlendingEnabled: Swift.Bool, sourceRGBBlendFactor: Metal.MTLBlendFactor, destinationRGBBlendFactor: Metal.MTLBlendFactor, sourceAlphaBlendFactor: Metal.MTLBlendFactor, destinationAlphaBlendFactor: Metal.MTLBlendFactor)
}
public class MetalHelper {
  final public let commandQueue: any Metal.MTLCommandQueue
  final public let depthStencilState: any Metal.MTLDepthStencilState
  public init(libraryBundle: Foundation.Bundle)
  public func rgbaTextureForPixelBuffer(_ pixelBuffer: CoreVideo.CVPixelBuffer) -> (any Metal.MTLTexture)?
  public func createMonochromeTexture(textureData: Swift.UnsafeMutablePointer<Swift.UInt8>, width: Swift.Int, height: Swift.Int) -> any Metal.MTLTexture
  public func createRenderPipeline(vertexFunctionName: Swift.String, fragmentFunctionName: Swift.String, pixelFormat: Metal.MTLPixelFormat = .bgra8Unorm, depthPixelFormat: Metal.MTLPixelFormat? = nil, blendParameters: UnifiedVideoEditorSDK.MetalBlendingParameters? = nil, bundle: Foundation.Bundle = Bundle.main, label: Swift.String? = nil) -> (any Metal.MTLRenderPipelineState)?
  public func setupRenderPassDescriptor(destinationTexture: any Metal.MTLTexture, useBufferFetch: Swift.Bool = false) -> Metal.MTLRenderPassDescriptor
  public func setupRenderPassDescriptor(destinationTexture: any Metal.MTLTexture, depth: any Metal.MTLTexture) -> Metal.MTLRenderPassDescriptor
  public func makeBuffer<T>(array: [T]) -> any Metal.MTLBuffer
  public func makeBuffer(bytes pointer: Swift.UnsafeRawPointer, length: Swift.Int, options: Metal.MTLResourceOptions = []) -> any Metal.MTLBuffer
  public func makeTexture(descriptor: Metal.MTLTextureDescriptor) -> any Metal.MTLTexture
  public func makeDefaultUVBuffer() -> any Metal.MTLBuffer
  public func makeDefaultVertexBuffer() -> any Metal.MTLBuffer
  @objc deinit
}
extension Metal.MTLBuffer {
  public func replaceData<T>(with newData: [T])
}
@_hasMissingDesignatedInitializers public class ConnectionListener {
  final public let onConnectionChanged: ((UnifiedVideoEditorSDK.Connection) -> ())
  @objc deinit
}
public protocol ReachabilityServicing {
  var currentConnection: UnifiedVideoEditorSDK.Connection { get }
  var isInternetAvailable: Swift.Bool { get }
  func listenConnection(onConnectionChanged: @escaping ((UnifiedVideoEditorSDK.Connection) -> ())) -> UnifiedVideoEditorSDK.ConnectionListener
  func stopListenConnection(for connectionListener: UnifiedVideoEditorSDK.ConnectionListener)
}
public struct ReachabilityServiceBuilder {
  public static func build() -> (any UnifiedVideoEditorSDK.ReachabilityServicing)?
}
extension Dispatch.DispatchQueue {
  public static func checkAndPerformOnMainThreadAsync(_ block: @escaping () -> Swift.Void)
}
public struct BlurCoordinateParams : Swift.Codable {
  public var center: CoreFoundation.CGPoint
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var radius: CoreFoundation.CGFloat
  public var absoluteCenter: CoreFoundation.CGPoint
  public var absoluteRadius: CoreFoundation.CGFloat
  public static var zero: UnifiedVideoEditorSDK.BlurCoordinateParams {
    get
  }
  public init(center: CoreFoundation.CGPoint, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, radius: CoreFoundation.CGFloat)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol EffectSelectionViewControllerDelegate : AnyObject {
  func effectSelectionViewController(viewController: any UnifiedVideoEditorSDK.EffectSelectionViewController, didSelectFile url: Foundation.URL, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func effectSelectionViewControllerDidCancel(viewController: any UnifiedVideoEditorSDK.EffectSelectionViewController)
}
public protocol EffectSelectionViewController : UIKit.UIViewController {
  var effectSelectionDelegate: (any UnifiedVideoEditorSDK.EffectSelectionViewControllerDelegate)? { get set }
}
@_hasMissingDesignatedInitializers public class MetalHelperHolder {
  public static let shared: UnifiedVideoEditorSDK.MetalHelperHolder
  final public let metalHelper: UnifiedVideoEditorSDK.MetalHelper
  @objc deinit
}
extension UIKit.UIImage {
  public static func orientation(byRotation rotation: UnifiedVideoEditorSDK.AssetRotation) -> UIKit.UIImage.Orientation
}
public enum EffectType {
  case effect
  case videoEditorEffect
  public static func == (a: UnifiedVideoEditorSDK.EffectType, b: UnifiedVideoEditorSDK.EffectType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AppliedEffectsStack : UnifiedVideoEditorSDK.EffectStack {
  public func getAllEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  public func getAllEffects() -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
@objc public class BackgroundConfiguration : ObjectiveC.NSObject {
  public var cornerRadius: CoreFoundation.CGFloat
  public var color: UIKit.UIColor
  public init(cornerRadius: CoreFoundation.CGFloat, color: UIKit.UIColor)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class License : ObjectiveC.NSObject {
  @objc public var token: Swift.String {
    get
  }
  @objc public var clientId: Swift.String {
    get
  }
  @objc public var maxFaces: Swift.Int32 {
    get
  }
  @objc public var collectAnalytics: Swift.Bool {
    get
  }
  @objc public var supportsAnalytics: Swift.Bool {
    get
  }
  @objc public var videoEditorSupportsFaceAR: Swift.Bool {
    get
  }
  @objc public var hasFaceARFeatures: Swift.Bool {
    get
  }
  @objc public var postProcessingEffects: [Swift.Int] {
    get
  }
  @objc public var arCloudURL: Swift.String? {
    get
  }
  @objc public var timeBomb: UnifiedVideoEditorSDK.TimeBomb? {
    get
  }
  @objc public var supportsFHD: Swift.Bool {
    get
  }
  @objc public var isExportAPIEnabled: Swift.Bool {
    get
  }
  @objc public var isPlaybackAPIEnabled: Swift.Bool {
    get
  }
  @objc public var isVESDKEnabled: Swift.Bool {
    get
  }
  @objc public var isPhotoEditorSDKEnabled: Swift.Bool {
    get
  }
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc public static func getLicense(fromToken token: Swift.String) -> UnifiedVideoEditorSDK.License?
  public func getLicenseState(completion: @escaping ((BNBLicenseUtils.XBNBLicenseStatus) -> Swift.Void))
  @objc deinit
}
@objc public class VideoTimeLineCollectionViewHandler : ObjectiveC.NSObject {
  final public let collectionView: UIKit.UICollectionView
  final public let timeLineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource
  final public let cornerRadius: CoreFoundation.CGFloat
  public init(collectionView: UIKit.UICollectionView, timeLineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, cornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler {
  public func applyContentInset(appliedWidth: CoreFoundation.CGFloat, cursorOffset: CoreFoundation.CGFloat? = nil)
  public func applyContentOffset(_ offset: CoreFoundation.CGPoint)
  public func cellSize() -> CoreFoundation.CGSize
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler : UnifiedVideoEditorSDK.TimeLineDataSourceDelegate {
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc dynamic public func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource)
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
}
public typealias Bitrate = Swift.Int
public class ExportVideoInfo {
  public enum Resolution : Swift.String {
    case ultraHd2160
    case qhd1440
    case fullHd1080
    case hd720
    case md540
    case md480
    case ld360
    case original
    public var size: CoreFoundation.CGSize {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public let resolution: UnifiedVideoEditorSDK.ExportVideoInfo.Resolution
  final public let aspect: UnifiedVideoEditorSDK.AspectRatio?
  final public let exportSettings: UnifiedVideoEditorSDK.ExportVideoSettings
  final public let audioSettings: [Swift.String : Any]?
  public init(resolution: UnifiedVideoEditorSDK.ExportVideoInfo.Resolution, aspect: UnifiedVideoEditorSDK.AspectRatio? = nil, useHEVCCodecIfPossible: Swift.Bool, frameRate: Swift.Int = 30, scalingMode: Swift.String = AVVideoScalingModeResize, audioSettings: [Swift.String : Any]? = VESettings.audio)
  public static func setupOriginalSize(size: CoreFoundation.CGSize)
  @objc deinit
}
public struct ExportVideoInfoFactory {
  public static func assetExportSettings(resolution: UnifiedVideoEditorSDK.VideoResolution, aspect: UnifiedVideoEditorSDK.AspectRatio? = nil, useHEVCCodecIfPossible: Swift.Bool, frameRate: Swift.Int = 30, scalingMode: Swift.String = AVVideoScalingModeResize, audioSettings: [Swift.String : Any]?) -> UnifiedVideoEditorSDK.ExportVideoInfo
}
@_hasMissingDesignatedInitializers public class ExportVideoSettings {
  final public let width: Swift.Int
  final public let height: Swift.Int
  final public let aspect: UnifiedVideoEditorSDK.AspectRatio?
  final public let bitrate: UnifiedVideoEditorSDK.Bitrate
  final public let frameRate: Swift.Int
  final public let codecType: AVFoundation.AVVideoCodecType
  final public let scalingMode: Swift.String
  public var options: [Swift.String : Any] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class VideoAspectRatioCalculator {
  public static func calculateVideoAspectRatio(withVideoSize videoSize: CoreFoundation.CGSize) -> Swift.Double
  public static func adjustVideoSize(_ videoSize: CoreFoundation.CGSize, withAspectRatio aspectRatio: Swift.Double) -> CoreFoundation.CGSize
  @objc deinit
}
extension UIKit.UIColor {
  convenience public init?(colorParams: UnifiedVideoEditorSDK.ColorParams)
}
extension AVFoundation.AVAssetTrack {
  public var fixedPreferredTransform: CoreFoundation.CGAffineTransform {
    get
  }
}
public protocol PlayerStateStorable {
  var playerState: Swift.Bool { get set }
}
extension Foundation.NSNotification.Name {
  public static let videoEditorPlayerCurrentTimeChanged: Foundation.Notification.Name
}
public protocol VideoEditorPlayable : AnyObject {
  var isPlaying: Swift.Bool { get }
  var playerItem: AVFoundation.AVPlayerItem? { get }
  var avPlayer: AVFoundation.AVPlayer { get }
  var currentTime: CoreMedia.CMTime { get }
  var videoDuration: CoreMedia.CMTime { get }
  var playingRange: CoreMedia.CMTimeRange { get }
  var isMuted: Swift.Bool { get set }
  var audioMix: AVFoundation.AVAudioMix? { get set }
  var playerDelegate: (any UnifiedVideoEditorSDK.VideoEditorPlayerDelegate)? { get set }
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool, range: CoreMedia.CMTimeRange)
  func pause()
  func seek(to time: CoreMedia.CMTime)
  func smoothlySeek(to time: CoreMedia.CMTime)
  func seek(to time: CoreMedia.CMTime, completion: @escaping (_ isFinished: Swift.Bool) -> Swift.Void)
  func reloadPreview(shouldAutoStart: Swift.Bool)
}
public protocol VideoEditorPlayerDelegate : AnyObject {
  func playerPlaysFrame(_ player: any UnifiedVideoEditorSDK.VideoEditorPlayable, atTime time: CoreMedia.CMTime)
  func playerDidEndPlaying(_ player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
}
public class VideoSequenceItem {
  @_hasMissingDesignatedInitializers public class VideoInfo {
    final public let duration: Foundation.TimeInterval
    final public let resolution: CoreFoundation.CGSize
    @objc deinit
  }
  final public let uuidString: Swift.String
  final public let url: Foundation.URL
  public var videoInfo: UnifiedVideoEditorSDK.VideoSequenceItem.VideoInfo {
    get
    set
  }
  final public let isGalleryAsset: Swift.Bool
  final public let isSlideShow: Swift.Bool
  final public let isPIP: Swift.Bool
  final public let isCopy: Swift.Bool
  public var rotation: UnifiedVideoEditorSDK.AssetRotation
  final public let preview: UIKit.UIImage?
  final public let originalAssetResolution: CoreFoundation.CGSize?
  public var previewUrl: Foundation.URL?
  public var speed: Swift.Double {
    get
  }
  public var name: Swift.String {
    get
  }
  public var transition: UnifiedVideoEditorSDK.TransitionType
  public init(uuidString: Swift.String, assetUrl url: Foundation.URL, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool, isCopy: Swift.Bool, rotation: UnifiedVideoEditorSDK.AssetRotation, preview: UIKit.UIImage?, previewUrl: Foundation.URL?, transition: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize?)
  public func tryReplaceVideo(at videoUrl: Foundation.URL) -> Swift.Bool
  @objc deinit
}
@objc public class VideoSequence : ObjectiveC.NSObject {
  final public let folderURL: Foundation.URL
  public var modificationDate: Foundation.Date {
    get
    set
  }
  public var preview: UIKit.UIImage?
  public var videos: [UnifiedVideoEditorSDK.VideoSequenceItem]
  public var sequenceId: Swift.String {
    get
  }
  public var durations: [Foundation.TimeInterval] {
    get
  }
  public var initialDurations: [Foundation.TimeInterval] {
    get
  }
  public var isGallerySequence: Swift.Bool {
    get
  }
  public var removedVideos: [UnifiedVideoEditorSDK.VideoSequenceItem] {
    get
  }
  required public init(folderURL: Foundation.URL)
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public func remove()
  public func removeVideos()
  @discardableResult
  public func deleteVideo(_ video: UnifiedVideoEditorSDK.VideoSequenceItem) -> Swift.Bool
  public var hasRemovedVideos: Swift.Bool {
    get
  }
  public func restoreRemovedVideos()
  @discardableResult
  public func removeVideo(_ video: UnifiedVideoEditorSDK.VideoSequenceItem) -> Swift.Bool
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public static func generateName() -> Swift.String
}
extension UnifiedVideoEditorSDK.VideoSequence {
  @discardableResult
  public func addVideo(uuidString: Swift.String = UUID().uuidString, at url: Foundation.URL, speed: Swift.Double = 1.0, isGalleryAsset: Swift.Bool = false, isSlideShow: Swift.Bool, isPIP: Swift.Bool = false, isRemovedVideo: Swift.Bool = false, rotation: UnifiedVideoEditorSDK.AssetRotation = .none, preview: UIKit.UIImage? = nil, shouldMoveFile: Swift.Bool = true, shouldUseUniqName: Swift.Bool = true, transition: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize? = nil) -> UnifiedVideoEditorSDK.VideoSequenceItem?
  @discardableResult
  public func addVideoCopy(uuidString: Swift.String, at url: Foundation.URL, speed: Swift.Double = 1.0, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool, isRemoved: Swift.Bool = false, rotation: UnifiedVideoEditorSDK.AssetRotation = .none, preview: UIKit.UIImage? = nil, transition: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize? = nil) -> UnifiedVideoEditorSDK.VideoSequenceItem?
  public func didUpdateVideo(_ video: UnifiedVideoEditorSDK.VideoSequenceItem)
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public typealias SequnceVideos = (originalVideos: [UnifiedVideoEditorSDK.VideoSequenceItem], videos: [UnifiedVideoEditorSDK.VideoSequenceItem])
  public func getVideoFileNames(in directory: Foundation.URL) -> UnifiedVideoEditorSDK.VideoSequence.SequnceVideos
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public func totalDuration(isSpeedCountingEnabled: Swift.Bool = true) -> Foundation.TimeInterval
  public func getDurations(isSpeedCountingEnabled: Swift.Bool = true) -> [Foundation.TimeInterval]
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public static func restore(folder: Foundation.URL) -> UnifiedVideoEditorSDK.VideoSequence
}
extension UnifiedVideoEditorSDK.VideoSequence {
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
}
@objc public class SmallActivityIndicatorConfiguration : ObjectiveC.NSObject {
  @objc public enum GradientTypeAdapter : Swift.Int {
    case color
    case image
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public class GradientType : ObjectiveC.NSObject {
    public var type: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter
    public var color: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientColorConfiguration?
    public var image: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
    public init(type: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter, color: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientColorConfiguration?, image: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?)
    @objc deinit
  }
  @objc public class GradientColorConfiguration : ObjectiveC.NSObject {
    public var angle: CoreFoundation.CGFloat
    public var colors: [CoreGraphics.CGColor]
    public init(angle: CoreFoundation.CGFloat, colors: [CoreGraphics.CGColor])
    @objc deinit
  }
  public var gradientType: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType
  public var activityLineWidth: CoreFoundation.CGFloat
  public init(gradientType: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType, activityLineWidth: CoreFoundation.CGFloat)
  @objc deinit
}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType {
  @objc public static func color(_ color: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientColorConfiguration) -> UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType
  @objc public static func image(_ image: any UnifiedVideoEditorSDK.ImageConfigurationProtocol) -> UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType
}
public struct SaveButtonConfiguration {
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var inactiveTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var text: Swift.String
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var inactiveBackgroundColor: UIKit.UIColor
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, inactiveTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration, text: Swift.String, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, inactiveBackgroundColor: UIKit.UIColor)
}
public protocol EffectsHolderServicing : AnyObject {
  init(license: UnifiedVideoEditorSDK.License)
  var transitionEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] { get }
  var speedEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] { get }
  var visualEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] { get }
}
@objc final public class EditorEffectsConfigHolder : ObjectiveC.NSObject, UnifiedVideoEditorSDK.EffectsHolderServicing {
  public init(license: UnifiedVideoEditorSDK.License)
  public init(token: Swift.String)
  final public var transitionEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] {
    get
  }
  final public var speedEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] {
    get
  }
  final public var visualEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SliderRounderCalculator {
  public typealias Result = (rounded: Swift.Float, displayed: Swift.String)
  public static func getRoundedVolumeValue(_ volume: Swift.Float, wasChanged: Swift.Bool) -> UnifiedVideoEditorSDK.SliderRounderCalculator.Result
  @objc deinit
}
public struct GalleryLayoutConfiguration {
  public var numberOfItemsPerRow: Swift.Int
  public var interitemSpacing: CoreFoundation.CGFloat
  public var edgeInsets: UIKit.UIEdgeInsets
  public init(numberOfItemsPerRow: Swift.Int, interitemSpacing: CoreFoundation.CGFloat, edgeInsets: UIKit.UIEdgeInsets)
}
public protocol VideoMetadataStorageDelegate : AnyObject {
  func videoMetadataStorageDidStartStoring(_ videoMetadataStorage: UnifiedVideoEditorSDK.VideoMetadataStorage)
}
public class VideoMetadataStorage {
  weak public var delegate: (any UnifiedVideoEditorSDK.VideoMetadataStorageDelegate)?
  public var videoSequence: UnifiedVideoEditorSDK.VideoSequence? {
    get
  }
  public var videoMetadata: UnifiedVideoEditorSDK.VideoMetadata? {
    get
  }
  public var videoEditorMetadata: UnifiedVideoEditorSDK.VideoEditorMetadata? {
    get
  }
  public var videoEditorTrimMetadata: UnifiedVideoEditorSDK.VideoEditorTrimMetadata? {
    get
  }
  public var videoCoverMetadata: UnifiedVideoEditorSDK.VideoCoverMetadata? {
    get
  }
  public var musicEditorMetadata: UnifiedVideoEditorSDK.MusicEditorMetadata? {
    get
  }
  public var cameraSessionMetadata: UnifiedVideoEditorSDK.CameraSessionMetadata? {
    get
  }
  required public init(videoSequence: UnifiedVideoEditorSDK.VideoSequence? = nil, fileManager: Foundation.FileManager = FileManager.default)
  @objc deinit
  public func update(musicEditorTracks: [UnifiedVideoEditorSDK.MusicEditorTrack], trackVolumes: [Swift.Int32 : Swift.Float], pipVolume: Swift.Float?, videoVolume: Swift.Float)
  public func update(metadata: UnifiedVideoEditorSDK.CameraSessionMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoEditorTrimMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoEditorMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoCoverMetadata)
  public func reset()
  public func setupCurrentSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  public func videoMetadata(forVideoSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence?) -> UnifiedVideoEditorSDK.VideoMetadata?
  public func videoEditorTrimMetadata(for videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> UnifiedVideoEditorSDK.VideoEditorTrimMetadata?
  public func videoCoverMetadata(forVideoSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence?) -> UnifiedVideoEditorSDK.VideoCoverMetadata?
  public func replaceMetadata(ofVideoSequence destinationSequence: UnifiedVideoEditorSDK.VideoSequence, withVideoSequence sourceSequence: UnifiedVideoEditorSDK.VideoSequence)
  public func duplicateMetadata(ofVideoSequence sourceSequence: UnifiedVideoEditorSDK.VideoSequence, toVideoSequence destinationSequence: UnifiedVideoEditorSDK.VideoSequence)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var spinCircleLayer: QuartzCore.CAShapeLayer
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func startAnimating()
  @_Concurrency.MainActor(unsafe) public func stopAnimating()
  @objc deinit
}
@objc public protocol ImageConfigurationProtocol {
  @objc var image: UIKit.UIImage? { get }
  @objc var tintColor: UIKit.UIColor? { get }
}
public class BanubaImageConfiguration : UnifiedVideoEditorSDK.ImageConfigurationProtocol {
  @objc final public let image: UIKit.UIImage?
  @objc final public let tintColor: UIKit.UIColor?
  public init(image: UIKit.UIImage?, tintColor: UIKit.UIColor? = nil)
  @objc deinit
}
@objc public class TimeBomb : ObjectiveC.NSObject, Swift.Codable {
  @objc public var yearBegin: Swift.Int, monBegin: Swift.Int, dayBegin: Swift.Int, yearEnd: Swift.Int
  @objc public var monEnd: Swift.Int, dayEnd: Swift.Int
  @objc public var isExpired: Swift.Bool {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
public enum OverlayPopoverActionsPosition {
  case bottomLeft(_: CoreFoundation.CGPoint)
  case topLeft(_: CoreFoundation.CGPoint)
  case topRight(_: CoreFoundation.CGPoint)
  case bottomRight(_: CoreFoundation.CGPoint)
  case center
}
public struct PopoverAlertViewConfiguration {
  public var mainBackgroundColor: UIKit.UIColor
  public var actionsViewBackgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var actionCellHeight: CoreFoundation.CGFloat
  public var hideAnimated: Swift.Bool
  public static var `default`: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration {
    get
  }
  public init(mainBackgroundColor: UIKit.UIColor, actionsViewBackgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, actionCellHeight: CoreFoundation.CGFloat, hideAnimated: Swift.Bool)
}
public struct OverlayPopoverActionConfiguration {
  public init(leftImage: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, rightImage: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, title: UnifiedVideoEditorSDK.TextConfiguration, titleImageInset: CoreFoundation.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class PopoverAlertViewController : UIKit.UIViewController, UnifiedVideoEditorSDK.NibLoadable {
  public enum ActionType {
    case edit(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
    case delete(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
    case discardChanges(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
    case updateDraft(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration
  @_Concurrency.MainActor(unsafe) public var actions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType]
  @_Concurrency.MainActor(unsafe) public var actionsPosition: UnifiedVideoEditorSDK.OverlayPopoverActionsPosition
  @_Concurrency.MainActor(unsafe) public var resultCompletion: ((UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UnifiedVideoEditorSDK.PopoverAlertViewController : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
public typealias ExternalDraft = UnifiedVideoEditorSDK.VideoSequence
@_hasMissingDesignatedInitializers public class DraftsService {
  public func getDrafts() -> [UnifiedVideoEditorSDK.ExternalDraft]
  public func removeExternalDraft(_ externalDraft: UnifiedVideoEditorSDK.ExternalDraft) -> Swift.Bool
  public func getPreviewForVideoSequence(_ externalDraft: UnifiedVideoEditorSDK.ExternalDraft, thumbnailHeight: CoreFoundation.CGFloat, completion: ((_ preview: UIKit.UIImage?) -> Swift.Void)?)
  @objc deinit
}
public enum AnalyticsEffectType : Swift.String, Swift.CaseIterable {
  case mask
  case filter
  case speed
  case beautification
  case timer
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.AnalyticsEffectType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.AnalyticsEffectType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@objc(BNBAnalyticsManager) public class BNBAnalyticsManager : ObjectiveC.NSObject {
  public var license: UnifiedVideoEditorSDK.License {
    get
  }
  public var cameraEffects: [UnifiedVideoEditorSDK.AnalyticsEffectType : [Swift.String?]]
  public init(license: UnifiedVideoEditorSDK.License)
  @objc deinit
}
extension UnifiedVideoEditorSDK.BNBAnalyticsManager {
  public func sendEvent(withType type: UnifiedVideoEditorSDK.BNBInformerEventType)
}
public struct TransitionEffectInfo {
  public var type: UnifiedVideoEditorSDK.TransitionEffectType {
    get
  }
  public var start: CoreMedia.CMTime {
    get
  }
  public var end: CoreMedia.CMTime {
    get
  }
  public init(type: UnifiedVideoEditorSDK.TransitionEffectType, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
}
public class AudioServiceItem : UnifiedVideoEditorSDK.AudioItem {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var title: Swift.String?
  public var additionalTitle: Swift.String?
  public var isEditable: Swift.Bool
  public var timeRange: CoreMedia.CMTimeRange?
  public init(uuid: Foundation.UUID, url: Foundation.URL, coverURL: Foundation.URL?, title: Swift.String?, additionalTitle: Swift.String?, isEditable: Swift.Bool, timeRange: CoreMedia.CMTimeRange? = nil)
  @objc deinit
}
public protocol AudioPlayerDelegate : AnyObject {
  func playerPlaysFrameAtTime(_ time: Foundation.TimeInterval)
  func didEndPlaying()
}
public protocol AudioServicing {
  var player: AVFAudio.AVAudioPlayer? { get set }
  var delegate: (any UnifiedVideoEditorSDK.AudioPlayerDelegate)? { get set }
  var rate: Swift.Float { get set }
  var currentAudio: UnifiedVideoEditorSDK.AudioServiceItem? { get }
  var duration: Foundation.TimeInterval? { get }
  func autoRepeat(repeat: Swift.Bool, delay: Swift.Double)
  func seekToStart()
  func seekToStart(isEnabled: Swift.Bool)
  func seek(to: Foundation.TimeInterval)
  func load(item: UnifiedVideoEditorSDK.AudioServiceItem) throws
  func unload()
  func toggle()
  func play()
  func pause()
  func setRate(_ rate: Swift.Float)
  func setDelegate(_ delegate: any UnifiedVideoEditorSDK.AudioPlayerDelegate)
  func changeVolume(volume: Swift.Float)
  func createAudioDirectory()
}
@objc @_inheritsConvenienceInitializers public class AudioService : ObjectiveC.NSObject, UnifiedVideoEditorSDK.AudioServicing {
  weak public var delegate: (any UnifiedVideoEditorSDK.AudioPlayerDelegate)?
  public var currentAudio: UnifiedVideoEditorSDK.AudioServiceItem?
  public var player: AVFAudio.AVAudioPlayer?
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var playingTimeRange: CoreMedia.CMTimeRange?
  public var rate: Swift.Float {
    get
    set
  }
  public func autoRepeat(repeat: Swift.Bool)
  public func autoRepeat(repeat: Swift.Bool, delay: Swift.Double = .zero)
  public func seekToStart(isEnabled: Swift.Bool)
  public func createAudioDirectory()
  public func setRate(_ rate: Swift.Float)
  public func changeVolume(volume: Swift.Float)
  public func load(item: UnifiedVideoEditorSDK.AudioServiceItem) throws
  public func load(trackUrl: Foundation.URL) throws
  public func unload()
  public func toggle()
  public func play()
  public func pause()
  public func seekToStart()
  public func seek(to: Foundation.TimeInterval)
  public func setDelegate(_ delegate: any UnifiedVideoEditorSDK.AudioPlayerDelegate)
  @objc override dynamic public init()
  @objc deinit
}
extension UnifiedVideoEditorSDK.AudioService : AVFAudio.AVAudioPlayerDelegate {
  @objc dynamic public func audioPlayerDidFinishPlaying(_ player: AVFAudio.AVAudioPlayer, successfully flag: Swift.Bool)
}
extension UnifiedVideoEditorSDK.AudioServicing {
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack? {
    get
  }
}
@_hasMissingDesignatedInitializers public class CancelExportHandler {
  public func cancel()
  @objc deinit
}
public class VEExport {
  public init?(videoEditorService: UnifiedVideoEditorSDK.VideoEditorService)
  @discardableResult
  public func exportVideo(to fileURL: Foundation.URL, using exportVideoInfo: UnifiedVideoEditorSDK.ExportVideoInfo, watermarkFilterModel: UnifiedVideoEditorSDK.VideoEditorFilterModel?, exportProgress: ((Swift.Float) -> Swift.Void)?, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  @discardableResult
  public func exportAudio(to fileURL: Foundation.URL, audioSettings: [Swift.String : Any] = VESettings.audio, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  @discardableResult
  public func exportSlideshowImages(_ images: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol], to fileUrl: Foundation.URL? = nil, videoResolution: UnifiedVideoEditorSDK.VideoResolution, completion: ((Foundation.URL, (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler
  @discardableResult
  public func exportAudio(to fileURL: Foundation.URL, from asset: AVFoundation.AVAsset, audioSettings: [Swift.String : Any] = VESettings.audio, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  @objc deinit
}
public protocol ExternalLogListener {
  func log(message: Swift.String)
  func log(error: Swift.String)
}
@_hasMissingDesignatedInitializers open class Logger {
  public static var externalListener: (any UnifiedVideoEditorSDK.ExternalLogListener)?
  open class func logError(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logDegug(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logInfo(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logFault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logDefault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  @objc deinit
}
public protocol ExternalMaskProviding {
  var didReceiveExternalMasks: (([any UnifiedVideoEditorSDK.ExternalMask]) -> Swift.Void)? { get set }
  var masks: [any UnifiedVideoEditorSDK.ExternalMask] { get }
  func requestMask(_ mask: any UnifiedVideoEditorSDK.ExternalMask, statusUpdateHandler: ((UnifiedVideoEditorSDK.ExternalMaskStatus) -> Swift.Void)?)
  func cancelMaskDownloading(_ mask: any UnifiedVideoEditorSDK.ExternalMask)
  func requestMaskPreview(_ mask: any UnifiedVideoEditorSDK.ExternalMask, completion: ((UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)?)
}
public protocol ExternalMask {
  var id: Swift.UInt { get }
  var maskType: Swift.String? { get }
  var name: Swift.String { get }
  var url: Foundation.URL { get }
  var previewImageURL: Foundation.URL { get }
  var status: UnifiedVideoEditorSDK.ExternalMaskStatus { get }
}
public enum ExternalMaskStatus : Swift.Equatable {
  case startDownloading
  case notDownloaded
  case downloaded(path: Foundation.URL, shouldApply: Swift.Bool)
  case downloading(progress: Swift.Float)
  case error(any Swift.Error)
  public static let downloadEffectMaxProgress: Swift.Float
  public static let downloadEffectMinProgress: Swift.Float
  public static func == (lhs: UnifiedVideoEditorSDK.ExternalMaskStatus, rhs: UnifiedVideoEditorSDK.ExternalMaskStatus) -> Swift.Bool
}
public struct VideoSequenceNameDuplacatesFinder {
  public let sequenceName: Swift.String
  public init(sequenceName: Swift.String)
  public func findDuplicates(inSequenceNames sequenceNames: [Swift.String]) -> [Swift.String]
  public func getIndex(fromName: Swift.String?) -> Swift.Int?
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class BaseTrackSelectionViewController : UIKit.UINavigationController, UnifiedVideoEditorSDK.TrackSelectionViewController {
  @_Concurrency.MainActor(unsafe) weak public var trackSelectionDelegate: (any UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate)?
  @available(iOS 5.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol TrackSelectionViewControllerDelegate : AnyObject {
  func trackSelectionViewController(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, timeRange: CoreMedia.CMTimeRange?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func trackSelectionViewControllerDidCancel(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController)
  func trackSelectionViewControllerDiscardCurrentTrack(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController)
}
extension UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewController(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL? = nil, timeRange: CoreMedia.CMTimeRange? = nil, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
}
extension UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewControllerDiscardCurrentTrack(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController)
}
public protocol TrackSelectionViewController : UIKit.UIViewController {
  var trackSelectionDelegate: (any UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate)? { get set }
}
@objc public class EffectModel : ObjectiveC.NSObject {
  public var id: Swift.UInt
  public var url: Foundation.URL?
  public var name: Swift.String?
  public init(id: Swift.UInt, url: Foundation.URL)
  public init(id: Swift.UInt, name: Swift.String)
  @objc deinit
}
public class VideoEditorEffectDrawer : UnifiedVideoEditorSDK.CompositionRenderering {
  public var renderer: (any UnifiedVideoEditorSDK.EffectRenderer)? {
    get
  }
  required public init()
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, effect: any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol, additionalParameters: [Swift.String : Any]?)
  public func cleanUpResources()
  @objc deinit
}
public enum VideoTextAlignment : Swift.Int {
  case left
  case center
  case right
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension CoreFoundation.CGRect {
  public func getCenter() -> CoreFoundation.CGPoint
  public func convert(from srcCoordinateSize: CoreFoundation.CGSize, to dstCoordinateSize: CoreFoundation.CGSize) -> CoreFoundation.CGRect
}
@objc @_inheritsConvenienceInitializers public class SDKLogger : ObjectiveC.NSObject {
  public static func debugPrint(_ text: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public struct EffectIDs {
  public static let colorEffectStartId: Swift.UInt
  public static let maskEffectStartId: Swift.UInt
  public static let speedEffectStartId: Swift.UInt
  public static let visualEffectStartId: Swift.UInt
  public static let transformEffectId: Swift.UInt
  public static let blurEffectId: Swift.UInt
}
public protocol ReflectedStringConvertible : Swift.CustomStringConvertible {
}
extension UnifiedVideoEditorSDK.ReflectedStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc extension UIKit.UIImage {
  @objc convenience dynamic public init?(bgraDataNoCopy: Foundation.NSData, width: Swift.Int, height: Swift.Int)
  @objc dynamic public func makeBgraPixelBuffer() -> CoreVideo.CVPixelBuffer?
}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration {
  public static var config: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration {
    get
  }
}
extension UnifiedVideoEditorSDK.FullScreenActivityConfiguration {
  public static var config: UnifiedVideoEditorSDK.FullScreenActivityConfiguration {
    get
  }
}
extension UnifiedVideoEditorSDK.WatermarkConfiguration {
  public static var config: UnifiedVideoEditorSDK.WatermarkConfiguration {
    get
  }
}
public protocol EffectsManagement : AnyObject {
  func getStoredEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  func getCurrentAppliedEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  func applyEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime, removeSameType: Swift.Bool, isAutoCutEffect: Swift.Bool)
  func startCurrentEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, at: CoreMedia.CMTime)
  func endCurrentEffect(at: CoreMedia.CMTime)
  func undoEffect(uuid: Swift.String) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  func undoLast(type: UnifiedVideoEditorSDK.EditorEffectType) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  func undoAll(type: UnifiedVideoEditorSDK.EditorEffectType)
  func undoAll(except: UnifiedVideoEditorSDK.EditorEffectType)
  func undoAll()
  func getSpeed(at time: CoreMedia.CMTime) -> Swift.Float
  func changeEffectTimeRange(with uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  func hasChangesInAppliedEffects() -> Swift.Bool
  func storeStack()
  func restoreStack()
}
public protocol ExportScalable {
  func exportScaled(outputUrl: Foundation.URL, quality: Swift.String, trimData: UnifiedVideoEditorSDK.VideoTrimData?, completion: (((any Swift.Error)?) -> Swift.Void)?)
}
public protocol AssetEditable {
  func addTracks(_ tracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo], atIndex index: Swift.Int)
  func removeTrack(at index: Swift.Int)
  func removeTrack(_ track: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo)
  func moveTrack(fromIndex: Swift.Int, toIndex: Swift.Int)
  func reorderTracks(withTracks reorderedTracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo])
}
public struct VideoEditorAssetMusicTrack {
  public let track: UnifiedVideoEditorSDK.MediaTrack
  public let trackId: CoreMedia.CMPersistentTrackID
}
public class VideoEditorAsset {
  public var composition: AVFoundation.AVMutableComposition!
  public var instructions: [any AVFoundation.AVVideoCompositionInstructionProtocol]? {
    get
  }
  public var errors: [any Swift.Error] {
    get
  }
  public var tracksInfo: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo] {
    get
  }
  final public let videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var videoResolutionCurrentSize: CoreFoundation.CGSize?
  public var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>
  public var musicTracks: [UnifiedVideoEditorSDK.VideoEditorAssetMusicTrack] {
    get
  }
  public init(tracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo], isDebugModeOn: Swift.Bool = false, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> = CGFloat(0)...CGFloat(0), videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration)
  convenience public init(sequence: UnifiedVideoEditorSDK.VideoSequence, isGalleryAssets: Swift.Bool, isSlideShow: Swift.Bool, isDebugModeOn: Swift.Bool = false, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> = CGFloat(0)...CGFloat(0), videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration)
  public func reloadComposition()
  public func loadNonExistingThumbnails(completion: (() -> ())?)
  public func getPartIndex(at time: CoreMedia.CMTime) -> Swift.Int?
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoEditorAsset {
  public func changeMusicTrackPosition(_ musicTrack: UnifiedVideoEditorSDK.MediaTrack) -> Swift.Bool
  public func hasMusicTrack(with trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  @discardableResult
  public func addMusicTrack(_ musicTrack: UnifiedVideoEditorSDK.MediaTrack) -> (compositionTrack: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack)?
  @discardableResult
  public func removeMusic(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  public func removeAllMusic()
}
extension UnifiedVideoEditorSDK.VideoEditorAsset : UnifiedVideoEditorSDK.ExportScalable {
  public func exportScaled(outputUrl: Foundation.URL, quality: Swift.String, trimData: UnifiedVideoEditorSDK.VideoTrimData?, completion: (((any Swift.Error)?) -> Swift.Void)?)
}
extension UnifiedVideoEditorSDK.VideoEditorAsset : UnifiedVideoEditorSDK.AssetEditable {
  public func addTracks(_ tracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo], atIndex index: Swift.Int)
  public func removeTrack(at index: Swift.Int)
  public func removeTrack(_ track: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo)
  public func moveTrack(fromIndex: Swift.Int, toIndex: Swift.Int)
  public func reorderTracks(withTracks reorderedTracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo])
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class CircularProgressView : UIKit.UIView, UnifiedVideoEditorSDK.ProgressAnimatableView {
  @_Concurrency.MainActor(unsafe) public var progressColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shadowColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var progress: Swift.Float {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shadowLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var progressLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSublayers(of layer: QuartzCore.CALayer)
  @_Concurrency.MainActor(unsafe) public func resetProgress()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class VideoCompositionRenderQueue {
  public static let queue: Dispatch.DispatchQueue
  @objc deinit
}
public class ShapeDrawer : UnifiedVideoEditorSDK.CompositionRenderering {
  public var shapeTexture: (any Metal.MTLTexture)?
  required public init()
  public init(renderer: any UnifiedVideoEditorSDK.EffectRenderer)
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source allSources: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, effect: any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol, additionalParameters: [Swift.String : Any]?)
  @objc deinit
}
public protocol ImageTextButtonConfigurationProtocol {
  var imageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? { get set }
  var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? { get set }
  var style: UnifiedVideoEditorSDK.TextConfiguration? { get set }
}
public struct GalleryItemConfiguration {
  public var orderNumberBackgroudColor: UIKit.UIColor
  public var orderNumberSelectedBackgroudColor: UIKit.UIColor
  public var orderNumberTitleColor: UIKit.UIColor
  public var orderNumberTitleFont: UIKit.UIFont
  public var orderNumberBorderWidth: CoreFoundation.CGFloat
  public var orderNumberSelectedBorderWidth: CoreFoundation.CGFloat
  public var orderNumberBorderColor: UIKit.UIColor
  public var durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var durationLabelBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var durationLabelAlignment: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment
  public var activityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public var cornerRadius: CoreFoundation.CGFloat
  public init(orderNumberBackgroudColor: UIKit.UIColor, orderNumberSelectedBackgroudColor: UIKit.UIColor, orderNumberTitleColor: UIKit.UIColor, orderNumberTitleFont: UIKit.UIFont, orderNumberBorderWidth: CoreFoundation.CGFloat, orderNumberSelectedBorderWidth: CoreFoundation.CGFloat, orderNumberBorderColor: UIKit.UIColor, durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, durationLabelBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, durationLabelAlignment: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment, activityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration, cornerRadius: CoreFoundation.CGFloat)
  public enum DurationLabelAlignment {
    case left
    case right
    public static func == (a: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment, b: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol ProgressAnimatableViewFactory {
  func makeProgressAnimatableView() -> any UnifiedVideoEditorSDK.ProgressAnimatableView
}
public class CircularProgressViewFactory : UnifiedVideoEditorSDK.ProgressAnimatableViewFactory {
  public var progressColor: UIKit.UIColor
  final public let shadowColor: UIKit.UIColor
  public init(progressColor: UIKit.UIColor = .white, shadowColor: UIKit.UIColor = UIColor(white: 0, alpha: 0.25))
  public func makeProgressAnimatableView() -> any UnifiedVideoEditorSDK.ProgressAnimatableView
  @objc deinit
}
public protocol TextEditSelectionColorBehavior {
  func setColorView(_ view: UIKit.UIView, selected: Swift.Bool, animated: Swift.Bool)
}
public class EffectMetalRenderer : UnifiedVideoEditorSDK.EffectRenderer {
  required public init()
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String, additionalParameters: [Swift.String : Any]?)
  @objc deinit
}
extension UIKit.UIColor {
  public var colorComponents: (red: CoreFoundation.CGFloat, green: CoreFoundation.CGFloat, blue: CoreFoundation.CGFloat, alpha: CoreFoundation.CGFloat)? {
    get
  }
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
  convenience public init(rgb: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
}
@_hasMissingDesignatedInitializers public class EffectStack {
  public func getAllEffects(at time: CoreMedia.CMTime, from: [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func embed(toView view: UIKit.UIView, topOffset: CoreFoundation.CGFloat = .zero, leftOffset: CoreFoundation.CGFloat = .zero, rightOffset: CoreFoundation.CGFloat = .zero, bottomOffset: CoreFoundation.CGFloat = .zero, forceLayoutPass: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func unembed()
}
public struct PlayerControlConfiguration {
  public var playButtonImageName: Swift.String
  public var pauseButtonImageName: Swift.String
  public var tintColor: UIKit.UIColor?
  public var playImage: UIKit.UIImage?
  public var pauseImage: UIKit.UIImage?
  public init(playButtonImageName: Swift.String, pauseButtonImageName: Swift.String, tintColor: UIKit.UIColor? = nil)
  public init(playImage: UIKit.UIImage?, pauseImage: UIKit.UIImage?)
}
@_hasMissingDesignatedInitializers public class AudioMixer {
  public struct VolumeDefaults {
    public static let mutedVolume: Swift.Float
    public static let defaultVolume: Swift.Float
  }
  public func getAudioMix(for asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  public func resetTrackVolumeToDefault(trackId: CoreMedia.CMPersistentTrackID)
  public func setVolume(_ volume: Swift.Float, forTrackId trackId: CoreMedia.CMPersistentTrackID)
  public func volume(forTrackId trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  public func isVolumeDefault(forTrackId trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  public func mutedMusicMix(asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  public func mutedAudioMix(asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  @objc deinit
}
public protocol VideoEditorEffectImageProvider {
  func provideImage(for textureSize: CoreFoundation.CGSize) -> UIKit.UIImage
}
public struct VideoEditorEffectInfo {
  public let uuid: Swift.String
  public let image: UIKit.UIImage?
  public let imageProvider: (any UnifiedVideoEditorSDK.VideoEditorEffectImageProvider)?
  public let relativeScreenPoints: UnifiedVideoEditorSDK.ImagePoints?
  public let start: CoreMedia.CMTime
  public let end: CoreMedia.CMTime
  public init(uuid: Swift.String, image: UIKit.UIImage? = nil, imageProvider: (any UnifiedVideoEditorSDK.VideoEditorEffectImageProvider)? = nil, relativeScreenPoints: UnifiedVideoEditorSDK.ImagePoints? = nil, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
}
public protocol ImageButtonConfigurationProtocol {
  var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol { get set }
  var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? { get set }
}
public struct BanubaImageButtonConfiguration : UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol {
  public var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public init(imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? = nil)
}
@_hasMissingDesignatedInitializers public class VideoEditorTrackRotationCalculator {
  public static func getTrackRotation(_ track: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo) -> UnifiedVideoEditorSDK.AssetRotation
  @objc deinit
}
public enum FileExtension {
  public enum Video : Swift.String {
    case mp4
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension Swift.Int32 {
  public static let `default`: CoreMedia.CMTimeScale
}
public class AverageSum {
  public init(name: Swift.String, skipFirstCount: Swift.Int, autoprint: Swift.Bool = true, autoprintInterval: Swift.UInt = 100)
  @objc deinit
}
@_inheritsConvenienceInitializers public class AverageTimeSum : UnifiedVideoEditorSDK.AverageSum {
  public func begin()
  public func end()
  override public init(name: Swift.String, skipFirstCount: Swift.Int, autoprint: Swift.Bool = super, autoprintInterval: Swift.UInt = super)
  @objc deinit
}
public struct WatermarkConfiguration {
  public var watermark: UnifiedVideoEditorSDK.ImageConfiguration
  public var size: CoreFoundation.CGSize
  public var sharedOffset: CoreFoundation.CGFloat
  public var position: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition
  public var id: Swift.UInt?
  public enum WatermarkPosition {
    case leftTop
    case leftBottom
    case rightTop
    case rightBottom
    public static func == (a: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition, b: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var expiredWatermarkId: Swift.UInt
  public static var expiredWatermark: UnifiedVideoEditorSDK.WatermarkConfiguration {
    get
  }
  public init(watermark: UnifiedVideoEditorSDK.ImageConfiguration, size: CoreFoundation.CGSize, sharedOffset: CoreFoundation.CGFloat, position: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition, id: Swift.UInt? = nil)
}
public struct AlertViewConfiguration {
  public var backgroundColor: UIKit.UIColor
  public var alertBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var resetButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var resetCancelTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var additionalButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var refuseButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var agreeButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var titleTextConfig: UnifiedVideoEditorSDK.TextConfiguration
  public var messageTextConfig: UnifiedVideoEditorSDK.TextConfiguration
  public var spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat
  public var titleAndMessageInsets: UIKit.UIEdgeInsets
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public init(backgroundColor: UIKit.UIColor, alertBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, resetButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, resetCancelTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, refuseButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, agreeButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, additionalButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, titleTextConfig: UnifiedVideoEditorSDK.TextConfiguration, messageTextConfig: UnifiedVideoEditorSDK.TextConfiguration, spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat, titleAndMessageInsets: UIKit.UIEdgeInsets, preferredStatusBarStyle: UIKit.UIStatusBarStyle)
}
extension UnifiedVideoEditorSDK.CompositionRenderering {
  public var className: Swift.String {
    get
  }
  public static var className: Swift.String {
    get
  }
  public func cleanUpResources()
}
public protocol CompositionRenderering : AnyObject {
  init()
  func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, effect: any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol, additionalParameters: [Swift.String : Any]?)
  func cleanUpResources()
}
@objc public class GalleryConfiguration : ObjectiveC.NSObject {
  public var videoResolution: UnifiedVideoEditorSDK.VideoResolution
  public var galleryItemConfiguration: UnifiedVideoEditorSDK.GalleryItemConfiguration
  public var closeButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol
  public var albumButtonConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var albumArrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var collectionInfoHeaderConfiguration: UnifiedVideoEditorSDK.CollectionInfoHeaderConfiguration
  public var galleryItemPreviewViewConfiguration: UnifiedVideoEditorSDK.GalleryItemPreviewViewConfiguration
  public var nextButtonConfiguration: UnifiedVideoEditorSDK.SaveButtonConfiguration
  public var noItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var layoutConfiguration: UnifiedVideoEditorSDK.GalleryLayoutConfiguration
  public var topBarBlurColor: UIKit.UIColor
  public var clearSelectionButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol
  public var galleryTypeButton: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var galleryTypeUnderlineColor: UIKit.UIColor
  public var isPhotoSequenceAnimationEnabled: Swift.Bool
  public var importItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var isCloseButtonHidden: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var maximumSelectedCountFromGallery: Swift.Int
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var alertConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration
  public init(videoResolution: UnifiedVideoEditorSDK.VideoResolution, galleryItemConfiguration: UnifiedVideoEditorSDK.GalleryItemConfiguration, closeButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol, albumButtonConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration, albumArrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, collectionInfoHeaderConfiguration: UnifiedVideoEditorSDK.CollectionInfoHeaderConfiguration, galleryItemPreviewViewConfiguration: UnifiedVideoEditorSDK.GalleryItemPreviewViewConfiguration, nextButtonConfiguration: UnifiedVideoEditorSDK.SaveButtonConfiguration, noItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, layoutConfiguration: UnifiedVideoEditorSDK.GalleryLayoutConfiguration, topBarBlurColor: UIKit.UIColor, clearSelectionButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol, galleryTypeButton: UnifiedVideoEditorSDK.TextButtonConfiguration, galleryTypeUnderlineColor: UIKit.UIColor, isPhotoSequenceAnimationEnabled: Swift.Bool, importItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, isCloseButtonHidden: Swift.Bool, backgroundColor: UIKit.UIColor, maximumSelectedCountFromGallery: Swift.Int, preferredStatusBarStyle: UIKit.UIStatusBarStyle, alertConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration, autoCutGalleryConfiguration: UnifiedVideoEditorSDK.AutoCutGalleryConfiguration? = nil)
  @objc deinit
}
public class VideoEditorImagesSequence {
  @objc deinit
  public init(imageAssets: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol])
}
public struct DeviceVibrateManager {
  public static func vibrate(withPower power: UIKit.UIImpactFeedbackGenerator.FeedbackStyle)
}
public protocol VideoImageEffectDrawable {
  func draw(imageTexture: any Metal.MTLTexture, in pixelBuffer: CoreVideo.CVPixelBuffer, sampleTime: Foundation.TimeInterval, startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, imageSize: CoreFoundation.CGSize)
}
public protocol SequencesServicing {
  var aspectRatio: UnifiedVideoEditorSDK.AspectRatio { get }
  var currentSequence: UnifiedVideoEditorSDK.VideoSequence? { get }
  var lastModifiedSequence: UnifiedVideoEditorSDK.VideoSequence? { get }
  var sequences: [UnifiedVideoEditorSDK.VideoSequence] { get }
  var draftedSequences: [UnifiedVideoEditorSDK.VideoSequence] { get }
  func createNewSequence(withMusicTrack musicTrack: UnifiedVideoEditorSDK.MediaTrack?, isSlideShow: Swift.Bool, editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep, maxVideoDuration: Foundation.TimeInterval) -> UnifiedVideoEditorSDK.VideoSequence
  func cancelAndRemoveCurrentSequence()
  @discardableResult
  func removeSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> Swift.Bool
  @discardableResult
  func duplicateSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence, withSameName: Swift.Bool) -> (UnifiedVideoEditorSDK.VideoSequence, UnifiedVideoEditorSDK.VideoMetadata)
  func replaceSequenceWithId(_ sequenceId: Swift.String, withVideoSequence: UnifiedVideoEditorSDK.VideoSequence)
  func setupWithVideoSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  func setEditingStep(_ editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep, forSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence)
}
extension UnifiedVideoEditorSDK.SequencesServicing {
  public func createNewSequence(withMusicTrack musicTrack: UnifiedVideoEditorSDK.MediaTrack? = nil, isSlideShow: Swift.Bool = false, editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep = .trimmer, maxVideoDuration: Foundation.TimeInterval) -> UnifiedVideoEditorSDK.VideoSequence
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class SlideInPresentationManager : ObjectiveC.NSObject, UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor(unsafe) public var backgroundViewInteractionHandler: (() -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public init(coverPercentage: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: UnifiedVideoEditorSDK.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool = false, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor(unsafe) public init(coverHeight: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: UnifiedVideoEditorSDK.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor(unsafe) @objc convenience override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc public func presentationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController?, source: UIKit.UIViewController) -> UIKit.UIPresentationController?
  @_Concurrency.MainActor(unsafe) @objc public func animationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController, source: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func animationController(forDismissed dismissed: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func interactionControllerForPresentation(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func interactionControllerForDismissal(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @objc deinit
}
public enum GiphyResolution {
  case medium
  case original
  public static func == (a: UnifiedVideoEditorSDK.GiphyResolution, b: UnifiedVideoEditorSDK.GiphyResolution) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol VideoEditorSDKServicing {
  var videoEditorService: UnifiedVideoEditorSDK.VideoEditorService { get }
}
public protocol AudioVideoEditorSDKServicing : UnifiedVideoEditorSDK.VideoEditorSDKServicing {
  var audioService: any UnifiedVideoEditorSDK.AudioServicing { get }
}
public protocol SDKVideoCompositionInstructionDataSource : AnyObject {
  func getEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  func getEffectsBefore(time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
}
public typealias DownloadEffectRequestId = Swift.UInt
extension Swift.UInt {
  public static var invalid: UnifiedVideoEditorSDK.DownloadEffectRequestId {
    get
  }
}
@objc public class BanubaARCloud : ObjectiveC.NSObject {
  @objc public static var effectsFolderURL: Foundation.URL {
    @objc get
  }
  @objc required public init(arCloudUrl: Swift.String, embeddedEffectURLs: [Foundation.URL]? = nil)
  @objc public func getAREffects(completion: @escaping ([any UnifiedVideoEditorSDK.AREffect]?, Foundation.NSError?) -> Swift.Void)
  @objc public func getArEffectPreview(_ effect: any UnifiedVideoEditorSDK.AREffect, completion: @escaping (UIKit.UIImage?, Foundation.NSError?) -> Swift.Void)
  @discardableResult
  @objc public func downloadArEffect(_ effect: any UnifiedVideoEditorSDK.AREffect, downloadProgress: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Foundation.URL?, Foundation.NSError?) -> Swift.Void) -> UnifiedVideoEditorSDK.DownloadEffectRequestId
  @objc public func cancelDownloadingEffect(withRequestId requestId: UnifiedVideoEditorSDK.DownloadEffectRequestId)
  @objc public static func application(_ application: UIKit.UIApplication, handleEventsForBackgroundURLSession identifier: Swift.String, completionHandler: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol AnimatableView : UIKit.UIView {
  func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  func stop()
}
public protocol CountdownTimerAnimatableView : UnifiedVideoEditorSDK.AnimatableView {
  var countdownDigit: Swift.Int { get set }
}
public protocol ProgressAnimatableView : UIKit.UIView {
  var progress: Swift.Float { get set }
}
public enum ContentLocationType : Swift.Int {
  case remote
  case local
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol EffectViewModel : AnyObject {
  var type: UnifiedVideoEditorSDK.EffectType { get }
  var image: UIKit.UIImage? { get set }
  var title: Swift.String { get }
  var id: Swift.UInt { get }
  var progress: Swift.Float? { get set }
  var progressHandler: ((_ progress: Swift.Float, _ failed: Swift.Bool) -> Swift.Void)? { get set }
  var downloadType: UnifiedVideoEditorSDK.ContentLocationType { get }
  var lutFileName: Swift.String? { get }
  func isEqual(to model: any UnifiedVideoEditorSDK.EffectViewModel) -> Swift.Bool
}
extension UnifiedVideoEditorSDK.EffectModel : UnifiedVideoEditorSDK.EffectViewModel {
  public var lutFileName: Swift.String? {
    get
  }
  public var downloadType: UnifiedVideoEditorSDK.ContentLocationType {
    get
  }
  public var progress: Swift.Float? {
    get
    set
  }
  public var progressHandler: ((_ progress: Swift.Float, _ failed: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  public func isEqual(to model: any UnifiedVideoEditorSDK.EffectViewModel) -> Swift.Bool
  public var type: UnifiedVideoEditorSDK.EffectType {
    get
  }
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var title: Swift.String {
    get
  }
}
extension UnifiedVideoEditorSDK.VideoEditorFilterModel : UnifiedVideoEditorSDK.EffectViewModel {
  public var lutFileName: Swift.String? {
    get
  }
  public var downloadType: UnifiedVideoEditorSDK.ContentLocationType {
    get
  }
  public var progress: Swift.Float? {
    get
    set
  }
  public var progressHandler: ((_ progress: Swift.Float, _ failed: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  public func isEqual(to model: any UnifiedVideoEditorSDK.EffectViewModel) -> Swift.Bool
  public var type: UnifiedVideoEditorSDK.EffectType {
    get
  }
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var title: Swift.String {
    get
  }
}
public let exportCancelledError: Foundation.NSError
extension UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ imageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?)
}
extension UnifiedVideoEditorSDK.TransitionType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TransitionType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TransitionType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.BackButtonConfiguration.Position : Swift.Equatable {}
extension UnifiedVideoEditorSDK.BackButtonConfiguration.Position : Swift.Hashable {}
extension UnifiedVideoEditorSDK.BackButtonConfiguration.Position : Swift.Sendable {}
extension UnifiedVideoEditorSDK.SharingServiceModel.SharingType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SharingServiceModel.SharingType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.OutputServiceError : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OutputServiceError : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SDKEventScreen : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SDKEventScreen : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SDKEventScreen : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.SDKEventName : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SDKEventName : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SDKEventName : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.EffectSpeed : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EffectSpeed : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EffectSpeed : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AspectRatio : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AspectRatio : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AspectRatio : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.VideoSequenceEditingStep : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VideoSequenceEditingStep : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoSequenceEditingStep : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint : Swift.Equatable {}
extension UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint : Swift.Hashable {}
extension UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.DraftActionType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DraftActionType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditorEffectKey : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EditorEffectKey : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditorEffectKey : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.VisualEffectApplicatorType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VisualEffectApplicatorType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VisualEffectApplicatorType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.SpeedEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SpeedEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SpeedEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.TransitionEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TransitionEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TransitionEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnit : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnit : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnitParameter : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnitParameter : Swift.Hashable {}
extension UnifiedVideoEditorSDK.Connection : Swift.Equatable {}
extension UnifiedVideoEditorSDK.Connection : Swift.Hashable {}
extension UnifiedVideoEditorSDK.RecorderPreviewScalingMode : Swift.Equatable {}
extension UnifiedVideoEditorSDK.RecorderPreviewScalingMode : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DrawableFigure : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DrawableFigure : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DrawableFigure : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.DeviceModel : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DeviceModel : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DeviceModel : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AssetRotation : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AssetRotation : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AssetRotation : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.EditorEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EditorEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditorEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.TitlePosition : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TitlePosition : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DraftsFeatureConfig : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DraftsFeatureConfig : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DraftsFeatureConfig : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.DraftMenuItemType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DraftMenuItemType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AlertViewController.ButtonType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AlertViewController.ButtonType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoResolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VideoResolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoResolution : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.CameraVideoResolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CameraVideoResolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ExportVideoInfo.Resolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.ExportVideoInfo.Resolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ExportVideoInfo.Resolution : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AnalyticsEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AnalyticsEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AnalyticsEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.VideoTextAlignment : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VideoTextAlignment : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoTextAlignment : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment : Swift.Equatable {}
extension UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment : Swift.Hashable {}
extension UnifiedVideoEditorSDK.FileExtension.Video : Swift.Equatable {}
extension UnifiedVideoEditorSDK.FileExtension.Video : Swift.Hashable {}
extension UnifiedVideoEditorSDK.FileExtension.Video : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition : Swift.Equatable {}
extension UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition : Swift.Hashable {}
extension UnifiedVideoEditorSDK.GiphyResolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.GiphyResolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ContentLocationType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.ContentLocationType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ContentLocationType : Swift.RawRepresentable {}
