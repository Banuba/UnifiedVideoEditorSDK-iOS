// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios15.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=unchecked -O -module-name UnifiedVideoEditorSDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import Accelerate
import BNBLicenseUtils
import BNBSdkApi
import BNBSdkCore
import CloudKit
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreMedia
import CoreMotion
import CoreVideo
import DeveloperToolsSupport
import Foundation
import Foundation/*.NSRecursiveLock*/
import ImageIO
import LocalAuthentication
import MediaPlayer
import Metal
import MetalKit
import MobileCoreServices
import Photos
import QuartzCore
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
@_exported import UnifiedVideoEditorSDK
import VideoToolbox
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
import os.signpost
public class EffectItem {
  public var effect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`
  public var icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var text: UnifiedVideoEditorSDK.TextConfiguration
  public var isSelected: Swift.Bool
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var selectedColor: UIKit.UIColor
  public init(choosedEffect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, text: UnifiedVideoEditorSDK.TextConfiguration, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, selectedColor: UIKit.UIColor)
  @objc deinit
}
@inlinable internal func distanceFrom(value: CoreFoundation.CGFloat, availableDistance: CoreFoundation.CGFloat, bounds: Swift.ClosedRange<CoreFoundation.CGFloat> = 0.0...1.0, leadingOffset: CoreFoundation.CGFloat = 0, trailingOffset: CoreFoundation.CGFloat = 0) -> CoreFoundation.CGFloat {
  guard availableDistance > leadingOffset + trailingOffset else { return 0 }
  let boundsLenght = bounds.upperBound - bounds.lowerBound
  let relativeValue = (value - bounds.lowerBound) / boundsLenght
  let offset = (leadingOffset - ((leadingOffset + trailingOffset) * relativeValue))
  return offset + (availableDistance * relativeValue)
}
@inlinable internal func valueFrom(distance: CoreFoundation.CGFloat, availableDistance: CoreFoundation.CGFloat, bounds: Swift.ClosedRange<CoreFoundation.CGFloat> = 0.0...1.0, step: CoreFoundation.CGFloat = 0.001, leadingOffset: CoreFoundation.CGFloat = 0, trailingOffset: CoreFoundation.CGFloat = 0) -> CoreFoundation.CGFloat {
  let relativeValue = (distance - leadingOffset) / (availableDistance - (leadingOffset + trailingOffset))
  let newValue = bounds.lowerBound + (relativeValue * (bounds.upperBound - bounds.lowerBound))
  let steppedNewValue = (round(newValue / step) * step)
  let validatedValue = min(bounds.upperBound, max(bounds.lowerBound, steppedNewValue))
  return validatedValue
}
public enum GalleryError : Foundation.CustomNSError, Foundation.LocalizedError {
  case uploadingFailed
  case error(any Swift.Error)
  case uploadingCancelled
  public var isCancelled: Swift.Bool {
    get
  }
  public static var errorDomain: Swift.String
  public var errorDescription: Swift.String? {
    get
  }
}
public class PreviewExtractor {
  final public let asset: AVFoundation.AVAsset
  final public let thumbnailHeight: CoreFoundation.CGFloat
  final public let imageGenerator: AVFoundation.AVAssetImageGenerator
  public init(asset: AVFoundation.AVAsset, thumbnailHeight: CoreFoundation.CGFloat)
  @objc deinit
  public func extractPreview(at time: CoreMedia.CMTime) -> UIKit.UIImage?
  #if compiler(>=5.3) && $AsyncAwait
  public func extractPreview(at time: CoreMedia.CMTime) async -> UIKit.UIImage?
  #endif
}
@objc public enum GalleryItemType : Swift.Int {
  case photo
  case video
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol GalleryItem : ObjectiveC.NSObjectProtocol {
  @objc var urlAsset: AVFoundation.AVURLAsset? { get }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var duration: Foundation.TimeInterval { get }
  @objc var type: UnifiedVideoEditorSDK.GalleryItemType { get }
  @objc func requestPreview(size: CoreFoundation.CGSize, synchronously: Swift.Bool, handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc func requestPhoto(size: CoreFoundation.CGSize, progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)
  @objc func requestAVURLAsset(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVURLAsset?, (any Swift.Error)?) -> Swift.Void)
  @objc func requestAVPlayerItem(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVPlayerItem?, (any Swift.Error)?) -> Swift.Void)
}
@objc open class BanubaGalleryItem : ObjectiveC.NSObject, UnifiedVideoEditorSDK.GalleryItem {
  public static let defaultPreviewSize: CoreFoundation.CGSize
  final public let asset: Photos.PHAsset
  final public let videoResolution: UnifiedVideoEditorSDK.VideoResolution
  @objc public var preview: UIKit.UIImage?
  @objc public var duration: Foundation.TimeInterval {
    @objc get
  }
  @objc public var urlAsset: AVFoundation.AVURLAsset? {
    get
  }
  @objc public var type: UnifiedVideoEditorSDK.GalleryItemType {
    @objc get
  }
  public init(asset: Photos.PHAsset, videoResolution: UnifiedVideoEditorSDK.VideoResolution)
  @objc open func requestAVURLAsset(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVURLAsset?, (any Swift.Error)?) -> Swift.Void)
  @objc open func requestAVPlayerItem(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVPlayerItem?, (any Swift.Error)?) -> Swift.Void)
  @objc open func requestPreview(size: CoreFoundation.CGSize = BanubaGalleryItem.defaultPreviewSize, synchronously: Swift.Bool, handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc open func requestPhoto(size: CoreFoundation.CGSize, progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
extension UnifiedVideoEditorSDK.BanubaGalleryItem {
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
}
public struct CustomSDKVideoCompositionConfig {
  public static let renderingQueueName: Swift.String
}
public enum TransitionType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case normal
  case whipDown
  case whipUp
  case whipRight
  case whipLeft
  case scrollDown
  case scrollUp
  case scrollRight
  case scrollLeft
  case spinRight
  case fade
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.TransitionType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.TransitionType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum EffectPlayerRenderMode : Swift.Int {
  case photo
  case video
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class EffectPlayerConfiguration : ObjectiveC.NSObject {
  @_inheritsConvenienceInitializers @objc public class Defaults : ObjectiveC.NSObject {
    @objc public static let videoSessionPreset: AVFoundation.AVCaptureSession.Preset
    @objc public static let photoSessionPreset: AVFoundation.AVCaptureSession.Preset
    @objc public static let photoRenderSize: CoreFoundation.CGSize
    @objc public static let videoRenderSize: CoreFoundation.CGSize
    @objc public static let defaultFrameRate: Swift.Int
    @objc override dynamic public init()
    @objc deinit
  }
  @objc final public let cameraMode: UnifiedVideoEditorSDK.CameraSessionType
  @objc public var renderContentMode: UnifiedVideoEditorSDK.RenderContentMode
  @objc public var renderSize: CoreFoundation.CGSize
  @objc public var captureSessionPreset: AVFoundation.AVCaptureSession.Preset
  @objc public var preferredRenderFrameRate: Swift.Int
  @objc public var shouldAutoStartOnEnterForeground: Swift.Bool
  @objc public var isMirrored: Swift.Bool
  @objc public var flipVertically: Swift.Bool
  @objc public var delayedCameraInitialization: Swift.Bool
  @objc public var orientation: BNBSdkCore.BNBCameraOrientation
  @objc public var notificationCenter: Foundation.NotificationCenter
  @objc override convenience dynamic public init()
  @objc convenience public init(renderMode: UnifiedVideoEditorSDK.EffectPlayerRenderMode, renderContentMode: UnifiedVideoEditorSDK.RenderContentMode = .resizeAspect, orientation: BNBSdkCore.BNBCameraOrientation = .deg90, preferredRenderFrameRate: Swift.Int = EffectPlayerConfiguration.Defaults.defaultFrameRate, shouldAutoStartOnEnterForeground: Swift.Bool = true, isMirrored: Swift.Bool = false, delayedCameraInitialization: Swift.Bool = false, notificationCenter: Foundation.NotificationCenter = NotificationCenter.default)
  @objc public init(cameraMode: UnifiedVideoEditorSDK.CameraSessionType, renderContentMode: UnifiedVideoEditorSDK.RenderContentMode = .resizeAspect, renderSize: CoreFoundation.CGSize, captureSessionPreset: AVFoundation.AVCaptureSession.Preset, orientation: BNBSdkCore.BNBCameraOrientation = .deg90, preferredRenderFrameRate: Swift.Int = EffectPlayerConfiguration.Defaults.defaultFrameRate, shouldAutoStartOnEnterForeground: Swift.Bool = true, isMirrored: Swift.Bool = false, flipVertically: Swift.Bool = true, delayedCameraInitialization: Swift.Bool = false, notificationCenter: Foundation.NotificationCenter = NotificationCenter.default)
  @objc deinit
}
extension CoreFoundation.CGSize {
  public func swap() -> CoreFoundation.CGSize
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class FullscreenActivityView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var text: Swift.String? {
    get
    set
  }
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var additionalButton: UIKit.UIButton?
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.FullScreenActivityConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) public func applyVisibility(_ visible: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public static func loadFromNib() -> UnifiedVideoEditorSDK.FullscreenActivityView
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct BorderButtonConfiguration {
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: CoreGraphics.CGColor
  public init(borderWidth: CoreFoundation.CGFloat, borderColor: CoreGraphics.CGColor)
}
public class VideoTrimData {
  public var start: CoreMedia.CMTime {
    get
  }
  public var end: CoreMedia.CMTime {
    get
  }
  public var duration: CoreMedia.CMTime {
    get
  }
  public init(start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  @objc deinit
}
@objc public protocol AppStateObserverDelegate {
  @objc func applicationWillResignActive(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc func applicationDidBecomeActive(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc optional func applicationWillEnterForeground(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc optional func applicationWillTerminateNotification(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc optional func applicationDidEnterBackgroundNotification(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
}
@_inheritsConvenienceInitializers @objc public class AppStateObserver : ObjectiveC.NSObject {
  weak public var delegate: (any UnifiedVideoEditorSDK.AppStateObserverDelegate)?
  public var appWillResignActive: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  convenience public init(delegate: (any UnifiedVideoEditorSDK.AppStateObserverDelegate)?)
  @objc deinit
}
extension UnifiedVideoEditorSDK.AppStateObserver {
  public func subscribeToNotifications()
  public func unsubscribeFromNotifications()
  @objc dynamic public func handleApplicationWillResignActiveNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleApplicationDidBecomeActiveNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleWillEnterForegroundNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleWillTerminateNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleDidEnterBackgroundNotification(_ notification: Foundation.Notification)
}
public enum AudioTrackLinePosition : Swift.Int, Swift.CaseIterable {
  case first
  case second
  case third
  case fourth
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UnifiedVideoEditorSDK.AudioTrackLinePosition]
  public typealias RawValue = Swift.Int
  public static var allCases: [UnifiedVideoEditorSDK.AudioTrackLinePosition] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public class AudioTrack : Swift.Equatable {
  public var isAudioRecord: Swift.Bool
  public var dbArray: [Swift.Float]?
  public var compositionTrack: AVFoundation.AVMutableCompositionTrack?
  public var avAssetTrack: AVFoundation.AVAssetTrack?
  public var avURLAsset: AVFoundation.AVURLAsset
  public var timeRange: CoreMedia.CMTimeRange
  public var trimmedTimeRange: CoreMedia.CMTimeRange
  public var compositionStart: CoreMedia.CMTime
  public var url: Foundation.URL
  public var originalURL: Foundation.URL
  public var coverURL: Foundation.URL?
  public var title: Swift.String?
  public var additionalTitle: Swift.String?
  public var id: Swift.Int32?
  final public let uuid: Foundation.UUID
  public var appliedFilterId: Swift.Int?
  public var isCameraTrack: Swift.Bool
  public var isEditable: Swift.Bool
  public var position: UnifiedVideoEditorSDK.AudioTrackLinePosition
  required public init(url: Foundation.URL, coverURL: Foundation.URL?, originalURL: Foundation.URL, uuid: Foundation.UUID, id: Swift.Int32?, timeRange: CoreMedia.CMTimeRange, trimTimeRange: CoreMedia.CMTimeRange, compositionStart: CoreMedia.CMTime, avURLAsset: AVFoundation.AVURLAsset, isAudioRecord: Swift.Bool, isEditable: Swift.Bool, isCameraTrack: Swift.Bool, title: Swift.String?, additionalTitle: Swift.String?, appliedFilterId: Swift.Int?)
  public static func == (lhs: UnifiedVideoEditorSDK.AudioTrack, rhs: UnifiedVideoEditorSDK.AudioTrack) -> Swift.Bool
  public func resetFilter()
  @objc deinit
}
final public class ApplicationInformation {
  required public init(bundle: Foundation.Bundle)
  final public var version: Swift.String {
    get
  }
  final public var build: Swift.String {
    get
  }
  final public var fullVersion: Swift.String {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers public class PixelationStaticEffectRenderer : UnifiedVideoEditorSDK.EffectMetalRenderer {
  override public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String, additionalParameters: [Swift.String : Any]?)
  required public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class GalleryViewControllerBuilder : ObjectiveC.NSObject, UnifiedVideoEditorSDK.GalleryViewControllerFactory {
  public static let shared: UnifiedVideoEditorSDK.GalleryViewControllerBuilder
  @objc public func makeGalleryViewController(withConfiguration configuration: UnifiedVideoEditorSDK.GalleryConfiguration, albumsConfiguration: UnifiedVideoEditorSDK.AlbumsConfiguration, selectionBehaviour: UnifiedVideoEditorSDK.GallerySelectionBehaviour) -> UnifiedVideoEditorSDK.GalleryViewController
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum CameraModuleSessionType : Swift.Int {
  case frontVideo
  case backVideo
  case frontPhoto
  case backPhoto
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct CameraModulePhotoSettings {
  public let useStabilization: Swift.Bool
  public let flashMode: AVFoundation.AVCaptureDevice.FlashMode
  public init(useStabilization: Swift.Bool, flashMode: AVFoundation.AVCaptureDevice.FlashMode)
}
public struct CameraModuleDefaults {
  public static var viewSize: CoreFoundation.CGSize {
    get
  }
}
@objc public protocol CameraModule : UnifiedVideoEditorSDK.SDKBeautyEffectManaging, UnifiedVideoEditorSDK.SDKEffectsServicing, UnifiedVideoEditorSDK.SDKInputServicing, UnifiedVideoEditorSDK.SDKOutputServicing, UnifiedVideoEditorSDK.SDKPIPServicing {
  @objc var isLoaded: Swift.Bool { get }
  @objc var allowProcessing: Swift.Bool { get set }
  @objc var autoStart: Swift.Bool { get set }
  @objc var isCameraEnabled: Swift.Bool { get set }
  @objc var renderQueue: Dispatch.DispatchQueue? { get }
  @objc func setup()
  @objc func setMaxFaces(facesCount: Swift.Int32)
  @objc func destroy()
  @objc func start(completion: @escaping () -> Swift.Void)
  @objc func stop(completion: (() -> Swift.Void)?)
  @objc func setRenderTarget(view: UIKit.UIView)
  @objc func removeRenderTarget()
  @objc func takeSnapshot(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc func getRendererView() -> UIKit.UIView
  @objc func startRenderLoop()
  @objc func stopRenderLoop()
  @objc func addFPSListener(_ listener: ((_ fpsInfo: Foundation.NSAttributedString) -> Swift.Void)?)
}
@objc public class VideoEditorLaunchConfig : ObjectiveC.NSObject {
  public var entryPoint: UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint
  public var hostController: UIKit.UIViewController
  public var videoItems: [Foundation.URL]?
  public var shouldCopyVideo: Swift.Bool
  public var draftedLaunchConfig: UnifiedVideoEditorSDK.VideoEditorLaunchConfig.DraftedLaunchConfig?
  public var pipVideoItem: Foundation.URL?
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack?
  public var animated: Swift.Bool
  public struct DraftedLaunchConfig {
    public var externalDraft: UnifiedVideoEditorSDK.ExternalDraft
    public var draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig
    public init(externalDraft: UnifiedVideoEditorSDK.ExternalDraft, draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig)
  }
  public init(entryPoint: UnifiedVideoEditorSDK.BanubaVideoEditorEntryPoint, hostController: UIKit.UIViewController, videoItems: [Foundation.URL]? = nil, shouldCopyVideo: Swift.Bool = false, pipVideoItem: Foundation.URL? = nil, draftedLaunchConfig: UnifiedVideoEditorSDK.VideoEditorLaunchConfig.DraftedLaunchConfig? = nil, musicTrack: UnifiedVideoEditorSDK.MediaTrack? = nil, animated: Swift.Bool)
  @objc deinit
}
public struct ExportCoverImages {
  public var coverImage: UIKit.UIImage?
  public var gifFileUrl: Foundation.URL?
}
public protocol BanubaVideoEditorDelegate : AnyObject {
  func videoEditorDidCancel(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor)
  func videoEditorDone(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor)
  func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, shouldProcessMediaUrls urls: [Foundation.URL]) -> Swift.Bool
  func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, didSaveDraft draft: UnifiedVideoEditorSDK.ExternalDraft)
}
extension UnifiedVideoEditorSDK.BanubaVideoEditorDelegate {
  public func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, shouldProcessMediaUrls urls: [Foundation.URL]) -> Swift.Bool
  public func videoEditor(_ videoEditor: UnifiedVideoEditorSDK.BanubaVideoEditor, didSaveDraft draft: UnifiedVideoEditorSDK.ExternalDraft)
}
public class BanubaVideoEditor {
  weak public var delegate: (any UnifiedVideoEditorSDK.BanubaVideoEditorDelegate)?
  public var musicMetadata: UnifiedVideoEditorSDK.MusicEditorMetadata? {
    get
  }
  public var metadata: UnifiedVideoEditorSDK.VideoEditorMetadata? {
    get
  }
  public var videoMetadata: UnifiedVideoEditorSDK.VideoMetadata? {
    get
  }
  public var blurEffectsList: UnifiedVideoEditorSDK.BlurList? {
    get
  }
  public var asset: AVFoundation.AVAsset? {
    get
  }
  public var externalAnalyticsEventListener: (any UnifiedVideoEditorSDK.ExternalSDKAnalyticsEventsListener)? {
    get
    set
  }
  public var externalLogListener: (any UnifiedVideoEditorSDK.ExternalLogListener)? {
    get
    set
  }
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack? {
    get
  }
  public var draftsService: UnifiedVideoEditorSDK.DraftsService {
    get
  }
  public var imageGenerator: AVFoundation.AVAssetImageGenerator? {
    get
  }
  public var currentConfiguration: UnifiedVideoEditorSDK.VideoEditorConfig {
    get
  }
  public var draftActionType: UnifiedVideoEditorSDK.DraftActionType {
    get
  }
  public init?(token: Swift.String, arguments: [Swift.String : Any] = [:], isCameraEnabled: Swift.Bool = true, configuration: UnifiedVideoEditorSDK.VideoEditorConfig, externalViewControllerFactory: (any UnifiedVideoEditorSDK.ExternalViewControllerFactory)? = nil)
  @objc deinit
  public func export(using configuration: UnifiedVideoEditorSDK.ExportConfiguration, exportProgress: ((Swift.Float) -> Swift.Void)?, completion: @escaping ((_ error: (any Swift.Error)?, _ exportCoverImages: UnifiedVideoEditorSDK.ExportCoverImages?) -> Swift.Void))
  public func stopExport()
  public func isExporting() -> Swift.Bool
  public func exportAudio(fileUrl: Foundation.URL, audioSettings: [Swift.String : Any] = VESettings.audio, completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public func clearSessionData()
  public func dismissVideoEditor(animated: Swift.Bool, completion: (() -> Swift.Void)?)
  public func getVideoEditorNavigationController(withLaunchConfiguration configuration: UnifiedVideoEditorSDK.VideoEditorLaunchConfig) -> UIKit.UINavigationController?
  public func presentVideoEditor(withLaunchConfiguration configuration: UnifiedVideoEditorSDK.VideoEditorLaunchConfig, completion: (() -> Swift.Void)?)
  public func updateVideoEditorConfig(_ config: UnifiedVideoEditorSDK.VideoEditorConfig)
  public func updateVideoEditorArgs(_ arguments: [Swift.String : Any])
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public static func presentSharingViewController(from hostController: UIKit.UIViewController, configuration: UnifiedVideoEditorSDK.SharingScreenConfiguration, mainVideoUrl: Foundation.URL, videoUrls: [Foundation.URL], previewImage: UIKit.UIImage, animated: Swift.Bool, completion: (() -> Swift.Void)?)
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public static func presentFeedBackAlertViewController(from hostController: UIKit.UIViewController, animated: Swift.Bool, completion: @escaping (UnifiedVideoEditorSDK.FeedbackAlertViewController.ActionTypes) -> Swift.Void)
  public static var currentDevice: Swift.String {
    get
  }
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public func exportExternalDraft(_ externalDraft: UnifiedVideoEditorSDK.ExternalDraft) throws -> Foundation.URL
  public func importExternalDraft(fromZipUrl url: Foundation.URL) throws -> UnifiedVideoEditorSDK.ExternalDraft
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
}
extension UnifiedVideoEditorSDK.BanubaVideoEditor {
  public struct TextLink : UnifiedVideoEditorSDK.ReflectedStringConvertible {
    public let title: Swift.String
    public let link: Swift.String
    public let start: Foundation.TimeInterval
    public let end: Foundation.TimeInterval
  }
  public var textLinks: [UnifiedVideoEditorSDK.BanubaVideoEditor.TextLink] {
    get
  }
}
@objc public class BanubaAudioBrowser : ObjectiveC.NSObject {
  @objc public init(audioBrowserConfig: UnifiedVideoEditorSDK.AudioBrowserConfig?, audioService: (any UnifiedVideoEditorSDK.AudioBrowserServiceAdoptable)? = nil, selectedTrack: UnifiedVideoEditorSDK.AudioBrowserTrack? = nil, isMusicLibraryEnabled: Swift.Bool, isSoundstripeEnabled: Swift.Bool, token: Swift.String, isAudioPartSelectionEnabled: Swift.Bool, videoDuration: Swift.Double)
  @objc public static func setMubertKeys(license: Swift.String, token: Swift.String)
  @objc public static func setPredefinedList(_ music: [UnifiedVideoEditorSDK.AudioBrowserTrack])
  @objc public func getAudioBrowserController() -> UIKit.UINavigationController
  @objc public static func setMusicLibraryConfiguration(_ configuration: UnifiedVideoEditorSDK.MusicLibraryConfiguration)
  @objc deinit
}
@objc public class MusicLibraryConfiguration : ObjectiveC.NSObject {
  @objc final public let authHeaderName: Swift.String
  @objc final public let authHeaderValue: Swift.String
  @objc final public let homeURL: Swift.String
  @objc final public let recentsURL: Swift.String
  @objc final public let favoritesURL: Swift.String
  @objc final public let addFavoriteURL: Swift.String
  @objc final public let removeFavoriteURL: Swift.String
  @objc final public let tracksURL: Swift.String
  @objc final public let searchTracksURL: Swift.String
  @objc final public let genresURL: Swift.String
  @objc final public let collectionsURL: Swift.String
  @objc final public let genreTracksURL: Swift.String
  @objc final public let collectionTracksURL: Swift.String
  @objc final public let tracksPerPage: Swift.Int
  @objc final public let noMatchesIcon: UnifiedVideoEditorSDK.ImageConfiguration?
  @objc final public let attentionIcon: UnifiedVideoEditorSDK.ImageConfiguration?
  @objc public init(authHeaderName: Swift.String, authHeaderValue: Swift.String, homeURL: Swift.String, recentsURL: Swift.String, favoritesURL: Swift.String, addFavoriteURL: Swift.String, removeFavoriteURL: Swift.String, tracksURL: Swift.String, searchTracksURL: Swift.String, genresURL: Swift.String, collectionsURL: Swift.String, genreTracksURL: Swift.String, collectionTracksURL: Swift.String, tracksPerPage: Swift.Int, noMatchesIcon: UnifiedVideoEditorSDK.ImageConfiguration?, attentionIcon: UnifiedVideoEditorSDK.ImageConfiguration?)
  @objc deinit
}
public protocol AlertViewControllerFactory : AnyObject {
  func getAlertViewController() -> UnifiedVideoEditorSDK.AlertViewController?
  func getPopoverAlertViewController() -> UnifiedVideoEditorSDK.PopoverAlertViewController?
}
extension UnifiedVideoEditorSDK.AlertViewControllerFactory where Self : UIKit.UIViewController {
  public func getPopoverAlertViewController() -> UnifiedVideoEditorSDK.PopoverAlertViewController?
}
public protocol AlertPresentable : UnifiedVideoEditorSDK.AlertViewControllerFactory {
  func presentAlertViewController(alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String?, disagreeButtonTitle: Swift.String?, animated: Swift.Bool, completion: @escaping ((_ success: Swift.Bool, _ buttonType: UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void))
  func presentPopoverAlert(position: UnifiedVideoEditorSDK.OverlayPopoverActionsPosition, actions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType) -> Swift.Void))
}
extension UnifiedVideoEditorSDK.AlertPresentable where Self : UIKit.UIViewController {
  public func presentAlertViewController(alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentAlert(alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool = false, completion: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String? = nil, disagreeButtonTitle: Swift.String? = nil, animated: Swift.Bool = false, completion: @escaping ((_ success: Swift.Bool, _ buttonType: UnifiedVideoEditorSDK.AlertViewController.ButtonType?) -> Swift.Void))
  public func presentPopoverAlert(position: UnifiedVideoEditorSDK.OverlayPopoverActionsPosition, actions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType) -> Swift.Void))
}
public protocol EffectRenderer {
  func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String, additionalParameters: [Swift.String : Any]?)
}
public struct MainMusicViewControllerConfig {
  public var editButtons: [UnifiedVideoEditorSDK.EditButtonConfig]
  public var editButtonsHeight: CoreFoundation.CGFloat
  public var editCompositionButtons: [UnifiedVideoEditorSDK.EditCompositionButtonConfig]
  public var controlButtons: [UnifiedVideoEditorSDK.ControlButtonConfig]
  public var playerControlsHeight: CoreFoundation.CGFloat
  public var audioWaveConfiguration: UnifiedVideoEditorSDK.AudioWaveConfiguration
  public var mainLabelColors: UIKit.UIColor
  public var additionalLabelColors: UIKit.UIColor
  public var tracksLimit: Swift.Int
  public var cursorColor: UIKit.UIColor
  public var controlsBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var previewViewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var videoControlsViewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public var toastConfiguration: UnifiedVideoEditorSDK.ToastConfiguration
}
public struct AudioRecorderViewControllerConfig {
  public var rewindToStartButton: UnifiedVideoEditorSDK.ControlButtonConfig?
  public var playPauseButton: UnifiedVideoEditorSDK.ControlButtonConfig
  public var playerControlsHeight: CoreFoundation.CGFloat
  public var recordButton: UnifiedVideoEditorSDK.ControlButtonConfig
  public var recordButtonBorderWidth: CoreFoundation.CGFloat
  public var backButtonImage: Swift.String
  public var doneButtonImage: Swift.String
  public var dimViewColor: UIKit.UIColor
  public var additionalLabelColors: UIKit.UIColor
  public var startingRecordingTimerSeconds: Foundation.TimeInterval
  public var timerColor: UIKit.UIColor
  public var cursorColor: UIKit.UIColor
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var playerControlsBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public var resetButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var controlButtonsTintColor: UIKit.UIColor?
}
public struct VideoTrackLineEditViewControllerConfig {
  public var doneButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var cancelButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var sliderTintColor: UIKit.UIColor
  public var thumbImage: UnifiedVideoEditorSDK.ImageConfiguration?
  public var mainLabelColors: UIKit.UIColor
  public var additionalLabelColors: UIKit.UIColor
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
}
public struct AudioWaveConfiguration {
  public var waveBorderColor: UIKit.UIColor
  public var waveCornerRadius: CoreFoundation.CGFloat
  public var waveLinesColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var maxWaveHeight: CoreFoundation.CGFloat
  public var audioTitleFont: UIKit.UIFont?
  public var audioTitleColor: UIKit.UIColor?
  public var bottomOffset: CoreFoundation.CGFloat
}
public struct AudioTrackLineEditViewControllerConfig {
  public var songLabelTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var audioWaveConfiguration: UnifiedVideoEditorSDK.AudioWaveConfiguration
  public var doneButtonImageName: Swift.String
  public var doneButtonTintColor: UIKit.UIColor?
  public var cancelButtonImageName: Swift.String
  public var cancelButtonTintColor: UIKit.UIColor?
  public var sliderTintColor: UIKit.UIColor
  public var sliderThumbImage: UnifiedVideoEditorSDK.ImageConfiguration?
  public var draggersColor: UIKit.UIColor
  public var draggerImageName: Swift.String?
  public var trimHeight: CoreFoundation.CGFloat
  public var trimBorderColor: UIKit.UIColor
  public var trimBorderWidth: CoreFoundation.CGFloat
  public var cursorHeight: CoreFoundation.CGFloat
  public var dimViewColor: UIKit.UIColor
  public var mainLabelColors: UIKit.UIColor
  public var additionalLabelColors: UIKit.UIColor
  public var cursorColor: UIKit.UIColor
  public var draggersWidth: CoreFoundation.CGFloat
  public var draggersLineColor: UIKit.UIColor
  public var draggersCornerRadius: CoreFoundation.CGFloat
  public var draggersLineWidth: CoreFoundation.CGFloat
  public var draggersLineHeight: CoreFoundation.CGFloat
  public var numberOfLinesInDraggers: Swift.Int
  public var draggerLinesSpacing: CoreFoundation.CGFloat
  public var draggersLineCornerRadius: CoreFoundation.CGFloat
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var voiceFilterConfiguration: UnifiedVideoEditorSDK.VoiceFilterConfiguration?
  public var voiceFilterProvider: (any UnifiedVideoEditorSDK.VoiceFilterProvider)?
  public var isVoiceFilterHidden: Swift.Bool {
    get
  }
}
public struct EditButtonConfig {
  public enum `Type` : Swift.String {
    case track
    case effect
    case record
    case volume
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var font: UIKit.UIFont
  public var type: UnifiedVideoEditorSDK.EditButtonConfig.`Type`
  public var title: Swift.String
  public var titleColor: UIKit.UIColor
  public var imageName: Swift.String
  public var tintColor: UIKit.UIColor?
  public init(font: UIKit.UIFont, type: UnifiedVideoEditorSDK.EditButtonConfig.`Type`, title: Swift.String, titleColor: UIKit.UIColor, imageName: Swift.String, tintColor: UIKit.UIColor? = nil)
}
public struct EditCompositionButtonConfig {
  public enum `Type` : Swift.String {
    case voiceEffect
    case edit
    case delete
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var font: UIKit.UIFont
  public var type: UnifiedVideoEditorSDK.EditCompositionButtonConfig.`Type`
  public var title: Swift.String
  public var titleColor: UIKit.UIColor
  public var imageName: Swift.String
  public var selectedImageName: Swift.String?
  public var tintColor: UIKit.UIColor?
  public init(font: UIKit.UIFont, type: UnifiedVideoEditorSDK.EditCompositionButtonConfig.`Type`, title: Swift.String, titleColor: UIKit.UIColor, imageName: Swift.String, selectedImageName: Swift.String?, tintColor: UIKit.UIColor? = nil)
}
public struct ControlButtonConfig {
  public enum `Type` : Swift.String {
    case reset
    case play
    case done
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var type: UnifiedVideoEditorSDK.ControlButtonConfig.`Type`
  public var image: UIKit.UIImage?
  public var selectedImage: UIKit.UIImage?
  public var imageName: Swift.String
  public var selectedImageName: Swift.String?
  public var imageEdgeInsets: UIKit.UIEdgeInsets?
  public var tintColor: UIKit.UIColor?
  public init(type: UnifiedVideoEditorSDK.ControlButtonConfig.`Type`, imageName: Swift.String, selectedImageName: Swift.String?, imageEdgeInsets: UIKit.UIEdgeInsets? = nil, tintColor: UIKit.UIColor? = nil)
}
public typealias TextButtonConfig = UnifiedVideoEditorSDK.MusicEditor.TextButtonConfig
public struct MusicEditor {
  public struct TextButtonConfig {
    public var font: UIKit.UIFont
    public var color: UIKit.UIColor
    public var title: Swift.String
  }
}
public struct VoiceFilterConfiguration {
  public var cornerRadius: CoreFoundation.CGFloat
  public var imageCornerRadius: CoreFoundation.CGFloat
  public var selectionBorderWidth: CoreFoundation.CGFloat
  public var selectionColor: UIKit.UIColor
  public var font: UIKit.UIFont
  public var textColor: UIKit.UIColor
  public var noneFilterTitle: Swift.String?
  public var noneFilterImageName: Swift.String
  public var availableVoiceFilterIDs: [Swift.Int]?
  public init(cornerRadius: CoreFoundation.CGFloat, imageCornerRadius: CoreFoundation.CGFloat, selectionBorderWidth: CoreFoundation.CGFloat, selectionColor: UIKit.UIColor, font: UIKit.UIFont, textColor: UIKit.UIColor, noneFilterTitle: Swift.String?, noneFilterImageName: Swift.String)
}
public struct BackButtonConfiguration {
  public var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var position: UnifiedVideoEditorSDK.BackButtonConfiguration.Position?
  public var menuActions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType]
  @frozen public enum Position {
    case left
    case right
    public static func == (a: UnifiedVideoEditorSDK.BackButtonConfiguration.Position, b: UnifiedVideoEditorSDK.BackButtonConfiguration.Position) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? = nil, position: UnifiedVideoEditorSDK.BackButtonConfiguration.Position? = nil, menuActions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType] = [])
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class NibView : UIKit.UIView, UnifiedVideoEditorSDK.NibLoadable {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func commonInit()
  @objc deinit
}
public protocol VoiceFilterProvider {
  func provideFilters() -> [UnifiedVideoEditorSDK.VoiceFilter]
}
public enum AVAudioEngineUnit {
  case timePitch
  case reverb
  case delay
  public static func == (a: UnifiedVideoEditorSDK.AVAudioEngineUnit, b: UnifiedVideoEditorSDK.AVAudioEngineUnit) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum AVAudioEngineUnitParameter {
  case pitch
  case rate
  case wetDryMix
  case delayTime
  case feedback
  public static func == (a: UnifiedVideoEditorSDK.AVAudioEngineUnitParameter, b: UnifiedVideoEditorSDK.AVAudioEngineUnitParameter) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum VoiceEffectType : Swift.Int {
  case baritone
  case echo
  case elf
  case giant
  case robot
  case squirrel
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public typealias AVAudioEngineUnitSettings = [UnifiedVideoEditorSDK.AVAudioEngineUnitParameter : Swift.Float]
public typealias AVAudioEngineFilterSetting = [UnifiedVideoEditorSDK.AVAudioEngineUnit : UnifiedVideoEditorSDK.AVAudioEngineUnitSettings]
public struct VoiceFilter : Swift.Equatable {
  public var id: Swift.Int {
    get
  }
  public let type: UnifiedVideoEditorSDK.VoiceEffectType
  public var title: Swift.String?
  public var color: UIKit.UIColor
  public var image: UIKit.UIImage?
  public var settings: UnifiedVideoEditorSDK.AVAudioEngineFilterSetting
  public init(type: UnifiedVideoEditorSDK.VoiceEffectType, title: Swift.String?, color: UIKit.UIColor? = nil, image: UIKit.UIImage?, settings: UnifiedVideoEditorSDK.AVAudioEngineFilterSetting? = nil)
  public static func == (lhs: UnifiedVideoEditorSDK.VoiceFilter, rhs: UnifiedVideoEditorSDK.VoiceFilter) -> Swift.Bool
}
public protocol TransformEffectsSDKServicing {
  var effectsApplicator: any UnifiedVideoEditorSDK.EffectsApplicatorServicing { get }
}
public protocol EffectsSDKServicing : UnifiedVideoEditorSDK.TransformEffectsSDKServicing {
  var watermarkApplicator: any UnifiedVideoEditorSDK.WatermarkApplicatorServicing { get }
  var effectsConfigHolder: any UnifiedVideoEditorSDK.EffectsHolderServicing { get }
}
@objc public protocol OutputServicing {
  @objc func configureWatermark(_ watermarkInfo: UnifiedVideoEditorSDK.WatermarkInfo)
  @objc func takeSnapshot(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc func takeSnapshot(configuration: UnifiedVideoEditorSDK.OutputConfiguration, handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc func removeWatermark()
  @objc func startVideoCapturing(fileURL: Foundation.URL?, externalAudioConfiguration: UnifiedVideoEditorSDK.ExternalAudioConfiguration?, progress: ((CoreMedia.CMTime) -> Swift.Void)?, didStart: (() -> Swift.Void)?, shouldSkipFrame: (() -> Swift.Bool)?, isFirstRun: Swift.Bool, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue]?, boundaryHandler: ((CoreMedia.CMTime) -> Swift.Void)?, totalDuration: Foundation.TimeInterval, configuration: UnifiedVideoEditorSDK.OutputConfiguration, completion: @escaping (Swift.Bool, (any Swift.Error)?) -> Swift.Void)
  @objc func stopVideoCapturing(cancel: Swift.Bool)
  @objc func reset()
  @objc func hasDiskCapacityForRecording() -> Swift.Bool
  @objc func startMuteEffectSoundIfNeeded()
  @objc func stopMuteEffectSound()
  @objc var isRecording: Swift.Bool { get }
  @objc var videoSize: CoreFoundation.CGSize { get set }
  @objc var cropOffsetY: Swift.Int { get set }
}
@objc public class OutputConfiguration : ObjectiveC.NSObject {
  @objc final public let applyWatermark: Swift.Bool
  @objc final public let adjustDeviceOrientation: Swift.Bool
  @objc final public let mirrorFrontCamera: Swift.Bool
  @objc final public let useHEVCCodecIfPossible: Swift.Bool
  @objc public init(applyWatermark: Swift.Bool, adjustDeviceOrientation: Swift.Bool, mirrorFrontCamera: Swift.Bool, useHEVCCodecIfPossible: Swift.Bool)
  @objc public static var defaultConfiguration: UnifiedVideoEditorSDK.OutputConfiguration {
    @objc get
  }
  @objc deinit
}
public struct VESettings {
  public static var audio: [Swift.String : Any] {
    get
  }
}
public class TextEditSelectionBorderAnimationBehavior : UnifiedVideoEditorSDK.TextEditSelectionColorBehavior {
  final public let defaultBorderWidth: CoreFoundation.CGFloat
  final public let selectedBorderWidth: CoreFoundation.CGFloat
  public init(defaultBorderWidth: CoreFoundation.CGFloat, selectedBorderWidth: CoreFoundation.CGFloat)
  public func setColorView(_ colorView: UIKit.UIView, selected: Swift.Bool, animated: Swift.Bool)
  @objc deinit
}
extension Swift.String : UnifiedVideoEditorSDK.KingfisherCompatibleValue {
}
extension CoreFoundation.CGPoint {
  public mutating func transformToGradientSpace()
  public func oppositePoint() -> CoreFoundation.CGPoint
  public static func gradientPointForAngle(_ angle: CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration {
  public static var `default`: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration {
    get
  }
}
public enum DiskStorage {
  @_hasMissingDesignatedInitializers public class Backend<T> where T : UnifiedVideoEditorSDK.DataTransformable {
    public var config: UnifiedVideoEditorSDK.DiskStorage.Config
    final public let directoryURL: Foundation.URL
    convenience public init(config: UnifiedVideoEditorSDK.DiskStorage.Config) throws
    public func store(value: T, forKey key: Swift.String, expiration: UnifiedVideoEditorSDK.StorageExpiration? = nil, writeOptions: Foundation.Data.WritingOptions = []) throws
    public func value(forKey key: Swift.String, extendingExpiration: UnifiedVideoEditorSDK.ExpirationExtending = .cacheTime) throws -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func isCached(forKey key: Swift.String, referenceDate: Foundation.Date) -> Swift.Bool
    public func remove(forKey key: Swift.String) throws
    public func removeAll() throws
    public func cacheFileURL(forKey key: Swift.String) -> Foundation.URL
    public func removeExpiredValues() throws -> [Foundation.URL]
    public func totalSize() throws -> Swift.UInt
    @objc deinit
  }
}
extension UnifiedVideoEditorSDK.DiskStorage {
  public struct Config {
    public var sizeLimit: Swift.UInt
    public var expiration: UnifiedVideoEditorSDK.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public var autoExtAfterHashedFileName: Swift.Bool
    public var cachePathBlock: ((_ directory: Foundation.URL, _ cacheName: Swift.String) -> Foundation.URL)!
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
  }
}
@_hasMissingDesignatedInitializers public class DefaultCountdownAnimatableView : UnifiedVideoEditorSDK.CountdownTimerViewFactory {
  public func makeCountdownTimerView() -> any UnifiedVideoEditorSDK.CountdownTimerAnimatableView
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class CountdownView : UIKit.UIView, UnifiedVideoEditorSDK.CountdownTimerAnimatableView {
  @_Concurrency.MainActor(unsafe) public var font: UIKit.UIFont {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func draw(_ rect: CoreFoundation.CGRect)
  @objc deinit
}
extension UnifiedVideoEditorSDK.CountdownView {
  @_Concurrency.MainActor(unsafe) public var countdownDigit: Swift.Int {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var digitColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func stop()
}
public struct VideoAspectRatio {
  public static var minFillAspectRatio: CoreFoundation.CGFloat {
    get
  }
  public static var maxFillAspectRatio: CoreFoundation.CGFloat {
    get
  }
  public static var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> {
    get
  }
}
public struct VideoEditorDurationConfig {
  public var maximumVideoDuration: Foundation.TimeInterval
  public var videoDurations: [Foundation.TimeInterval]
  public var minimumDurationFromCamera: Foundation.TimeInterval
  public var minimumDurationFromGallery: Foundation.TimeInterval
  public var minimumVideoDuration: Foundation.TimeInterval
  public var minimumTrimmedPartDuration: Foundation.TimeInterval
  public var slideshowDuration: Foundation.TimeInterval
  public init(maximumVideoDuration: Foundation.TimeInterval, videoDurations: [Foundation.TimeInterval], minimumDurationFromCamera: Foundation.TimeInterval, minimumDurationFromGallery: Foundation.TimeInterval, minimumVideoDuration: Foundation.TimeInterval, minimumTrimmedPartDuration: Foundation.TimeInterval, slideshowDuration: Foundation.TimeInterval)
  public static var `default`: UnifiedVideoEditorSDK.VideoEditorDurationConfig {
    get
  }
  public func validateTrimRecorderVideoSupporting(supportsTrimRecordedVideo: Swift.Bool)
}
@objc public protocol SDKMaskPostprocessServicing {
  @objc func processVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  @objc func surfaceCreated(with size: CoreFoundation.CGSize)
  @objc func setEffectSize(_ size: CoreFoundation.CGSize)
  @objc func loadEffect(path: Swift.String)
}
public protocol VEExportServicing : UnifiedVideoEditorSDK.ImageSlideshow {
  func exportVideo(to fileURL: Foundation.URL, using exportVideoInfo: UnifiedVideoEditorSDK.ExportVideoInfo, watermarkFilterModel: UnifiedVideoEditorSDK.VideoEditorFilterModel?, exportProgress: ((Swift.Float) -> Swift.Void)?, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  func exportAudio(to fileURL: Foundation.URL, asset: AVFoundation.AVAsset?, audioSettings: [Swift.String : Any], completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
}
public struct SharingServiceModel {
  public enum SharingType {
    case facebookReels
    case facebookStories
    case instagramStories
    case other
    public static func == (a: UnifiedVideoEditorSDK.SharingServiceModel.SharingType, b: UnifiedVideoEditorSDK.SharingServiceModel.SharingType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let sharingType: UnifiedVideoEditorSDK.SharingServiceModel.SharingType
  public let sharingTitle: Swift.String
  public let sharingImage: UIKit.UIImage
  public init(sharingType: UnifiedVideoEditorSDK.SharingServiceModel.SharingType, sharingTitle: Swift.String, sharingImage: UIKit.UIImage)
}
extension UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.TextConfiguration, with text: Swift.String)
}
public protocol PlayableViewController : AnyObject {
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func playRange(_ range: CoreMedia.CMTimeRange, loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func pause()
  func smoothlySeek(to time: CoreMedia.CMTime)
  func seek(to time: CoreMedia.CMTime)
  func reloadPreview(shouldAutoStart: Swift.Bool)
  func didVideoPlay(atTime time: CoreMedia.CMTime)
  var currentTime: CoreMedia.CMTime { get }
  var videoDuration: CoreMedia.CMTime { get }
  var player: (any UnifiedVideoEditorSDK.VideoEditorPlayable)? { get }
  var isPlaying: Swift.Bool { get }
  var previewVideoView: (any UnifiedVideoEditorSDK.VideoPlayableView)? { get }
}
public protocol AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  var onDownloadTaskStarted: ((UnifiedVideoEditorSDK.DownloadTask?) -> Swift.Void)? { get }
}
public protocol ImageDownloadRequestModifier : UnifiedVideoEditorSDK.AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
}
extension UnifiedVideoEditorSDK.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public var onDownloadTaskStarted: ((UnifiedVideoEditorSDK.DownloadTask?) -> Swift.Void)? {
    get
  }
}
public struct AnyModifier : UnifiedVideoEditorSDK.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  public init(modify: @escaping (Foundation.URLRequest) -> Foundation.URLRequest?)
}
@objc public class AlbumsConfiguration : ObjectiveC.NSObject {
  public var textButton: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var arrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var backButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var albumItemConfiguration: UnifiedVideoEditorSDK.AlbumItemConfiguration
  public var backgroundColor: UIKit.UIColor
  public init(textButton: UnifiedVideoEditorSDK.TextButtonConfiguration, arrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, backButton: UnifiedVideoEditorSDK.BackButtonConfiguration, albumItemConfiguration: UnifiedVideoEditorSDK.AlbumItemConfiguration, backgroundColor: UIKit.UIColor)
  @objc deinit
}
@objc public class AlbumItemConfiguration : ObjectiveC.NSObject {
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var numberOfAlbumItemsConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var coverCornerRadius: CoreFoundation.CGFloat
  public init(titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration, numberOfAlbumItemsConfiguration: UnifiedVideoEditorSDK.TextConfiguration, coverCornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
public enum ExportQuality {
  case videoConfiguration(UnifiedVideoEditorSDK.ExportVideoInfo)
  case auto
}
public struct GifSettings {
  public var duration: Foundation.TimeInterval
  public var width: CoreFoundation.CGFloat
  public var fps: Foundation.TimeInterval
  public var isReversed: Swift.Bool
  public init(duration: Foundation.TimeInterval, width: CoreFoundation.CGFloat = 240, fps: Foundation.TimeInterval = 15.0, isReversed: Swift.Bool = true)
}
public struct ExportConfiguration {
  public let videoConfigurations: [UnifiedVideoEditorSDK.ExportVideoConfiguration]
  public let isCoverEnabled: Swift.Bool
  public var gifSettings: UnifiedVideoEditorSDK.GifSettings?
  public static func defaultConfiguration(fileURL: Foundation.URL) -> UnifiedVideoEditorSDK.ExportConfiguration
  public init(videoConfigurations: [UnifiedVideoEditorSDK.ExportVideoConfiguration], isCoverEnabled: Swift.Bool, gifSettings: UnifiedVideoEditorSDK.GifSettings?)
}
public struct ExportVideoConfiguration {
  public let fileURL: Foundation.URL
  public let quality: UnifiedVideoEditorSDK.ExportQuality
  public let useHEVCCodecIfPossible: Swift.Bool
  public let audioSettings: [Swift.String : Any]?
  public let watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?
  public init(fileURL: Foundation.URL, quality: UnifiedVideoEditorSDK.ExportQuality, useHEVCCodecIfPossible: Swift.Bool, audioSettings: [Swift.String : Any]? = VESettings.audio, watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func withLatestFrom<Other, Result>(_ other: Other, resultSelector: @escaping (Self.Output, Other.Output) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Other, Result> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1, Result>(_ other: Other, _ other1: Other1, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2, Result>(_ other: Other, _ other1: Other1, _ other2: Other2, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output, Other2.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
  public func withLatestFrom<Other>(_ other: Other) -> Combine.Publishers.WithLatestFrom<Self, Other, Other.Output> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1>(_ other: Other, _ other1: Other1) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, (Other.Output, Other1.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2>(_ other: Other, _ other1: Other1, _ other2: Other2) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, (Other.Output, Other1.Output, Other2.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct WithLatestFrom<Upstream, Other, Output> : Combine.Publisher where Upstream : Combine.Publisher, Other : Combine.Publisher, Upstream.Failure == Other.Failure {
    public typealias Failure = Upstream.Failure
    public typealias ResultSelector = (Upstream.Output, Other.Output) -> Output
    public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, Other.Failure == S.Failure
  }
}
extension CoreFoundation.CGFloat {
  public var gradientPoints: (CoreFoundation.CGPoint, CoreFoundation.CGPoint) {
    get
  }
}
public class BanubaCancelHandler {
  public init(handler: @escaping () -> Swift.Void)
  public func cancel()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class BanubaAsyncOperation : Foundation.Operation {
  @objc override dynamic open var isReady: Swift.Bool {
    @objc get
  }
  @objc final override public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc final override public var isFinished: Swift.Bool {
    @objc get
  }
  @objc final override public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic open class func keyPathsForValuesAffectingValue(forKey key: Swift.String) -> Swift.Set<Swift.String>
  @objc final override public func start()
  @objc override dynamic open func main()
  final public func finish()
  @objc override dynamic public init()
  @objc deinit
}
public protocol ImageDownloadRedirectHandler {
  func handleHTTPRedirection(for task: UnifiedVideoEditorSDK.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct AnyRedirectHandler : UnifiedVideoEditorSDK.ImageDownloadRedirectHandler {
  public func handleHTTPRedirection(for task: UnifiedVideoEditorSDK.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public init(handle: @escaping (UnifiedVideoEditorSDK.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
}
public protocol ImageDataProvider {
  var cacheKey: Swift.String { get }
  func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  var contentURL: Foundation.URL? { get }
}
extension UnifiedVideoEditorSDK.ImageDataProvider {
  public var contentURL: Foundation.URL? {
    get
  }
  public func convertToSource() -> UnifiedVideoEditorSDK.Source
}
public struct LocalFileImageDataProvider : UnifiedVideoEditorSDK.ImageDataProvider {
  public let fileURL: Foundation.URL
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil, loadingQueue: UnifiedVideoEditorSDK.ExecutionQueue = .dispatch(DispatchQueue.global(qos: .userInitiated)))
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $EffectfulProp
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
  public var data: Foundation.Data {
    get async throws
  }
  #endif
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct Base64ImageDataProvider : UnifiedVideoEditorSDK.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public struct RawImageDataProvider : UnifiedVideoEditorSDK.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
extension Swift.Double {
  public func formatted(isMiliSecondsEnabled: Swift.Bool = true, isMinutesInFullFormat: Swift.Bool = false) -> Swift.String
  public func stringFromTimeInterval() -> Swift.String
}
@_hasMissingDesignatedInitializers public class ExportScaledTimeline : UnifiedVideoEditorSDK.EffectStack {
  public var composition: AVFoundation.AVMutableComposition? {
    get
  }
  public init(with composition: AVFoundation.AVMutableComposition?, allowOverlappingVisualEffects: Swift.Bool = false)
  public func scaleAndArrange(with effects: [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol])
  public func canBeIntersected(effectType: UnifiedVideoEditorSDK.EditorEffectType) -> Swift.Bool
  @objc deinit
}
extension UnifiedVideoEditorSDK.ExportScaledTimeline : UnifiedVideoEditorSDK.SDKVideoCompositionInstructionDataSource {
  public func getEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  public func getEffectsBefore(time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
}
public protocol AudioItem {
  var uuid: Foundation.UUID { get }
  var url: Foundation.URL { get }
  var coverURL: Foundation.URL? { get }
  var title: Swift.String? { get set }
  var additionalTitle: Swift.String? { get set }
  var isEditable: Swift.Bool { get set }
}
public struct ImageProgressive {
  public enum UpdatingStrategy {
    case `default`
    case keepCurrent
    case replace(UnifiedVideoEditorSDK.KFCrossPlatformImage?)
  }
  @available(*, deprecated, renamed: "init()", message: "Getting a default `ImageProgressive` is deprecated due to its syntax symatic is not clear. Use `ImageProgressive.init` instead.")
  public static let `default`: UnifiedVideoEditorSDK.ImageProgressive
  public let onImageUpdated: UnifiedVideoEditorSDK.Delegate<UnifiedVideoEditorSDK.KFCrossPlatformImage, UnifiedVideoEditorSDK.ImageProgressive.UpdatingStrategy>
  public init()
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
@objc public protocol BanubaSdkManagerDelegate {
  @objc func willPresent(changedPixelBuffer: CoreVideo.CVPixelBuffer?)
  @objc func willOutput(pixelBuffer: CoreVideo.CVPixelBuffer)
  @objc func didReceiveFPSInfo(_ cameraFPS: Swift.Float, recognizerFPS: Swift.Float, renderFPS: Swift.Float)
}
@_inheritsConvenienceInitializers @objc public class BanubaSdkManager : ObjectiveC.NSObject {
  @objc weak public var delegate: (any UnifiedVideoEditorSDK.BanubaSdkManagerDelegate)?
  @objc public var effectPlayer: BNBSdkCore.BNBEffectPlayer? {
    get
  }
  @objc public var faceOrientation: Swift.Int
  @objc public var isCameraEnabled: Swift.Bool
  @objc public func effectManager() -> BNBSdkCore.BNBEffectManager?
  @objc public var autoRotationEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public func loadEffect(_ effectUrl: Swift.String, synchronous: Swift.Bool = false) -> BNBSdkCore.BNBEffect?
  @objc public func currentEffect() -> BNBSdkCore.BNBEffect?
  @objc public func setMaxFaces(_ maxFaces: Swift.Int32)
  public var voiceChanger: (any UnifiedVideoEditorSDK.VoiceChangeable)? {
    get
  }
  @objc public var input: any UnifiedVideoEditorSDK.InputServicing {
    @objc get
    @objc set
  }
  @objc public var output: (any UnifiedVideoEditorSDK.OutputServicing)? {
    @objc get
  }
  @objc public var renderTarget: UnifiedVideoEditorSDK.RenderTarget?
  @objc public var playerConfiguration: UnifiedVideoEditorSDK.EffectPlayerConfiguration? {
    @objc get
  }
  @objc public func setRenderTarget(view: UnifiedVideoEditorSDK.EffectPlayerView, playerConfiguration: UnifiedVideoEditorSDK.EffectPlayerConfiguration?)
  @objc public func setRenderTarget(layer: QuartzCore.CAMetalLayer, renderMode: UnifiedVideoEditorSDK.EffectPlayerRenderMode, contentMode: UnifiedVideoEditorSDK.RenderContentMode = .resizeAspectFill)
  @objc public func setRenderTarget(layer: QuartzCore.CAMetalLayer, contentMode: UnifiedVideoEditorSDK.RenderContentMode = .resizeAspectFill, playerConfiguration: UnifiedVideoEditorSDK.EffectPlayerConfiguration?)
  @objc public func removeRenderTarget()
  public var editingImageFrameData: BNBSdkCore.BNBFrameData? {
    get
  }
  @objc public var renderThread: Foundation.Thread? {
    @objc get
  }
  @objc public var shouldAutoStartOnEnterForeground: Swift.Bool
  @objc public var isLoaded: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc public class func initialize(resourcePath: [Swift.String] = [], clientTokenString: Swift.String, logLevel: BNBSdkCore.BNBSeverityLevel = .info)
  @objc public class func deinitialize()
  @objc deinit
  @objc public func setup(configuration: UnifiedVideoEditorSDK.EffectPlayerConfiguration)
  @objc public func destroy()
  @objc public static func scaleBeforeProcessing(_ buffer: CoreVideo.CVPixelBuffer?) -> CoreVideo.CVPixelBuffer?
  @objc public var isDrawOnDemandMode: Swift.Bool {
    get
  }
  @objc public var frameOnDemandRendered: Swift.Bool {
    get
  }
  @objc public func setDrawOnDemandMode(_ mode: Swift.Bool)
  @objc public func requestFrameDraw()
}
@objc extension UnifiedVideoEditorSDK.BanubaSdkManager : UnifiedVideoEditorSDK.InputServiceDelegate {
  @objc dynamic public func push(cmBuffer: CoreMedia.CMSampleBuffer)
  @objc dynamic public func push(cvBuffer: CoreVideo.CVPixelBuffer)
}
@objc extension UnifiedVideoEditorSDK.BanubaSdkManager {
  @objc dynamic public func startEffectPlayer()
  @objc dynamic public func stopEffectPlayer()
  @objc dynamic public func destroyEffectPlayer()
  @objc dynamic public func startEditingImage(_ image: UIKit.UIImage, recognizerIterations: Foundation.NSNumber? = nil, imageOrientation: BNBSdkCore.BNBCameraOrientation = .deg0, requireMirroring: Swift.Bool = false, faceOrientation: Swift.Int = 0, fieldOfView: Swift.Float = 60, resetEffect: Swift.Bool = false, completion: ((Swift.Int, CoreFoundation.CGRect) -> Swift.Void)? = nil)
  @objc dynamic public func updateEditingFrameWithImage(_ image: UIKit.UIImage, imageOrientation: BNBSdkCore.BNBCameraOrientation = .deg0, requireMirroring: Swift.Bool = false, faceOrientation: Swift.Int = 0, fieldOfView: Swift.Float = 60, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc dynamic public func captureEditedImage(imageOrientation: BNBSdkCore.BNBCameraOrientation = .deg0, resetEffect: Swift.Bool = false, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc dynamic public func stopEditingImage(startCameraInput: Swift.Bool = false)
  @objc dynamic public func makeCameraPhoto(cameraSettings: UnifiedVideoEditorSDK.CameraPhotoSettings, flipFrontCamera: Swift.Bool = false, srcImageHandler: ((CoreVideo.CVPixelBuffer) -> Swift.Void)? = nil, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc dynamic public func processImageData(_ inputData: CoreVideo.CVImageBuffer, orientation: BNBSdkCore.BNBCameraOrientation = .deg0, faceOrientation: Swift.Int = 0, fieldOfView: Swift.Float = 60, isMirrored: Swift.Bool = false, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc dynamic public func processImageData(_ imputImage: UIKit.UIImage, orientation: BNBSdkCore.BNBCameraOrientation = .deg0, fieldOfView: Swift.Float = 60, isMirrored: Swift.Bool = false, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc dynamic public func configureWatermark(_ watermarkInfo: UnifiedVideoEditorSDK.WatermarkInfo)
  @objc dynamic public func removeWatermark()
  @objc dynamic public func startVideoProcessing(width: Swift.UInt, height: Swift.UInt, orientation: BNBSdkCore.BNBCameraOrientation = .deg0, resetEffect: Swift.Bool = false)
  @objc dynamic public func stopVideoProcessing(resetEffect: Swift.Bool = false)
  @objc dynamic public func processVideoFrame(from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, timeNs: Swift.Int64, iterations: Foundation.NSNumber? = nil, cameraOrientation: BNBSdkCore.BNBCameraOrientation = .deg0, requireMirroring: Swift.Bool = false, faceOrientation: Swift.Int = 0, fieldOfView: Swift.Float = 60)
  @objc dynamic public var imageOrientationForCameraPhoto: BNBSdkCore.BNBCameraOrientation {
    @objc get
  }
}
extension UnifiedVideoEditorSDK.BanubaSdkManager : BNBSdkCore.BNBCameraPoiListener {
  @objc dynamic public func onCameraPoiChanged(_ x: Swift.Float, y: Swift.Float)
}
extension UnifiedVideoEditorSDK.BanubaSdkManager : BNBSdkCore.BNBFaceNumberListener {
  @objc dynamic public func onFaceNumberChanged(_ faceNumber: Swift.Int32)
}
extension UnifiedVideoEditorSDK.BanubaSdkManager : BNBSdkCore.BNBFrameDurationListener {
  public func listenFrameDuration()
  @objc dynamic public func onRecognizerFrameDurationChanged(_ instant: Swift.Float, averaged: Swift.Float)
  @objc dynamic public func onCameraFrameDurationChanged(_ instant: Swift.Float, averaged: Swift.Float)
  @objc dynamic public func onRenderFrameDurationChanged(_ instant: Swift.Float, averaged: Swift.Float)
}
extension UnifiedVideoEditorSDK.BanubaSdkManager {
  public var isPiPPlayerLandscapeOrientation: Swift.Bool? {
    get
  }
  public var isPIPPlayerReadyToProvideData: Swift.Bool? {
    get
  }
  public func createPIPPlayer(withVideoURL url: Foundation.URL, completion: (() -> Swift.Void)?)
  public func startPIPPlayer()
  public func stopPIPPlayer()
  public func setPIPPlayerVolume(_ volume: Swift.Float)
  public func seekPIPPlayer(to time: Foundation.TimeInterval)
  public func setPIPPlayer(renderBehaviour: UnifiedVideoEditorSDK.RenderBehavior)
  public func setPIPPlayer(shapeType type: UnifiedVideoEditorSDK.PIPShapeBuilder.PIPShapeType)
  public func setRenderTarget(shapeType type: UnifiedVideoEditorSDK.PIPShapeBuilder.PIPShapeType)
  public func setPIPPlayer(centerPoint point: CoreFoundation.CGPoint)
  public func resetSplitRender()
  public func setSplitRender()
}
extension UnifiedVideoEditorSDK.BanubaSdkManager {
  @objc public class BanubaVisualClipVideo : ObjectiveC.NSObject {
    final public let path: Swift.String
    final public let startPosition: Swift.Float
    final public let duration: Swift.Float
    @objc public init(path: Swift.String, startPosition: Swift.Float, duration: Swift.Float)
    @objc deinit
  }
  @objc public static func createAutoCutVideos(with musicDbPath: Swift.String, visualEffects: [Swift.String], transitionEffects: [Swift.String], videos: [UnifiedVideoEditorSDK.BanubaSdkManager.BanubaVisualClipVideo], numFrames: Swift.Int32, resultSize: Swift.Int32, cancellation: @escaping ((Swift.Double) -> Swift.Bool)) -> [Swift.String]?
}
extension UnifiedVideoEditorSDK.BanubaSdkManager : UnifiedVideoEditorSDK.AppStateObserverDelegate {
  @objc dynamic public func applicationWillResignActive(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc dynamic public func applicationDidBecomeActive(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc dynamic public func applicationDidEnterBackgroundNotification(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc dynamic public func applicationWillEnterForeground(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
  @objc dynamic public func applicationWillTerminateNotification(_ appStateObserver: UnifiedVideoEditorSDK.AppStateObserver)
}
extension ObjectiveC.NSObject {
  public func performSync(onThread: Foundation.Thread?, block: @escaping @convention(block) () -> Swift.Void)
  public func performAsync(onThread: Foundation.Thread?, block: @escaping @convention(block) () -> Swift.Void)
}
public protocol CountdownTimerViewFactory {
  func makeCountdownTimerView() -> any UnifiedVideoEditorSDK.CountdownTimerAnimatableView
}
public protocol ImageSlideshow {
  @discardableResult
  func exportSlideshowImages(_ images: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol], to fileUrl: Foundation.URL?, videoResolution: UnifiedVideoEditorSDK.VideoResolution, completion: ((Foundation.URL, (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler
}
extension UnifiedVideoEditorSDK.ImageSlideshow {
  public func exportSlideshowImages(_ images: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol], to fileUrl: Foundation.URL? = nil, videoResolution: UnifiedVideoEditorSDK.VideoResolution, completion: ((Foundation.URL, (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler
}
@objc public enum RenderContentMode : Swift.Int {
  case resizeAspect
  case resizeAspectFill
  case resize
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol SnapshotProvider {
  func makeSnapshotWithSettings(_ settings: UnifiedVideoEditorSDK.VEOutputSettings, watermarkPixelBuffer: CoreVideo.CVPixelBuffer?) -> UIKit.UIImage?
}
public protocol PixelBufferProvider {
  func makeVideoPixelBuffer() -> CoreVideo.CVPixelBuffer?
}
@_hasMissingDesignatedInitializers @objc public class RenderTarget : UnifiedVideoEditorSDK.PIPShapeDrawer, UnifiedVideoEditorSDK.SnapshotProvider, UnifiedVideoEditorSDK.PixelBufferProvider {
  public var renderBehaviour: UnifiedVideoEditorSDK.RenderBehavior
  public var pipPlayer: UnifiedVideoEditorSDK.PIPPlayer?
  public var pipPlayerRelativeLeftTopPoint: CoreFoundation.CGPoint
  public var splitRenderOffset: CoreFoundation.CGPoint
  public var playerRect: CoreFoundation.CGRect {
    get
  }
  public var pipRect: CoreFoundation.CGRect? {
    get
  }
  public var shouldZoomPipImage: Swift.Bool
  public func setSplitRender(rect: CoreFoundation.CGRect, offset: CoreFoundation.CGPoint)
  @objc deinit
  @objc public func makeVideoPixelBuffer() -> CoreVideo.CVPixelBuffer?
  @objc public func makeSnapshotWithSettings(_ settings: UnifiedVideoEditorSDK.VEOutputSettings, watermarkPixelBuffer: CoreVideo.CVPixelBuffer?) -> UIKit.UIImage?
  @objc public func activate()
  @objc public func present(_ willPresentHandler: ((CoreVideo.CVPixelBuffer?) -> Swift.Void)?)
}
public enum OutputServiceError : Swift.Error {
  case notEnoughSpace
  public static func == (a: UnifiedVideoEditorSDK.OutputServiceError, b: UnifiedVideoEditorSDK.OutputServiceError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol VideoSequenceServicing {
  var videoSequences: [UnifiedVideoEditorSDK.VideoSequence] { get }
  var currentSequence: UnifiedVideoEditorSDK.VideoSequence? { get }
  func setupCurrentSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence?)
  @discardableResult
  func startNewSequence() -> UnifiedVideoEditorSDK.VideoSequence
  func cancelCurrentSequence()
  func duplicateSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> UnifiedVideoEditorSDK.VideoSequence
  func replaceSequence(_ videoSequenceToReplace: UnifiedVideoEditorSDK.VideoSequence, withSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  @discardableResult
  func removeSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> Swift.Bool
  func removeAllSequences()
}
public class VideoSequenceService {
  public var videoSequences: [UnifiedVideoEditorSDK.VideoSequence] {
    get
  }
  public var currentSequence: UnifiedVideoEditorSDK.VideoSequence?
  public init()
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoSequenceService : UnifiedVideoEditorSDK.VideoSequenceServicing {
  public func setupCurrentSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence?)
  @discardableResult
  public func startNewSequence() -> UnifiedVideoEditorSDK.VideoSequence
  public func cancelCurrentSequence()
  @discardableResult
  public func removeSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> Swift.Bool
  @discardableResult
  public func duplicateSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> UnifiedVideoEditorSDK.VideoSequence
  public func replaceSequence(_ videoSequenceToReplace: UnifiedVideoEditorSDK.VideoSequence, withSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  public func removeAllSequences()
}
public struct ColorPair : Swift.Equatable {
  public let background: UIKit.UIColor
  public let foreground: UIKit.UIColor
  public init(background: UIKit.UIColor, foreground: UIKit.UIColor)
  public static func == (lhs: UnifiedVideoEditorSDK.ColorPair, rhs: UnifiedVideoEditorSDK.ColorPair) -> Swift.Bool
}
public struct VideoTextColorPair : Swift.Equatable {
  public let foreground: UnifiedVideoEditorSDK.ColorPair
  public let background: UnifiedVideoEditorSDK.ColorPair
  public init(colors: (UIKit.UIColor, UIKit.UIColor, UIKit.UIColor, UIKit.UIColor))
  public init(foreground: UnifiedVideoEditorSDK.ColorPair, background: UnifiedVideoEditorSDK.ColorPair)
  public static func == (lhs: UnifiedVideoEditorSDK.VideoTextColorPair, rhs: UnifiedVideoEditorSDK.VideoTextColorPair) -> Swift.Bool
}
public struct VideoTextFont : Swift.Equatable {
  public var font: UIKit.UIFont?
  public var name: Swift.String
  public init(font: UIKit.UIFont?, name: Swift.String)
  public static func == (a: UnifiedVideoEditorSDK.VideoTextFont, b: UnifiedVideoEditorSDK.VideoTextFont) -> Swift.Bool
}
public protocol ExternalSDKAnalyticsEventsListener : AnyObject {
  func onVideoEditorSDKEvent(_ event: Swift.String)
}
public enum SDKEventScreen : Swift.String, Swift.Codable {
  case camera
  case editor
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SDKEventName : Swift.String {
  case maskDownloaded
  case maskApplied
  case maskCancelled
  case exportVideo
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SDKEffectEvent : Swift.Codable {
  public let name: Swift.String
  public let data: UnifiedVideoEditorSDK.SDKEventEffectData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SDKEventEffectData : Swift.Codable, Swift.Hashable {
  public let name: Swift.String
  public let screen: UnifiedVideoEditorSDK.SDKEventScreen?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UnifiedVideoEditorSDK.SDKEventEffectData, b: UnifiedVideoEditorSDK.SDKEventEffectData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct SDKExportEvent : Swift.Codable {
  public let name: Swift.String
  public let data: UnifiedVideoEditorSDK.SDKExportEvent.SDKExportEventData
  public struct SDKExportEventData : Swift.Codable {
    public let masks: [Swift.String]
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RevokedTokenError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
  public init()
}
@_inheritsConvenienceInitializers @objc public class BanubaCameraModule : ObjectiveC.NSObject {
  @objc public var isPIPSessionAlreadySetup: Swift.Bool
  @objc public var isPIPSession: Swift.Bool
  @objc public var pipVideoURL: Foundation.URL?
  @objc public var pipSwitchSetting: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting?
  @objc public var pipPlayerSetting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting?
  @objc public var pipCameraSetting: UnifiedVideoEditorSDK.PIPCameraLayoutSetting?
  @objc public var isCameraEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  public static var arCloudPath: Swift.String?
  @objc public var isLoaded: Swift.Bool
  @objc public var allowProcessing: Swift.Bool
  @objc public var inputDelegate: (any UnifiedVideoEditorSDK.SDKInputServicingDelegate)?
  public static var videoSize: CoreFoundation.CGSize! {
    get
  }
  public static var videoPreset: AVFoundation.AVCaptureSession.Preset! {
    get
  }
  @objc public static func initialize(sdkToken: Swift.String, videoSize: CoreFoundation.CGSize, videoPreset: AVFoundation.AVCaptureSession.Preset, useHEVCCodecIfPossibleForRecorder: Swift.Bool, arCloudPath: Swift.String? = nil)
  @objc required override dynamic public init()
  public enum MethodInJson : Swift.String {
    case changeAxis
    case runScan
    case resetScan
    case onStop
    case onTouchesBegan
    case onFinish
    case setBgTexture
    case setBgVideo
    case playVideo
    case pauseVideo
    case rotateBg
    case playVideoRange
    case stopVideo
    case stopMusic
    case hideInteractive
    case updatePreview
    case enableBlur
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : UnifiedVideoEditorSDK.CameraModule {
  @objc dynamic public var renderQueue: Dispatch.DispatchQueue? {
    @objc get
  }
  public var pipRenderSize: CoreFoundation.CGSize {
    get
  }
  @objc dynamic public var autoStart: Swift.Bool {
    @objc get
    @objc set
  }
  @objc dynamic public var isPIPPlayerReadyToProvideData: Swift.Bool {
    @objc get
  }
  @objc dynamic public func addFPSListener(_ listener: ((_ fpsInfo: Foundation.NSAttributedString) -> Swift.Void)?)
  @objc dynamic public func setMaxFaces(facesCount: Swift.Int32)
  @objc dynamic public func setup()
  @objc dynamic public func destroy()
  @objc dynamic public func takeSnapshot(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc dynamic public func start(completion: @escaping () -> Swift.Void)
  @objc dynamic public func stop(completion: (() -> Swift.Void)?)
  @objc dynamic public func setRenderTarget(view: UIKit.UIView)
  @objc dynamic public func removeRenderTarget()
  @objc dynamic public func getRendererView() -> UIKit.UIView
  @objc dynamic public func startRenderLoop()
  @objc dynamic public func stopRenderLoop()
}
extension UnifiedVideoEditorSDK.BanubaCameraModule {
  @objc dynamic public func seekPIPPlayer(to time: Foundation.TimeInterval)
  @objc dynamic public func startPIPPlayer()
  @objc dynamic public func stopPIPPlayer()
  @objc dynamic public func setPIPPlayerVolume(_ volume: Swift.Float)
  @objc dynamic public func setupPIPSession(withVideoURL url: Foundation.URL, playerSetting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, cameraSetting: UnifiedVideoEditorSDK.PIPCameraLayoutSetting, switchSetting: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting)
  @objc dynamic public func startPIPSessionIfNeeded(withSetting setting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, completion: (() -> Swift.Void)?)
  @objc dynamic public func applyPIPCameraSettingIfNeeded(_ setting: UnifiedVideoEditorSDK.PIPCameraLayoutSetting, restoreSession: Swift.Bool)
  @objc dynamic public func applyPIPPlayerSettingIfNeeded(_ setting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, restoreSession: Swift.Bool)
  @objc dynamic public func applyPIPSwitchSettingIfNeeded(_ setting: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting, restoreSession: Swift.Bool)
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : UnifiedVideoEditorSDK.SDKInputServicing {
  @objc dynamic public var zoomFactor: Swift.Float {
    @objc get
  }
  @objc dynamic public var isFrontCamera: Swift.Bool {
    @objc get
  }
  @objc dynamic public var currentCameraSessionType: UnifiedVideoEditorSDK.CameraModuleSessionType {
    @objc get
  }
  @objc dynamic public func focus(at point: CoreFoundation.CGPoint, useContinuousDetection: Swift.Bool)
  @objc dynamic public func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
  @objc dynamic public func toggleCamera(completion: @escaping () -> ())
  @objc dynamic public func startCamera()
  @objc dynamic public func startAudioCapturing()
  @objc dynamic public func stopAudioCapturing()
  @objc dynamic public func setCameraSessionType(_ type: UnifiedVideoEditorSDK.CameraModuleSessionType)
  @objc dynamic public func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  @objc dynamic public func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : UnifiedVideoEditorSDK.SDKOutputServicing {
  @objc dynamic public var isRecording: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isEnoughDiskSpaceForRecording: Swift.Bool {
    @objc get
  }
  @objc dynamic public func startVideoCapturing(fileURL: Foundation.URL?, startTimeForVideoTexture: Swift.Double, externalAudioConfiguration: UnifiedVideoEditorSDK.ExternalAudioConfiguration?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, didStart: (() -> Swift.Void)?, shouldSkipFrame: (() -> Swift.Bool)?, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue], boundaryHandler: @escaping (CoreMedia.CMTime) -> Swift.Void, totalDuration: Foundation.TimeInterval, itemDuration: Foundation.TimeInterval, completion: @escaping (Swift.Bool, (any Swift.Error)?) -> Swift.Void)
  @objc dynamic public func stopVideoCapturing(cancel: Swift.Bool)
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : UnifiedVideoEditorSDK.SDKEffectsServicing {
  @objc dynamic public func enableBlur()
  @objc dynamic public var isMaskLoaded: Swift.Bool {
    @objc get
  }
  @objc dynamic public func loadMask(name: Swift.String, synchronous: Swift.Bool)
  @objc dynamic public func unloadMask()
  @objc dynamic public func removeAllFilters()
  @objc dynamic public func applyFilter(_ filter: any UnifiedVideoEditorSDK.RenderEffect)
  @objc dynamic public func removeFilter(_ filter: any UnifiedVideoEditorSDK.RenderEffect)
  @objc dynamic public func setEffectSubtypeModificationsEventListener(_ listener: any UnifiedVideoEditorSDK.EffectSubtypeModificationsEventListener)
  @objc dynamic public func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
  @objc dynamic public func effectDidBeginApplying()
  @objc dynamic public func effectDidEndApplying()
  @objc dynamic public func effectDidResetApplying()
  @objc dynamic public func effectDidChangeState()
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : UnifiedVideoEditorSDK.SDKEffectsTextureServicing {
  @objc dynamic public func setupDefaultImageTexture()
  @objc dynamic public func effectAddImageTexture(image: UIKit.UIImage, backgroundColor: UIKit.UIColor)
  @objc dynamic public func effectAddVideoTexture(asset: AVFoundation.AVURLAsset, backgroundColor: UIKit.UIColor)
  @objc dynamic public func stopVideoTextureIfNeeded()
  @objc dynamic public func effectReloadTexturePreview(startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, itemDuration: Foundation.TimeInterval)
  @objc dynamic public func unloadEffectTexture()
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : UnifiedVideoEditorSDK.SDKBeautyEffectManaging {
  @objc dynamic public var isBeautificationEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc dynamic public var supportsIntensity: Swift.Bool {
    @objc get
  }
  @objc dynamic public var intensity: Swift.Double {
    @objc get
    @objc set
  }
  @objc dynamic public func toggleBeautification() -> Swift.Bool
  @objc dynamic public func resetIntensity()
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : UnifiedVideoEditorSDK.BanubaSdkManagerDelegate {
  @objc dynamic public func willOutput(pixelBuffer: CoreVideo.CVPixelBuffer)
  @objc dynamic public func willPresent(changedPixelBuffer: CoreVideo.CVPixelBuffer?)
  @objc dynamic public func didReceiveFPSInfo(_ cameraFPS: Swift.Float, recognizerFPS: Swift.Float, renderFPS: Swift.Float)
}
extension UnifiedVideoEditorSDK.BanubaCameraModule : BNBSdkCore.BNBEffectEventListener {
  @objc dynamic public func onEffectEvent(_ name: Swift.String, params: [Swift.String : Swift.String])
}
public enum BackgroundViewStyle : Swift.Equatable {
  case blur(style: UIKit.UIBlurEffect.Style)
  case dim
  case none
  public static func == (a: UnifiedVideoEditorSDK.BackgroundViewStyle, b: UnifiedVideoEditorSDK.BackgroundViewStyle) -> Swift.Bool
}
@objc public class TextConfiguration : ObjectiveC.NSObject {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var alignment: UIKit.NSTextAlignment
  public var text: Swift.String?
  public var shadow: UnifiedVideoEditorSDK.TextShadowConfiguration?
  public var lineBreakMode: UIKit.NSLineBreakMode
  public init(kern: Swift.Double = 0, font: UIKit.UIFont, color: UIKit.UIColor, alignment: UIKit.NSTextAlignment = .center, text: Swift.String? = nil, shadow: UnifiedVideoEditorSDK.TextShadowConfiguration? = nil, lineBreakMode: UIKit.NSLineBreakMode = .byWordWrapping)
  @objc override dynamic public func copy() -> Any
  @objc deinit
}
public struct TextShadowConfiguration {
  public var shadowColor: UIKit.UIColor
  public var shadowOffset: CoreFoundation.CGSize
  public var shadowBlurRadius: CoreFoundation.CGFloat
  public init(shadowColor: UIKit.UIColor = UIColor.black.withAlphaComponent(0.4), shadowOffset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), shadowBlurRadius: CoreFoundation.CGFloat = 2.0)
  public func shadow() -> UIKit.NSShadow
}
extension Swift.Error {
  public var errorMessage: Swift.String {
    get
  }
}
public enum EffectSpeed : Swift.Float {
  case normal
  case slowmo
  case rapid
  public init?(rawValue: Swift.Float)
  public typealias RawValue = Swift.Float
  public var rawValue: Swift.Float {
    get
  }
}
@_hasMissingDesignatedInitializers public class EditorCompositionFactory {
  public static func createEditorEffect(start: CoreMedia.CMTime, end: CoreMedia.CMTime, model: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, additionalParameters: [Swift.String : Any]?) -> any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol
  public static func createEditorEffect(start: CoreMedia.CMTime, end: CoreMedia.CMTime, type: UnifiedVideoEditorSDK.EditorEffectType, renderer: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)?, path: Swift.String, speed: UnifiedVideoEditorSDK.EffectSpeed, transition: UnifiedVideoEditorSDK.TransitionType = .normal, uuid: Swift.String, id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, additionalParameters: [Swift.String : Any]?) -> any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol
  public static func zeroTimeEffect() -> any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol
  @objc deinit
}
public protocol EditorCompositionEffectProtocol : AnyObject {
  var additionalParameters: [Swift.String : Any]? { get }
  var startTime: CoreMedia.CMTime { get }
  var endTime: CoreMedia.CMTime { get }
  var id: Swift.UInt { get }
  var tokenId: Swift.String { get set }
  var path: Swift.String { get }
}
public protocol EditorCompositionEditableEffectProtocol : Foundation.NSCopying, UnifiedVideoEditorSDK.EditorCompositionEffectProtocol {
  var startTime: CoreMedia.CMTime { get set }
  var endTime: CoreMedia.CMTime { get set }
  var filterType: UnifiedVideoEditorSDK.EditorEffectType { get }
  var speed: UnifiedVideoEditorSDK.EffectSpeed { get }
  var transitionType: UnifiedVideoEditorSDK.TransitionType { get }
  var uuid: Swift.String { get }
  var rendererClass: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)? { get }
  var rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)? { get }
  var additionalParameters: [Swift.String : Any]? { get }
  func isInTime(_ time: CoreMedia.CMTime) -> Swift.Bool
  func isEqual(to: any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol) -> Swift.Bool
}
public class VEPlayback {
  public init?(videoEditorService: UnifiedVideoEditorSDK.VideoEditorService)
  public func getPlayer(forExternalAsset asset: AVFoundation.AVAsset? = nil, delegate: (any UnifiedVideoEditorSDK.VideoEditorPlayerDelegate)?) -> any UnifiedVideoEditorSDK.VideoEditorPlayable
  public func getPlayableView(thumbnailSettings: UnifiedVideoEditorSDK.VEPlayback.ThumbnailSettings? = nil, forExternalAsset asset: AVFoundation.AVAsset? = nil, delegate: (any UnifiedVideoEditorSDK.VideoEditorPlayerDelegate)?) -> any UnifiedVideoEditorSDK.VideoPlayableView
  public struct ThumbnailSettings {
    public let playerTime: CoreMedia.CMTime
    public init(playerTime: CoreMedia.CMTime)
  }
  @objc deinit
}
public enum AspectRatio : Swift.UInt8, Swift.Codable {
  case original
  case aspect16x9
  case aspect9x16
  case aspect4x3
  case aspect4x5
  public func getVideoAspectRatio(withVideoSize videoSize: CoreFoundation.CGSize? = nil) -> CoreFoundation.CGFloat
  public init(videoAspectRatio: CoreFoundation.CGFloat)
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct CameraSessionMetadata : Swift.Codable {
  public var isFrontCamera: Swift.Bool
  public init(isFrontCamera: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VideoEditorTrimMetadata : Swift.Codable {
  public var sequenceItemsMetadata: [UnifiedVideoEditorSDK.VideoSequenceItemMetadata]
  public init(sequenceItemsMetadata: [UnifiedVideoEditorSDK.VideoSequenceItemMetadata])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VideoSequenceItemMetadata : Swift.Codable {
  public var videoName: Swift.String
  public var order: Swift.Int
  public var imageData: Foundation.Data?
  public var trimTimeRange: UnifiedVideoEditorSDK.TrimTimeRangeMetadata
  public let isGalleryAsset: Swift.Bool
  public let isSlideShow: Swift.Bool
  public let isPIP: Swift.Bool
  public var transition: UnifiedVideoEditorSDK.TransitionEffectMetadata
  public var aspectRatio: UnifiedVideoEditorSDK.AspectRatio
  public init(videoName: Swift.String, order: Swift.Int, imageData: Foundation.Data? = nil, trimTimeRange: UnifiedVideoEditorSDK.TrimTimeRangeMetadata, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool = false, transition: UnifiedVideoEditorSDK.TransitionEffectMetadata, aspectRatio: UnifiedVideoEditorSDK.AspectRatio)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct TransitionEffectMetadata : Swift.Codable {
  public struct Defaults {
    public static let transitionDuration: Swift.Double
    public static let timescale: CoreMedia.CMTimeScale
  }
  public let type: UnifiedVideoEditorSDK.TransitionType
  public init(type: UnifiedVideoEditorSDK.TransitionType)
  public static func startTime(fromTime: CoreMedia.CMTime) -> CoreMedia.CMTime
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TrimTimeRangeMetadata : Swift.Codable {
  public let start: UnifiedVideoEditorSDK.TimeMetadata
  public let duration: UnifiedVideoEditorSDK.TimeMetadata
  public func getCMTimeRange() -> CoreMedia.CMTimeRange
  public init(start: UnifiedVideoEditorSDK.TimeMetadata, duration: UnifiedVideoEditorSDK.TimeMetadata)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MusicEditorMetadata : Swift.Codable {
  public var tracks: [UnifiedVideoEditorSDK.MusicEditorTrack]
  public var pipVolume: Swift.Float?
  public var videoVolume: Swift.Float
  public init(tracks: [UnifiedVideoEditorSDK.MusicEditorTrack], pipVolume: Swift.Float?, videoVolume: Swift.Float)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct MusicEditorTrack : Swift.Codable {
  public var url: Foundation.URL
  public var coverURL: Foundation.URL?
  public var originalURL: Foundation.URL
  public var title: Swift.String
  public var additionalTitle: Swift.String?
  public var id: Swift.Int32
  public let uuid: Foundation.UUID
  public var volume: Swift.Float
  public var position: Swift.Int
  public var timeScale: Foundation.TimeInterval
  public var compositionStart: Foundation.TimeInterval
  public var timeRangeStart: Foundation.TimeInterval
  public var timeRangeEnd: Foundation.TimeInterval
  public var isAudioRecord: Swift.Bool
  public var isEditable: Swift.Bool
  public var applyedFilterId: Swift.Int?
  public var isCameraTrack: Swift.Bool
  public init(url: Foundation.URL, coverURL: Foundation.URL?, originalURL: Foundation.URL, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, id: Swift.Int32, volume: Swift.Float, position: Swift.Int, timeScale: Foundation.TimeInterval, compositionStart: Foundation.TimeInterval, timeRangeStart: Foundation.TimeInterval, timeRangeEnd: Foundation.TimeInterval, isAudioRecord: Swift.Bool, isEditable: Swift.Bool, applyedFilterId: Swift.Int? = nil, isCameraTrack: Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct VideoEditorMetadata : Swift.Codable {
  public var effectsOnVideoMetadata: [UnifiedVideoEditorSDK.EffectOnVideoMetadata]?
  public var colorOnVideoMetadata: UnifiedVideoEditorSDK.ColorOnVideoMetadata?
  public var textOnVideoMetadata: [UnifiedVideoEditorSDK.TextOnVideoMetadata]?
  public var gifOnVideoMetadata: [UnifiedVideoEditorSDK.GIFOnVideoMetadata]?
  public var blurOnVideoMetadata: [UnifiedVideoEditorSDK.BlurOnVideoMetadata]?
  public var filtersOnVideoMetadata: [UnifiedVideoEditorSDK.FilterOnVideoMetadata]?
  public var analyticsMetadataJSON: Swift.String?
  public static var empty: UnifiedVideoEditorSDK.VideoEditorMetadata {
    get
  }
  public func adjustBlurEffectMetadata() -> UnifiedVideoEditorSDK.BlurList?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ColorOnVideoMetadata : Swift.Codable {
  public let title: Swift.String
  public init(title: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct FilterOnVideoMetadata : Swift.Codable {
  public let title: Swift.String
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public init(title: Swift.String, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CaptionsMetadata : Swift.Codable {
  public let existingCaptionIds: [Swift.String]
  public let styleParams: UnifiedVideoEditorSDK.TextParams
  public let styleTextColorDestinationId: Swift.Int
  public let languageCode: Swift.String?
  public let predefinedStyleId: Swift.Int?
  public init(existingCaptionIds: [Swift.String], styleParams: UnifiedVideoEditorSDK.TextParams, styleTextColorDestinationId: Swift.Int, languageCode: Swift.String?, predefinedStyleId: Swift.Int?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EffectOnVideoMetadata : Swift.Codable {
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let effectId: Swift.UInt
  public let tokenId: Swift.String
  public init(startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, effectId: Swift.UInt, tokenId: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TextOnVideoMetadata : Swift.Codable {
  public let id: Swift.String
  public let textParams: UnifiedVideoEditorSDK.TextParams
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams
  public let order: Swift.Int
  public let textColorDestinationId: Swift.Int
  public let linePositionOrderNumber: Swift.Int?
  public let predefinedStyleId: Swift.Int?
  public init(id: Swift.String, textParams: UnifiedVideoEditorSDK.TextParams, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams, order: Swift.Int, textColorDestinationId: Swift.Int, linePositionOrderNumber: Swift.Int?, predefinedStyleId: Swift.Int?)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum VideoSequenceEditingStep : Swift.Int, Swift.Codable {
  case camera
  case trimmer
  case editor
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct VideoMetadata : Swift.Codable {
  public var name: Swift.String
  public var isDrafted: Swift.Bool
  public var aspect: UnifiedVideoEditorSDK.AspectRatio
  public var modificationDate: Foundation.Date
  public var maxVideoDuration: Foundation.TimeInterval?
  public let isSlideShow: Swift.Bool
  public var parentSequenceId: Swift.String?
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack?
  public var editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep
  public init(isSlideShow: Swift.Bool = false, isDrafted: Swift.Bool = false, name: Swift.String, maxVideoDuration: Foundation.TimeInterval?, sequenceParentName: Swift.String? = nil, editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep = .camera, musicTrack: UnifiedVideoEditorSDK.MediaTrack? = nil, aspect: UnifiedVideoEditorSDK.AspectRatio, modificationDate: Foundation.Date = Date())
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct BlurOnVideoMetadata : Swift.Codable {
  public let id: Swift.String
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let blurCoordinateParams: UnifiedVideoEditorSDK.BlurCoordinateParams
  public let coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams
  public let blurFigure: UnifiedVideoEditorSDK.DrawableFigure
  public let titleIndex: Swift.Int
  public let order: Swift.Int
  public init(id: Swift.String, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, blurCoordinateParams: UnifiedVideoEditorSDK.BlurCoordinateParams, coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams, blurFigure: UnifiedVideoEditorSDK.DrawableFigure, titleIndex: Swift.Int, order: Swift.Int)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct GIFOnVideoMetadata : Swift.Codable {
  public let id: Swift.String
  public let imageDataName: Swift.String
  public let imageData: Foundation.Data?
  public let startTime: UnifiedVideoEditorSDK.TimeMetadata
  public let endTime: UnifiedVideoEditorSDK.TimeMetadata
  public let coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams
  public let order: Swift.Int
  public init(id: Swift.String, imageDataName: Swift.String, startTime: UnifiedVideoEditorSDK.TimeMetadata, endTime: UnifiedVideoEditorSDK.TimeMetadata, coordinatesParams: UnifiedVideoEditorSDK.CoordinatesParams, order: Swift.Int)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct CoordinatesParams : Swift.Codable {
  public let transform: CoreFoundation.CGAffineTransform
  public let frame: CoreFoundation.CGRect
  public init(transform: CoreFoundation.CGAffineTransform, frame: CoreFoundation.CGRect)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ColorParams : Swift.Codable {
  public let red: CoreFoundation.CGFloat?
  public let green: CoreFoundation.CGFloat?
  public let blue: CoreFoundation.CGFloat?
  public let alpha: CoreFoundation.CGFloat?
  public init(red: CoreFoundation.CGFloat?, green: CoreFoundation.CGFloat?, blue: CoreFoundation.CGFloat?, alpha: CoreFoundation.CGFloat?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TextParams : Swift.Codable {
  public init(text: Swift.String?, link: Swift.String?, textFont: Swift.String?, fontName: Swift.String?, fontSize: CoreFoundation.CGFloat?, textAlignment: Swift.Int?, textColor: UnifiedVideoEditorSDK.ColorParams?, backgroundColor: UnifiedVideoEditorSDK.ColorParams?)
  public let text: Swift.String?
  public let link: Swift.String?
  public let textFont: Swift.String?
  public let fontName: Swift.String?
  public let fontSize: CoreFoundation.CGFloat?
  public let textAlignment: Swift.Int?
  public let textColor: UnifiedVideoEditorSDK.ColorParams?
  public let backgroundColor: UnifiedVideoEditorSDK.ColorParams?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct VideoCoverMetadata : Swift.Codable {
  public var image: UIKit.UIImage? {
    get
  }
  public let imageData: Foundation.Data?
  public let coverIndent: UnifiedVideoEditorSDK.TimeMetadata
  public init(imageData: Foundation.Data?, coverIndent: UnifiedVideoEditorSDK.TimeMetadata)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TimeMetadata : Swift.Codable {
  public let seconds: Swift.Double
  public let timescale: CoreMedia.CMTimeScale
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension UnifiedVideoEditorSDK.TimeMetadata {
  public init(cmTime: CoreMedia.CMTime)
  public func getCMTime() -> CoreMedia.CMTime
}
public struct BlurList : Swift.Codable {
  public let blurMask: [UnifiedVideoEditorSDK.BlurMask]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct BlurMask : Swift.Codable {
  public let id: Swift.String
  public let type: Swift.String
  public let startTime: Swift.Int, endTime: Swift.Int
  public let params: UnifiedVideoEditorSDK.Params
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Params : Swift.Codable {
  public let x: Swift.Float
  public let y: Swift.Float
  public let radius: Swift.Float
  public let width: Swift.Float
  public let height: Swift.Float
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension UnifiedVideoEditorSDK.EffectOnVideoMetadata {
  public init(from editorCompositionEffect: any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol)
}
public class VideoEditorAssetTrackInfo : Swift.Hashable, Swift.Equatable {
  final public let uuidString: Swift.String
  public var url: Foundation.URL {
    get
  }
  public var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>
  final public let videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var videoCurentSize: CoreFoundation.CGFloat?
  public var thumbnail: UIKit.UIImage?
  public var thumbnails: [UIKit.UIImage]
  public var trimTimeRange: CoreMedia.CMTimeRange
  public var rotation: UnifiedVideoEditorSDK.AssetRotation {
    get
    set
  }
  public var videoName: Swift.String {
    get
  }
  public var isGalleryAsset: Swift.Bool
  public var isSlideShow: Swift.Bool
  public var composition: AVFoundation.AVComposition! {
    get
  }
  public var instructions: [any AVFoundation.AVVideoCompositionInstructionProtocol]? {
    get
  }
  public var error: (any Swift.Error)? {
    get
  }
  public var timeRange: CoreMedia.CMTimeRange {
    get
  }
  public var urlAsset: AVFoundation.AVAsset {
    get
  }
  public var timeRangeInGlobal: CoreMedia.CMTimeRange
  final public let originalAssetResolution: CoreFoundation.CGSize?
  public var transitionEffectType: UnifiedVideoEditorSDK.TransitionType
  public init(uuidString: Swift.String, url: Foundation.URL, rotation: UnifiedVideoEditorSDK.AssetRotation, thumbnail: UIKit.UIImage?, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>, videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, transitionEffectType: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize?)
  public func copy() -> UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo
  public func replaceAssetUrl(_ url: Foundation.URL)
  public func rotate(clockwise: Swift.Bool)
  public func getTimeRangeWithSpeedExtension() -> CoreMedia.CMTimeRange
  public func updatePreview()
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo {
  public static func == (lhs: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo, rhs: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
extension UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo {
  public func isTimeInGlobalTimeRange(_ time: CoreMedia.CMTime) -> Swift.Bool
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) public class EffectPlayerView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc @_Concurrency.MainActor(unsafe) public func onLongTapGesture(gesture: UIKit.UITapGestureRecognizer)
  @objc @_Concurrency.MainActor(unsafe) public func onDoubleTapGesture(gesture: UIKit.UITapGestureRecognizer)
  @objc @_Concurrency.MainActor(unsafe) public func onScaleGesture(gesture: UIKit.UIPinchGestureRecognizer)
  @objc @_Concurrency.MainActor(unsafe) public func onRotationGesture(gesture: UIKit.UIRotationGestureRecognizer)
  @objc @_Concurrency.MainActor(unsafe) public func onSwipeGesture(gesture: UIKit.UISwipeGestureRecognizer)
  @objc deinit
}
@objc public protocol TimeLineDataSourceDelegate {
  @objc optional func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource)
}
@objc public protocol TimeLineDataSource {
  @objc var delegate: (any UnifiedVideoEditorSDK.TimeLineDataSourceDelegate)? { get set }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var duration: CoreMedia.CMTime { get }
  @objc var thumbnails: [UIKit.UIImage] { get }
  @objc var isAllThumbnailsFetched: Swift.Bool { get }
  @objc var thumbnailsCount: Swift.Int { get }
  @objc var thumbnailHeight: CoreFoundation.CGFloat { get }
  @objc func loadPreview(completion: @escaping (UIKit.UIImage?) -> Swift.Void, at second: Swift.Double)
  @objc func getImage(at index: Swift.Int) -> UIKit.UIImage?
  @objc func loadTimelineThumbs(completion: (() -> Swift.Void)?)
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIButton {
  @discardableResult
  public func setImage(with source: UnifiedVideoEditorSDK.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any UnifiedVideoEditorSDK.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with source: UnifiedVideoEditorSDK.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, parsedOptions: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  public func cancelImageDownloadTask()
  @discardableResult
  public func setBackgroundImage(with source: UnifiedVideoEditorSDK.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setBackgroundImage(with resource: (any UnifiedVideoEditorSDK.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  public func cancelBackgroundImageDownloadTask()
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIButton {
  public func taskIdentifier(for state: UIKit.UIControl.State) -> UnifiedVideoEditorSDK.Source.Identifier.Value?
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIButton {
  public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> UnifiedVideoEditorSDK.Source.Identifier.Value?
}
public protocol ProgressViewControllerFactory {
  func makeProgressViewController() -> any UnifiedVideoEditorSDK.BanubaProgressViewController
}
@_hasMissingDesignatedInitializers public class EditorEffectsFilter {
  public static func filterAddedEffects(effects: [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
public struct CollectionInfoHeaderConfiguration {
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var hideButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol
  public var height: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var underlinedTextColor: UIKit.UIColor
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, hideButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol, height: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, underlinedTextColor: UIKit.UIColor)
}
@objc public protocol GalleryViewControllerFactory : ObjectiveC.NSObjectProtocol {
  @objc func makeGalleryViewController(withConfiguration configuration: UnifiedVideoEditorSDK.GalleryConfiguration, albumsConfiguration: UnifiedVideoEditorSDK.AlbumsConfiguration, selectionBehaviour: UnifiedVideoEditorSDK.GallerySelectionBehaviour) -> UnifiedVideoEditorSDK.GalleryViewController
}
public enum CaptionsLanguage : Swift.String, Swift.CaseIterable {
  case english
  case mandarin
  case portuguese
  case spanish
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.CaptionsLanguage]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.CaptionsLanguage] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class ZipArchive : ObjectiveC.NSObject {
  public static func zip(to destinationUrl: Foundation.URL, folderUrl: Foundation.URL) -> Swift.Bool
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) throws
  #if compiler(>=5.3) && $AsyncAwait
  @discardableResult
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) async throws -> Swift.String
  #endif
  @objc override dynamic public init()
  @objc deinit
}
@objc public class VideoImagesComposition : ObjectiveC.NSObject {
  public init(sequence: UnifiedVideoEditorSDK.VideoEditorImagesSequence, videoResolution: UnifiedVideoEditorSDK.VideoResolution)
  public func exportVideo(to file: Foundation.URL, quality: Swift.String, completion: (((any Swift.Error)?) -> Swift.Void)?)
  public func cancelExport()
  @objc deinit
}
public enum BNBInformerEventType {
  case `init`(any UnifiedVideoEditorSDK.BasicEventOptions)
  case present(any UnifiedVideoEditorSDK.BasicEventOptions)
  case export(any UnifiedVideoEditorSDK.BasicEventOptions)
}
public protocol BasicEventOptions : Swift.Decodable, Swift.Encodable {
  var sdkVersion: Swift.String { get }
  var iOSVersion: Swift.String { get }
  func adjustStringJson() -> Swift.String?
}
extension UnifiedVideoEditorSDK.BasicEventOptions {
  public func adjustStringJson() -> Swift.String?
}
public struct VideoSources : Swift.Codable {
  public let camera: Swift.Int
  public let gallery: Swift.Int
  public let pip: Swift.Int
  public let slideshow: Swift.Int
  public let audio: Swift.Int
  public init(camera: Swift.Int, gallery: Swift.Int, pip: Swift.Int, slideshow: Swift.Int, audio: Swift.Int)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExportEventOptions : UnifiedVideoEditorSDK.BasicEventOptions {
  public let exportSuccess: Swift.Bool
  public let videoResolutions: [Swift.String]
  public let postProcessingEffects: UnifiedVideoEditorSDK.PostProcessingOptions?
  public let cameraEffects: [Swift.String]?
  public let sdkVersion: Swift.String
  public let iOSVersion: Swift.String
  public let exportDuration: Swift.Double
  public let videoDuration: Swift.Double
  public let videoCount: Swift.UInt8
  public let videoSources: UnifiedVideoEditorSDK.VideoSources
  public let aspectRatio: Swift.String
  public init(exportSuccess: Swift.Bool, videoResolutions: [Swift.String], postProcessingEffects: UnifiedVideoEditorSDK.PostProcessingOptions?, cameraEffects: [Swift.String]?, exportDuration: Foundation.TimeInterval, videoDuration: Foundation.TimeInterval, videoCount: Swift.UInt8, videoSources: UnifiedVideoEditorSDK.VideoSources, aspectRatio: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PostProcessingOptions : Swift.Codable {
  public init(visual: Swift.Int, speed: Swift.Int, mask: Swift.Int, color: Swift.Int, text: Swift.Int, sticker: Swift.Int, blur: Swift.Int)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct InitEventOptions : UnifiedVideoEditorSDK.BasicEventOptions {
  public var sdkVersion: Swift.String
  public var iOSVersion: Swift.String
  public init()
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias BanubaVideoEditorEntryPoint = UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint
public struct PresentEventOptions : UnifiedVideoEditorSDK.BasicEventOptions {
  public var sdkVersion: Swift.String
  public var iOSVersion: Swift.String
  public enum EntryPoint : Swift.String, Swift.Codable {
    case camera
    case pip
    case trimmer
    case editor
    case drafts
    case gallery
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init(entryPoint: UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.Error {
  public var isCancelled: Swift.Bool {
    get
  }
  public var isNetworkUnavailable: Swift.Bool {
    get
  }
}
extension Foundation.NSError {
  public static func makeCancelledError(domain: Swift.String) -> Foundation.NSError
}
public protocol VideoEditorTrackServicing {
  var preferredTrackId: CoreMedia.CMPersistentTrackID { get }
  func hasVideoAudio() -> Swift.Bool
  func isAudioTrackVolumeChanged() -> Swift.Bool
  func videoVolume() -> Swift.Float
  func setVideoVolume(_ volume: Swift.Float)
  func setVideoVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  func hasPiPAudio() -> Swift.Bool
  func isPiPAudioTrackVolumeChanged() -> Swift.Bool
  func getPiPAudioVolume() -> Swift.Float
  func setPiPAudioVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  func setPiPAudioVolume(_ volume: Swift.Float)
  func addMusicTrack(didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, preferredTrackID: CoreMedia.CMPersistentTrackID?, start: CoreMedia.CMTime, duration: CoreMedia.CMTime?, trimmedStart: Foundation.TimeInterval?) -> (id: CoreMedia.CMPersistentTrackID, asset: AVFoundation.AVURLAsset, timeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, compositionStart: CoreMedia.CMTime, avAssetTrack: AVFoundation.AVAssetTrack)?
  func changeMusicTrackPosition(currentTime: Swift.Double, durationInSeconds: Swift.Double, compositionTimeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack, audioTrackId: CoreMedia.CMPersistentTrackID, audioServiceItem: UnifiedVideoEditorSDK.AudioServiceItem) -> CoreMedia.CMTimeRange?
  func getTrackVolume(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  func setTrack(trackId: CoreMedia.CMPersistentTrackID, volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  func removeTrack(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  func removeAllMusicTracks()
}
public protocol WatermarkApplicatorServicing : AnyObject {
  func adjustWatermarkEffect(configuration: UnifiedVideoEditorSDK.WatermarkConfiguration, videoSize: CoreFoundation.CGSize) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
}
public protocol VideoEditorServicing : UnifiedVideoEditorSDK.EffectsManagement, UnifiedVideoEditorSDK.VideoEditorTrackServicing {
  var asset: AVFoundation.AVAsset? { get }
  var videoAsset: UnifiedVideoEditorSDK.VideoEditorAsset? { get set }
  var exportFrameDuration: CoreMedia.CMTime { get set }
  var videoSize: CoreFoundation.CGSize { get set }
  var audioMixer: UnifiedVideoEditorSDK.AudioMixer? { get set }
  func getEditorEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [UnifiedVideoEditorSDK.VideoEditorFilterModel]
  func setCurrentAsset(_ asset: UnifiedVideoEditorSDK.VideoEditorAsset?)
  func setEditorEffects(_ effects: [UnifiedVideoEditorSDK.VideoEditorFilterModel])
  func getImageGenerator() -> AVFoundation.AVAssetImageGenerator?
  func videoPartsCount() -> Swift.Int
  func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
  init?(token: Swift.String)
  init(license: UnifiedVideoEditorSDK.License)
}
final public class VideoEditorService {
  final public func getVideoPlayerItem(forExternalAsset asset: AVFoundation.AVAsset?) -> AVFoundation.AVPlayerItem?
  final public func getMusicPlayerItem(forExternalAsset asset: AVFoundation.AVAsset?) -> AVFoundation.AVPlayerItem?
  final public var videoAsset: UnifiedVideoEditorSDK.VideoEditorAsset? {
    get
    set
  }
  final public var asset: AVFoundation.AVAsset? {
    get
  }
  final public var videoSize: CoreFoundation.CGSize
  final public var exportFrameDuration: CoreMedia.CMTime
  final public var audioMixer: UnifiedVideoEditorSDK.AudioMixer?
  final public var effects: UnifiedVideoEditorSDK.AppliedEffectsStack {
    get
  }
  final public var autoCutEffects: UnifiedVideoEditorSDK.AutoCutEffectsStack {
    get
  }
  final public let license: UnifiedVideoEditorSDK.License
  convenience public init?(token: Swift.String)
  public init(license: UnifiedVideoEditorSDK.License)
  @objc deinit
  final public func createExportComposition(asset: AVFoundation.AVAsset, dataSource: (any UnifiedVideoEditorSDK.SDKVideoCompositionInstructionDataSource)?, renderSize: CoreFoundation.CGSize) -> AVFoundation.AVVideoComposition?
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.EffectsManagement {
  final public func changeEffectTimeRange(with uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  final public func applyEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime, removeSameType: Swift.Bool, isAutoCutEffect: Swift.Bool)
  final public func getSpeed(at time: CoreMedia.CMTime) -> Swift.Float
  @discardableResult
  final public func undoEffect(uuid: Swift.String) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  @discardableResult
  final public func undoLast(type: UnifiedVideoEditorSDK.EditorEffectType) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  final public func undoAll(type: UnifiedVideoEditorSDK.EditorEffectType)
  final public func undoAll(except type: UnifiedVideoEditorSDK.EditorEffectType)
  final public func undoAll()
  final public func startCurrentEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, at: CoreMedia.CMTime)
  final public func endCurrentEffect(at: CoreMedia.CMTime)
  final public func getCurrentAppliedEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getStoredEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getCurrentAppliedEffects() -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func storeStack()
  final public func restoreStack()
  final public func hasChangesInAppliedEffects() -> Swift.Bool
  final public func hasAutoCutEffects() -> Swift.Bool
  final public func undoAutoCutEffects()
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.SDKVideoCompositionInstructionDataSource {
  final public func getEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getEffectsBefore(time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.VideoEditorServicing {
  final public func getImageGenerator() -> AVFoundation.AVAssetImageGenerator?
  final public func reattachMusicTracks(_ mutableAsset: AVFoundation.AVMutableComposition)
  final public func getEditorEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [UnifiedVideoEditorSDK.VideoEditorFilterModel]
  final public func setCurrentAsset(_ asset: UnifiedVideoEditorSDK.VideoEditorAsset?)
  final public func setEditorEffects(_ effects: [UnifiedVideoEditorSDK.VideoEditorFilterModel])
  final public func videoPartsCount() -> Swift.Int
  final public func getLicenseState(completion: @escaping ((Swift.Bool) -> Swift.Void))
}
extension UnifiedVideoEditorSDK.VideoEditorService : UnifiedVideoEditorSDK.VideoEditorTrackServicing {
  final public var preferredTrackId: CoreMedia.CMPersistentTrackID {
    get
  }
  final public func hasVideoAudio() -> Swift.Bool
  final public func isAudioTrackVolumeChanged() -> Swift.Bool
  final public func videoVolume() -> Swift.Float
  final public func setVideoVolume(_ volume: Swift.Float)
  final public func setVideoVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  final public func hasPiPAudio() -> Swift.Bool
  final public func isPiPAudioTrackVolumeChanged() -> Swift.Bool
  final public func getPiPAudioVolume() -> Swift.Float
  final public func setPiPAudioVolume(_ volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  final public func setPiPAudioVolume(_ volume: Swift.Float)
  final public func hasPiPAudioTrack() -> Swift.Bool
  final public func changeMusicTrackPosition(currentTime: Swift.Double, durationInSeconds: Swift.Double, compositionTimeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack, audioTrackId: CoreMedia.CMPersistentTrackID, audioServiceItem: UnifiedVideoEditorSDK.AudioServiceItem) -> CoreMedia.CMTimeRange?
  final public func addMusicTrack(didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID, preferredTrackID: CoreMedia.CMPersistentTrackID?, start: CoreMedia.CMTime, duration: CoreMedia.CMTime?, trimmedStart: Foundation.TimeInterval?) -> (id: CoreMedia.CMPersistentTrackID, asset: AVFoundation.AVURLAsset, timeRange: CoreMedia.CMTimeRange, composition: AVFoundation.AVMutableCompositionTrack, compositionStart: CoreMedia.CMTime, avAssetTrack: AVFoundation.AVAssetTrack)?
  final public func getTrackVolume(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  final public func setTrack(trackId: CoreMedia.CMPersistentTrackID, volume: Swift.Float, to player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
  final public func removeTrack(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  final public func removeAllMusicTracks()
}
public protocol BanubaProgressViewController : UIKit.UIViewController {
  var message: Swift.String { get set }
  var tooltipMessage: Swift.String { get set }
  var configuration: UnifiedVideoEditorSDK.ProgressViewConfiguration? { get set }
  var cancelHandler: (() -> Swift.Void)? { get set }
  func updateProgressView(with progress: Swift.Float)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ProgressViewController : UIKit.UIViewController, UnifiedVideoEditorSDK.BanubaProgressViewController {
  @_Concurrency.MainActor(unsafe) public var message: Swift.String {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var tooltipMessage: Swift.String {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.ProgressViewConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var cancelHandler: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var slideInTransitioningDelegate: (any UIKit.UIViewControllerTransitioningDelegate)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UnifiedVideoEditorSDK.ProgressViewController {
  @_Concurrency.MainActor(unsafe) public func updateProgressView(with progress: Swift.Float)
}
extension UnifiedVideoEditorSDK.ProgressViewController {
  @_Concurrency.MainActor(unsafe) public static func makeViewController(presentationManager: UnifiedVideoEditorSDK.SlideInPresentationManager? = nil) -> UnifiedVideoEditorSDK.ProgressViewController
}
public struct OverlayEditorConfiguration {
  public var mainOverlayViewControllerConfig: UnifiedVideoEditorSDK.MainOverlayViewControllerConfig
}
public struct MainOverlayViewControllerConfig {
  public var addButtons: [UnifiedVideoEditorSDK.OverlayAddButtonConfig]
  public var editButtonsHeight: CoreFoundation.CGFloat
  public var editButtonsInteritemSpacing: CoreFoundation.CGFloat
  public var editCompositionButtons: [UnifiedVideoEditorSDK.OverlayEditButtonConfig]
  public var controlButtons: [UnifiedVideoEditorSDK.OverlayControlButtonConfig]
  public var playerControlsHeight: CoreFoundation.CGFloat
  public var mainLabelColors: UIKit.UIColor
  public var additionalLabelColors: UIKit.UIColor
  public var additionalLabelFonts: UIKit.UIFont
  public var cursorColor: UIKit.UIColor
  public var overlayItemConfiguration: UnifiedVideoEditorSDK.OverlayItemConfiguration
  public var resizeImageName: Swift.String
  public var draggersHorizontalInset: CoreFoundation.CGFloat
  public var draggersWidth: CoreFoundation.CGFloat?
  public var draggersHeight: CoreFoundation.CGFloat?
  public var draggersImageHeight: CoreFoundation.CGFloat?
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var playerControlsBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var defaultLinesCount: Swift.Int
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public var draggerBackgroundColor: UIKit.UIColor
  public var draggerCornerRadius: CoreFoundation.CGFloat?
  public var timeLabelsOffset: CoreFoundation.CGFloat
  public var itemsTopOffset: CoreFoundation.CGFloat
  public var previewViewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
}
public struct OverlayAddButtonConfig {
  public enum `Type` : Swift.String {
    case text
    case sticker
    case blur
    case captions
    public var editorEffectType: UnifiedVideoEditorSDK.EditorEffectType {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type`
  public let title: Swift.String
  public var titleColor: UIKit.UIColor
  public var font: UIKit.UIFont
  public var imageName: Swift.String
  public var drawableFigure: UnifiedVideoEditorSDK.DrawableFigure?
  public var tintColor: UIKit.UIColor?
  public init(type: UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type`, title: Swift.String, titleColor: UIKit.UIColor, font: UIKit.UIFont, imageName: Swift.String, drawableFigure: UnifiedVideoEditorSDK.DrawableFigure? = nil, tintColor: UIKit.UIColor? = nil)
}
public struct OverlayEditButtonConfig {
  public enum `Type` : Swift.String {
    case edit
    case style
    case delete
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type`
  public let title: Swift.String
  public var titleColor: UIKit.UIColor
  public var font: UIKit.UIFont
  public let imageName: Swift.String
  public let selectedImageName: Swift.String?
  public var tintColor: UIKit.UIColor?
  public init(type: UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type`, title: Swift.String, titleColor: UIKit.UIColor, font: UIKit.UIFont, imageName: Swift.String, selectedImageName: Swift.String?, tintColor: UIKit.UIColor? = nil)
}
public struct OverlayControlButtonConfig {
  public enum `Type` : Swift.String {
    case reset
    case play
    case done
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type`
  public var image: UIKit.UIImage?
  public var selectedImage: UIKit.UIImage?
  public let imageName: Swift.String?
  public let selectedImageName: Swift.String?
  public let imageEdgeInsets: UIKit.UIEdgeInsets?
  public var style: UnifiedVideoEditorSDK.TextConfiguration?
  public var tintColor: UIKit.UIColor?
  public init(type: UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type`, imageName: Swift.String? = nil, selectedImageName: Swift.String? = nil, imageEdgeInsets: UIKit.UIEdgeInsets? = nil, style: UnifiedVideoEditorSDK.TextConfiguration? = nil, tintColor: UIKit.UIColor? = nil)
}
public struct OverlayItemConfiguration {
  public var borderColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var borderWidth: CoreFoundation.CGFloat
  public var borderInset: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var titleFont: UIKit.UIFont?
  public var titleColor: UIKit.UIColor?
  public var imageInset: UIKit.UIEdgeInsets
  public init(borderColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, borderWidth: CoreFoundation.CGFloat, borderInset: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, titleFont: UIKit.UIFont? = nil, titleColor: UIKit.UIColor? = nil, imageInset: UIKit.UIEdgeInsets)
}
extension Foundation.NSNotification.Name {
  public static let KingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let KingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: UnifiedVideoEditorSDK.CacheType, b: UnifiedVideoEditorSDK.CacheType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CacheStoreResult {
  public let memoryCacheResult: Swift.Result<(), Swift.Never>
  public let diskCacheResult: Swift.Result<(), UnifiedVideoEditorSDK.KingfisherError>
}
extension UIKit.UIImage : UnifiedVideoEditorSDK.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Foundation.Data : UnifiedVideoEditorSDK.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult {
  case disk(UnifiedVideoEditorSDK.KFCrossPlatformImage)
  case memory(UnifiedVideoEditorSDK.KFCrossPlatformImage)
  case none
  public var image: UnifiedVideoEditorSDK.KFCrossPlatformImage? {
    get
  }
  public var cacheType: UnifiedVideoEditorSDK.CacheType {
    get
  }
}
open class ImageCache {
  public static let `default`: UnifiedVideoEditorSDK.ImageCache
  final public let memoryStorage: UnifiedVideoEditorSDK.MemoryStorage.Backend<UnifiedVideoEditorSDK.KFCrossPlatformImage>
  final public let diskStorage: UnifiedVideoEditorSDK.DiskStorage.Backend<Foundation.Data>
  public typealias DiskCachePathClosure = (Foundation.URL, Swift.String) -> Foundation.URL
  public init(memoryStorage: UnifiedVideoEditorSDK.MemoryStorage.Backend<UnifiedVideoEditorSDK.KFCrossPlatformImage>, diskStorage: UnifiedVideoEditorSDK.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: UnifiedVideoEditorSDK.ImageCache.DiskCachePathClosure? = nil) throws
  @objc deinit
  open func store(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: ((UnifiedVideoEditorSDK.CacheStoreResult) -> Swift.Void)? = nil)
  open func store(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: any UnifiedVideoEditorSDK.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: UnifiedVideoEditorSDK.CallbackQueue = .untouch, completionHandler: ((UnifiedVideoEditorSDK.CacheStoreResult) -> Swift.Void)? = nil)
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", expiration: UnifiedVideoEditorSDK.StorageExpiration? = nil, callbackQueue: UnifiedVideoEditorSDK.CallbackQueue = .untouch, completionHandler: ((UnifiedVideoEditorSDK.CacheStoreResult) -> Swift.Void)? = nil)
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: UnifiedVideoEditorSDK.CallbackQueue = .untouch, completionHandler: (() -> Swift.Void)? = nil)
  open func retrieveImage(forKey key: Swift.String, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo, callbackQueue: UnifiedVideoEditorSDK.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.ImageCacheResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)?)
  open func retrieveImage(forKey key: Swift.String, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, callbackQueue: UnifiedVideoEditorSDK.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.ImageCacheResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)?)
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, callbackQueue: UnifiedVideoEditorSDK.CallbackQueue = .untouch, completionHandler: @escaping (Swift.Result<UnifiedVideoEditorSDK.KFCrossPlatformImage?, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)
  public func clearCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func clearMemoryCache()
  open func clearDiskCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredMemoryCache()
  open func cleanExpiredDiskCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func backgroundCleanExpiredDiskCache()
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> UnifiedVideoEditorSDK.CacheType
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.Bool
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
  open func calculateDiskStorageSize(completion handler: @escaping ((Swift.Result<Swift.UInt, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void))
  #if compiler(>=5.3) && $EffectfulProp
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
  open var diskStorageSize: Swift.UInt {
    get async throws
  }
  #endif
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
}
extension UIKit.UIApplication : UnifiedVideoEditorSDK.KingfisherCompatible {
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
public struct VideoSequenceNameFormatter {
  public init()
  public func formattedNameFromDate(_ date: Foundation.Date) -> Swift.String
  public func formattedDraftSubtitleFromTime(_ time: Foundation.TimeInterval) -> Swift.String
}
public struct GalleryItemPreviewViewConfiguration {
  public var backgroundViewBlurStyle: UIKit.UIBlurEffect.Style
  public var selectionButtonView: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var selectionButtonSelectText: UnifiedVideoEditorSDK.TextConfiguration
  public var selectionButtonDeselectText: UnifiedVideoEditorSDK.TextConfiguration
  public var selectionButtonSelectImageName: Swift.String
  public var selectionButtonDeselectImageName: Swift.String
  public var previewContainerView: UnifiedVideoEditorSDK.BackgroundConfiguration
  public init(backgroundViewBlurStyle: UIKit.UIBlurEffect.Style, selectionButtonView: UnifiedVideoEditorSDK.BackgroundConfiguration, selectionButtonSelectText: UnifiedVideoEditorSDK.TextConfiguration, selectionButtonDeselectText: UnifiedVideoEditorSDK.TextConfiguration, selectionButtonSelectImageName: Swift.String, selectionButtonDeselectImageName: Swift.String, previewContainerView: UnifiedVideoEditorSDK.BackgroundConfiguration)
}
public enum BanubaVideoEditorSwiftUIError : Swift.Error, Foundation.LocalizedError {
  case initError
  case licenseError
  case exportError(description: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct BanubaVideoEditorSwiftUIView : SwiftUI.UIViewControllerRepresentable {
  public init(token: Swift.String, launchConfig: UnifiedVideoEditorSDK.VideoEditorLaunchConfig, configuration: UnifiedVideoEditorSDK.VideoEditorConfig, exportConfiguration: UnifiedVideoEditorSDK.ExportConfiguration)
  @_Concurrency.MainActor(unsafe) public func makeUIViewController(context: UnifiedVideoEditorSDK.BanubaVideoEditorSwiftUIView.Context) -> UIKit.UIViewController
  @_Concurrency.MainActor(unsafe) public func updateUIViewController(_ uiViewController: UIKit.UIViewController, context: UnifiedVideoEditorSDK.BanubaVideoEditorSwiftUIView.Context)
  public func onDidCancel(_ closure: (() -> Swift.Void)?) -> UnifiedVideoEditorSDK.BanubaVideoEditorSwiftUIView
  public func onDidSave(_ closure: (([Foundation.URL]) -> Swift.Void)?) -> UnifiedVideoEditorSDK.BanubaVideoEditorSwiftUIView
  public func onUpdateProgress(_ closure: ((Swift.Float) -> Swift.Void)?) -> UnifiedVideoEditorSDK.BanubaVideoEditorSwiftUIView
  public func onDidFail(_ closure: ((UnifiedVideoEditorSDK.BanubaVideoEditorSwiftUIError) -> Swift.Void)?) -> UnifiedVideoEditorSDK.BanubaVideoEditorSwiftUIView
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewControllerType = UIKit.UIViewController
}
public protocol RecordButton : UIKit.UIView {
  var delegate: (any UnifiedVideoEditorSDK.RecordButtonDelegate)? { get set }
  var configuration: UnifiedVideoEditorSDK.RecordButtonConfiguration { get set }
  func setCaptureButtonState(_ state: UnifiedVideoEditorSDK.CaptureButtonViewState)
  func setCaptureButtonMode(_ mode: UnifiedVideoEditorSDK.CaptureButtonViewMode)
}
public protocol RecordButtonDelegate : AnyObject {
  var captureButtonMode: UnifiedVideoEditorSDK.CaptureButtonViewMode { get }
  func recordButtonDidTakePhoto(_ recordButton: any UnifiedVideoEditorSDK.RecordButton)
  func recordButtonDidCancelTakePhoto(_ recordButton: any UnifiedVideoEditorSDK.RecordButton)
  func recordButtonDidStartVideoRecording(_ recordButton: any UnifiedVideoEditorSDK.RecordButton)
  func recordButtonDidStopVideoRecording(_ recordButton: any UnifiedVideoEditorSDK.RecordButton)
  func recordButtonDidZoomingVideoRecording(_ recordButton: any UnifiedVideoEditorSDK.RecordButton, recognizer: UIKit.UILongPressGestureRecognizer)
}
public enum CaptureButtonViewMode {
  case video
  case photo
  public static func == (a: UnifiedVideoEditorSDK.CaptureButtonViewMode, b: UnifiedVideoEditorSDK.CaptureButtonViewMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CaptureButtonViewState {
  case idle
  case recording
  case takePhoto
  public static func == (a: UnifiedVideoEditorSDK.CaptureButtonViewState, b: UnifiedVideoEditorSDK.CaptureButtonViewState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DraftActionType {
  case save
  case update
  case cancel
  case none
  public var isSaveOrUpdate: Swift.Bool {
    get
  }
  public static func == (a: UnifiedVideoEditorSDK.DraftActionType, b: UnifiedVideoEditorSDK.DraftActionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol BlurApplicatorServicing : AnyObject {
  func changeTextureLocation(drawableFigure: UnifiedVideoEditorSDK.DrawableFigure, shapeRenderer: UnifiedVideoEditorSDK.ShapeDrawer, coordinates: UnifiedVideoEditorSDK.BlurCoordinateParams, completion: (() -> Swift.Void)?)
}
@_hasMissingDesignatedInitializers public class BlurApplicator : UnifiedVideoEditorSDK.BlurApplicatorServicing {
  public func changeTextureLocation(drawableFigure: UnifiedVideoEditorSDK.DrawableFigure, shapeRenderer: UnifiedVideoEditorSDK.ShapeDrawer, coordinates: UnifiedVideoEditorSDK.BlurCoordinateParams, completion: (() -> Swift.Void)?)
  @objc deinit
}
public enum EditorEffectKey : Swift.String {
  case name
  case type
  case warpType
  case speed
  case renderer
  case path
  case id
  case effectType
  case additionalParameters
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum OverlayEffectApplicatorType {
  case gif
  case text
  case blur(drawableFigure: UnifiedVideoEditorSDK.DrawableFigure, coordinates: UnifiedVideoEditorSDK.BlurCoordinateParams)
}
public enum VisualEffectApplicatorType : Swift.String, Swift.CaseIterable {
  case acid
  case cathode
  case dvCam
  case flash
  case glitch
  case glitchEffect2
  case glitch3
  case heatmap
  case lumeire
  case kaleidoscope
  case dslrKaleidoscope
  case pixelationDynamic
  case pixelationStatic
  case polaroid
  case rave
  case soul
  case stars
  case tvFoam
  case transition1
  case transition4
  case twitch
  case vhs
  case vhs2
  case zoom
  case zoom2
  case transitionDiagonal
  case transitionDefocus
  case transitionTunnelVision
  case transitionTunnelMirrored
  public var id: Swift.Int {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.VisualEffectApplicatorType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.VisualEffectApplicatorType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum SpeedEffectType : Swift.String, Swift.CaseIterable {
  case slowmo
  case rapid
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.SpeedEffectType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.SpeedEffectType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum TransitionEffectType : Swift.String, Swift.CaseIterable {
  case normal
  case whipDown
  case whipUp
  case whipRight
  case whipLeft
  case scrollDown
  case scrollUp
  case scrollRight
  case scrollLeft
  case spinRight
  case fade
  public var id: Swift.Int {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.TransitionEffectType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.TransitionEffectType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension UnifiedVideoEditorSDK.TransitionEffectType {
  public static func type(from type: UnifiedVideoEditorSDK.TransitionType) -> UnifiedVideoEditorSDK.TransitionEffectType
}
public protocol VideoPlayableView : UIKit.UIImageView {
  var previewLayer: AVFoundation.AVPlayerLayer { get }
  var imageGenerator: AVFoundation.AVAssetImageGenerator? { get set }
  var videoEditorPlayer: (any UnifiedVideoEditorSDK.VideoEditorPlayable)? { get set }
  var player: AVFoundation.AVPlayer? { get }
  func setPlayer(_ player: (any UnifiedVideoEditorSDK.VideoEditorPlayable)?, isThumbnailNeeded: Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class PlayablePreview : UIKit.UIImageView, UnifiedVideoEditorSDK.VideoPlayableView {
  @_Concurrency.MainActor(unsafe) public var videoEditorPlayer: (any UnifiedVideoEditorSDK.VideoEditorPlayable)?
  @_Concurrency.MainActor(unsafe) public var imageGenerator: AVFoundation.AVAssetImageGenerator?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public var previewLayer: AVFoundation.AVPlayerLayer {
    get
  }
  @_Concurrency.MainActor(unsafe) public var player: AVFoundation.AVPlayer? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func setPlayer(_ player: (any UnifiedVideoEditorSDK.VideoEditorPlayable)?, isThumbnailNeeded: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public class TextButtonConfiguration : ObjectiveC.NSObject {
  public var style: UnifiedVideoEditorSDK.TextConfiguration
  public var text: Swift.String?
  public init(style: UnifiedVideoEditorSDK.TextConfiguration, text: Swift.String? = nil)
  @objc deinit
}
@objc public protocol InputServicing : UnifiedVideoEditorSDK.AudioCapturing, UnifiedVideoEditorSDK.CameraServicing, UnifiedVideoEditorSDK.CameraZoomable {
}
public typealias RotateCameraCallBack = () -> ()
@objc public protocol CameraServicing {
  @objc var delegate: (any UnifiedVideoEditorSDK.InputServiceDelegate)? { get set }
  @objc var isFrontCamera: Swift.Bool { get }
  @objc var isPhotoCameraSession: Swift.Bool { get }
  @objc var currentCameraSessionType: UnifiedVideoEditorSDK.CameraSessionType { get }
  @objc var exposurePointOfInterest: CoreFoundation.CGPoint { get }
  @objc var flipCamera: Swift.Bool { get set }
  @objc var cameraVideoOutput: AVFoundation.AVCaptureVideoDataOutput? { get }
  @objc func setupCamera()
  @objc func startCamera()
  @objc func stopCamera()
  @objc func releaseAudioCaptureSession()
  @objc func setCameraSessionType(_ type: UnifiedVideoEditorSDK.CameraSessionType)
  @objc func setCameraSessionType(_ type: UnifiedVideoEditorSDK.CameraSessionType, completion: @escaping UnifiedVideoEditorSDK.RotateCameraCallBack)
  @objc func setCameraSessionType(_ type: UnifiedVideoEditorSDK.CameraSessionType, zoomFactor: Swift.Float, completion: @escaping UnifiedVideoEditorSDK.RotateCameraCallBack)
  @objc func focus(at point: CoreFoundation.CGPoint, useContinuousDetection: Swift.Bool)
  @objc func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  @objc func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
  @objc func initiatePhotoCapture(cameraSettings: UnifiedVideoEditorSDK.CameraPhotoSettings, completion: @escaping (CoreVideo.CVImageBuffer?, BNBSdkCore.BNBFrameData?) -> Swift.Void)
  @objc func switchCamera(to type: UnifiedVideoEditorSDK.CameraSessionType, completion: @escaping UnifiedVideoEditorSDK.RotateCameraCallBack)
}
@objc public protocol AudioCapturing {
  @objc func startAudioCapturing()
  @objc func stopAudioCapturing()
}
@objc public protocol CameraZoomable {
  @objc var currentFieldOfView: Swift.Float { get }
  @objc var isZoomFactorAdjustable: Swift.Bool { get }
  @objc var minZoomFactor: Swift.Float { get }
  @objc var maxZoomFactor: Swift.Float { get }
  @objc var zoomFactor: Swift.Float { get }
  @objc func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
}
@objc public protocol InputServiceDelegate {
  @objc func push(cvBuffer: CoreVideo.CVPixelBuffer)
  @objc func push(cmBuffer: CoreMedia.CMSampleBuffer)
}
@objc public enum CameraSessionType : Swift.Int {
  case FrontCameraVideoSession = 0
  case BackCameraVideoSession = 1
  case FrontCameraPhotoSession = 2
  case BackCameraPhotoSession = 3
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class CameraPhotoSettings : ObjectiveC.NSObject {
  @objc final public let photoQualityPrioritization: AVFoundation.AVCapturePhotoOutput.QualityPrioritization
  @objc final public let flashMode: AVFoundation.AVCaptureDevice.FlashMode
  @objc public init(photoQualityPrioritization: AVFoundation.AVCapturePhotoOutput.QualityPrioritization, flashMode: AVFoundation.AVCaptureDevice.FlashMode)
  @objc deinit
}
extension UnifiedVideoEditorSDK.CameraSessionType {
  public var isFrontCamera: Swift.Bool {
    get
  }
  public var isPhotoMode: Swift.Bool {
    get
  }
}
extension UnifiedVideoEditorSDK.CameraServicing {
  public func toggleCamera(completion: @escaping UnifiedVideoEditorSDK.RotateCameraCallBack)
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity(color: UIKit.UIColor)
  case image(imageData: Foundation.Data)
  case custom(indicator: any UnifiedVideoEditorSDK.Indicator)
}
public protocol Indicator {
  func startAnimatingView()
  func stopAnimatingView()
  var centerOffset: CoreFoundation.CGPoint { get }
  var view: UnifiedVideoEditorSDK.IndicatorView { get }
  func sizeStrategy(in imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView) -> UnifiedVideoEditorSDK.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreFoundation.CGSize)
}
extension UnifiedVideoEditorSDK.Indicator {
  public var centerOffset: CoreFoundation.CGPoint {
    get
  }
  public func sizeStrategy(in imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView) -> UnifiedVideoEditorSDK.IndicatorSizeStrategy
}
public struct ImageCreatingOptions {
  public let scale: CoreFoundation.CGFloat
  public let duration: Foundation.TimeInterval
  public let preloadAll: Swift.Bool
  public let onlyFirstFrame: Swift.Bool
  public init(scale: CoreFoundation.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers public class GIFAnimatedImage {
  public static func getFrameDuration(from gifInfo: [Swift.String : Any]?) -> Foundation.TimeInterval
  public static func getFrameDuration(from imageSource: ImageIO.CGImageSource, at index: Swift.Int) -> Foundation.TimeInterval
  @objc deinit
}
extension UIKit.UITouch {
  @_Concurrency.MainActor(unsafe) public var id: Swift.Int64 {
    get
  }
}
public struct VideoEditorColorsPalette {
  public let primaryColor: UIKit.UIColor
  public let secondaryColor: UIKit.UIColor
  public let accentColor: UIKit.UIColor
  public let effectButtonColorsPalette: UnifiedVideoEditorSDK.EffectButtonColorsPalette
  public let addGalleryItemBackgroundColor: UIKit.UIColor
  public let addGalleryItemIconColor: UIKit.UIColor
  public let timelineEffectColorsPalette: UnifiedVideoEditorSDK.TimelineEffectColorsPalette
  public init(primaryColor: UIKit.UIColor, secondaryColor: UIKit.UIColor, accentColor: UIKit.UIColor, effectButtonColorsPalette: UnifiedVideoEditorSDK.EffectButtonColorsPalette, addGalleryItemBackgroundColor: UIKit.UIColor, addGalleryItemIconColor: UIKit.UIColor, timelineEffectColorsPalette: UnifiedVideoEditorSDK.TimelineEffectColorsPalette)
}
public struct EffectButtonColorsPalette {
  public let defaultIconColor: UIKit.UIColor
  public let defaultBackgroundColor: UIKit.UIColor
  public let selectedIconColor: UIKit.UIColor
  public let selectedBackgroundColor: UIKit.UIColor
  public init(defaultIconColor: UIKit.UIColor, defaultBackgroundColor: UIKit.UIColor, selectedIconColor: UIKit.UIColor, selectedBackgroundColor: UIKit.UIColor)
}
public struct TimelineEffectColorsPalette {
  public let stickersColor: UIKit.UIColor
  public let textsColor: UIKit.UIColor
  public let captionsColor: UIKit.UIColor
  public let pixelationColor: UIKit.UIColor
  public let audioTracksColor: UIKit.UIColor
  public let voiceOversColor: UIKit.UIColor
  public init(stickersColor: UIKit.UIColor, textsColor: UIKit.UIColor, captionsColor: UIKit.UIColor, pixelationColor: UIKit.UIColor, audioTracksColor: UIKit.UIColor, voiceOversColor: UIKit.UIColor)
  public static var `default`: UnifiedVideoEditorSDK.TimelineEffectColorsPalette {
    get
  }
}
public class WatermarkApplicator : UnifiedVideoEditorSDK.WatermarkApplicatorServicing {
  public init()
  public func adjustWatermarkEffect(configuration: UnifiedVideoEditorSDK.WatermarkConfiguration, videoSize: CoreFoundation.CGSize) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  @objc deinit
}
extension CoreMedia.CMTime : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class VideoDurationFormatter {
  public static func format(_ timeInterval: Foundation.TimeInterval) -> Swift.String
  @objc deinit
}
public enum Connection : Swift.CustomStringConvertible {
  case none, wifi, cellular
  public var description: Swift.String {
    get
  }
  public static func == (a: UnifiedVideoEditorSDK.Connection, b: UnifiedVideoEditorSDK.Connection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct AudioContext {
  public static let averagePeak: Swift.Float
  public static func averagePowers(audioFileURL: Foundation.URL, forChannel channelNumber: Swift.Int, compositionStart: Foundation.TimeInterval, compositionEnd: Foundation.TimeInterval?, duration: Foundation.TimeInterval, numberOfPeaks: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int) -> [Swift.Float]
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var keyboardLayoutGuide: UIKit.UILayoutGuide {
    get
  }
  @_Concurrency.MainActor(unsafe) public var keyboardLayoutGuideNoSafeArea: UIKit.UILayoutGuide {
    get
  }
}
@objc @_Concurrency.MainActor(unsafe) open class KeyboardLayoutGuide : UIKit.UILayoutGuide {
  @_Concurrency.MainActor(unsafe) public var usesSafeArea: Swift.Bool {
    get
    set
  }
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(notificationCenter: Foundation.NotificationCenter = NotificationCenter.default)
  @objc deinit
}
public protocol ImagesSequence {
  var relativeScreenPoints: UnifiedVideoEditorSDK.ImagePoints { get }
  func getImage(at time: Foundation.TimeInterval) -> CoreGraphics.CGImage
}
public struct VideoEditorConfig {
  public var videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var recorderConfiguration: UnifiedVideoEditorSDK.RecorderConfiguration
  public var editorConfiguration: UnifiedVideoEditorSDK.EditorConfiguration
  public var textEditorConfiguration: UnifiedVideoEditorSDK.TextEditorConfiguration
  public var toastConfiguration: UnifiedVideoEditorSDK.ToastConfiguration
  public var fullScreenActivityConfiguration: UnifiedVideoEditorSDK.FullScreenActivityConfiguration
  public var smallActivityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public var albumsConfiguration: UnifiedVideoEditorSDK.AlbumsConfiguration
  public var videoOverlayConfiguration: UnifiedVideoEditorSDK.VideoOverlayConfiguration
  public var videoDurationConfiguration: UnifiedVideoEditorSDK.VideoEditorDurationConfig
  public var gifPickerConfiguration: UnifiedVideoEditorSDK.GifPickerConfiguration
  public var combinedGalleryConfiguration: UnifiedVideoEditorSDK.GalleryConfiguration
  public var trimVideosConfiguration: UnifiedVideoEditorSDK.TrimVideosConfiguration
  public var trimVideoConfiguration: UnifiedVideoEditorSDK.TrimVideoConfiguration
  public var filterConfiguration: UnifiedVideoEditorSDK.FilterConfiguration
  public var extendedVideoCoverSelectionConfiguration: UnifiedVideoEditorSDK.VideoCoverSelectionConfiguration
  public var musicEditorConfiguration: UnifiedVideoEditorSDK.MusicEditorConfig
  public var overlayEditorConfiguration: UnifiedVideoEditorSDK.OverlayEditorConfiguration
  public var watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?
  public var alertViewConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration
  public var popoverAlertViewConfiguration: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration
  public var handsfreeConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration?
  public var pipSettingsConfiguration: UnifiedVideoEditorSDK.PIPSettingsConfiguration?
  public var sharingScreenConfiguration: UnifiedVideoEditorSDK.SharingScreenConfiguration
  public var featureConfiguration: UnifiedVideoEditorSDK.FeatureConfiguration
  public var isHandfreeEnabled: Swift.Bool
  public var draftsConfiguration: UnifiedVideoEditorSDK.DraftsConfiguration
  public var aspectsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration
  public var transitionsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration
  public var progressViewConfiguration: UnifiedVideoEditorSDK.ProgressViewConfiguration
  public var captionsConfiguration: UnifiedVideoEditorSDK.CaptionsConfiguration
  public var autoCutConfiguration: UnifiedVideoEditorSDK.AutoCutConfiguration
  public var beautyIntensityConfiguration: UnifiedVideoEditorSDK.BeautyIntensityConfiguration
  public init()
  public init(videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration, recorderConfiguration: UnifiedVideoEditorSDK.RecorderConfiguration, editorConfiguration: UnifiedVideoEditorSDK.EditorConfiguration, textEditorConfiguration: UnifiedVideoEditorSDK.TextEditorConfiguration, toastConfiguration: UnifiedVideoEditorSDK.ToastConfiguration, fullScreenActivityConfiguration: UnifiedVideoEditorSDK.FullScreenActivityConfiguration, smallActivityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration, albumsConfiguration: UnifiedVideoEditorSDK.AlbumsConfiguration, videoOverlayConfiguration: UnifiedVideoEditorSDK.VideoOverlayConfiguration, videoDurationConfiguration: UnifiedVideoEditorSDK.VideoEditorDurationConfig, gifPickerConfiguration: UnifiedVideoEditorSDK.GifPickerConfiguration, combinedGalleryConfiguration: UnifiedVideoEditorSDK.GalleryConfiguration, trimVideosConfiguration: UnifiedVideoEditorSDK.TrimVideosConfiguration, trimVideoConfiguration: UnifiedVideoEditorSDK.TrimVideoConfiguration, filterConfiguration: UnifiedVideoEditorSDK.FilterConfiguration, extendedVideoCoverSelectionConfiguration: UnifiedVideoEditorSDK.VideoCoverSelectionConfiguration, musicEditorConfiguration: UnifiedVideoEditorSDK.MusicEditorConfig, overlayEditorConfiguration: UnifiedVideoEditorSDK.OverlayEditorConfiguration, featureConfiguration: UnifiedVideoEditorSDK.FeatureConfiguration, watermarkConfiguration: UnifiedVideoEditorSDK.WatermarkConfiguration?, alertViewConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration, popoverAlertViewConfiguration: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration, handsfreeConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration?, pipSettingsConfiguration: UnifiedVideoEditorSDK.PIPSettingsConfiguration?, sharingScreenConfiguration: UnifiedVideoEditorSDK.SharingScreenConfiguration, draftsConfiguration: UnifiedVideoEditorSDK.DraftsConfiguration, aspectsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration, transitionsConfiguration: UnifiedVideoEditorSDK.EffectsListConfiguration, progressViewConfiguration: UnifiedVideoEditorSDK.ProgressViewConfiguration, captionsConfiguration: UnifiedVideoEditorSDK.CaptionsConfiguration, autoCutConfiguration: UnifiedVideoEditorSDK.AutoCutConfiguration, beautyIntensityConfiguration: UnifiedVideoEditorSDK.BeautyIntensityConfiguration)
  public mutating func setupColorsPalette(_ colorsPalette: UnifiedVideoEditorSDK.VideoEditorColorsPalette)
  public mutating func applyFont(_ font: UIKit.UIFont)
  public mutating func updateAlertFonts(_ font: UIKit.UIFont)
  public mutating func updateProgressViewFonts(_ font: UIKit.UIFont)
  public mutating func updateRecorderFonts(_ font: UIKit.UIFont)
  public mutating func updateEditorFonts(_ font: UIKit.UIFont)
  public mutating func updateToastFonts(_ font: UIKit.UIFont)
  public mutating func updateFullScreenActivityFonts(_ font: UIKit.UIFont)
  public mutating func updateAlbumsFonts(_ font: UIKit.UIFont)
  public mutating func updateTextEditorFonts(_ font: UIKit.UIFont)
  public mutating func updateSlideShowFonts(_ font: UIKit.UIFont)
  public mutating func updateTrimVideosFonts(_ font: UIKit.UIFont)
  public mutating func updateTrimVideoFonts(_ font: UIKit.UIFont)
  public mutating func updateFilterFonts(_ font: UIKit.UIFont)
  public mutating func updateExtendedVideoCoverSelectionFonts(_ font: UIKit.UIFont)
  public mutating func updateFeatureConfiguration(featureConfiguration: UnifiedVideoEditorSDK.FeatureConfiguration)
}
public struct TextEditorConfiguration {
  public var doneButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var fontButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var colorButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var textBackgroundButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var alignmentImages: [UnifiedVideoEditorSDK.VideoTextAlignment : UnifiedVideoEditorSDK.ImageButtonConfiguration]
  public var palette: [UnifiedVideoEditorSDK.VideoTextColorPair]
  public var fonts: [UnifiedVideoEditorSDK.VideoTextFont]
  public var additionalPaletteBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var palleteInsets: UIKit.UIEdgeInsets
  public var fontInsets: UIKit.UIEdgeInsets
  public var selectionColorBehavior: any UnifiedVideoEditorSDK.TextEditSelectionColorBehavior
  public var colorItemConfiguration: UnifiedVideoEditorSDK.TextEditColorItemConfiguration
  public var fontItemConfiguration: UnifiedVideoEditorSDK.TextEditFontItemConfiguration
  public var cursorColor: UIKit.UIColor
  public var isTextBackgroundColorAppliedByDefault: Swift.Bool
}
public struct TextEditColorItemConfiguration {
  public var borderColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public init(borderColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat)
}
public struct TextEditFontItemConfiguration {
  public var titleColor: UIKit.UIColor
  public let fontSize: CoreFoundation.CGFloat
  public let cornerRadius: CoreFoundation.CGFloat
  public let backgroundColor: UIKit.UIColor
  public let borderSelectionColor: UIKit.UIColor
  public let borderSelectionWidth: CoreFoundation.CGFloat
  public init(titleColor: UIKit.UIColor, fontSize: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, borderSelectionColor: UIKit.UIColor = .clear, borderSelectionWidth: CoreFoundation.CGFloat = .zero)
}
public struct VideoOverlayConfiguration {
  public var deleteImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var videoOverlayItemViewBlurConfiguration: UnifiedVideoEditorSDK.VideoOverlayItemViewConfiguration?
  public init(deleteImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, videoOverlayItemViewBlurConfiguration: UnifiedVideoEditorSDK.VideoOverlayItemViewConfiguration)
}
public struct FullScreenActivityConfiguration {
  public var labelFont: UIKit.UIFont
  public var cornerRadius: CoreFoundation.CGFloat
  public var activityEffectsViewAlpha: CoreFoundation.CGFloat
  public var activityIndicator: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public init(labelFont: UIKit.UIFont, cornerRadius: CoreFoundation.CGFloat, activityEffectsViewAlpha: CoreFoundation.CGFloat, activityIndicator: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration)
}
public struct RecorderConfiguration {
  public var videoResolution: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var saveButton: UnifiedVideoEditorSDK.SaveButtonConfiguration?
  public var backButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var removeButtonImageName: Swift.String
  public var removeMusicButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var progressLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration?
  public var floatingLineViewConfiguration: UnifiedVideoEditorSDK.TextConfiguration?
  public var floatingLineViewWidth: CoreFoundation.CGFloat?
  public var captureButtonModes: Swift.Set<UnifiedVideoEditorSDK.CaptureButtonViewMode>
  public var recordButtonConfiguration: UnifiedVideoEditorSDK.RecordButtonConfiguration
  public var recordButtonProvider: (any UnifiedVideoEditorSDK.RecordButtonProvider)?
  public var additionalEffectsButtons: [UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration]
  public var speedBarButtons: UnifiedVideoEditorSDK.SpeedBarButtonsConfiguration
  public var galleryButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var emptyGalleryImageName: Swift.String
  public var timerConfiguration: UnifiedVideoEditorSDK.TimerConfiguration
  public var timeLineConfiguration: UnifiedVideoEditorSDK.TimeLineConfiguration
  public var regularRecordButtonPosition: CoreFoundation.CGFloat
  public var recorderEffectsConfiguration: UnifiedVideoEditorSDK.RecorderEffectsConfiguration
  public var leftControlsBottomOffsetFromCaptureButton: CoreFoundation.CGFloat
  public var leftControlsLeftOffset: CoreFoundation.CGFloat
  public var sequenceHeight: CoreFoundation.CGFloat
  public var loopAudioWhileRecording: Swift.Bool
  public var takeAudioDurationAsMaximum: Swift.Bool
  public var isDynamicMusicTitle: Swift.Bool
  public var isDefaultFrontCamera: Swift.Bool
  public var isMusicTitleFloatingLineEnabled: Swift.Bool
  public var useHEVCCodecIfPossible: Swift.Bool
  public var isPhotoSequenceAnimationEnabled: Swift.Bool
  public var muteMicrophoneForPIP: Swift.Bool
  public var isAudioRateEqualsVideoSpeed: Swift.Bool
  public var isGalleryButtonHidden: Swift.Bool
  public var supportMultiRecords: Swift.Bool
  public var videoCaptureButtonConfiguration: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var photoCaptureButtonConfiguration: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var backgroundMusicContainerConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration?
  public var floatingViewSeparatedLines: Swift.Bool
  public var effectSelectorContainerCornerRadius: CoreFoundation.CGFloat
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var videoDurationButtonConfiguration: UnifiedVideoEditorSDK.BanubaButtonConfiguration
  public var isVideoDurationButtonHidden: Swift.Bool
  public var previewScalingMode: UnifiedVideoEditorSDK.RecorderPreviewScalingMode
  public var supportsAudioForPhoto: Swift.Bool
}
public struct RecordButtonConfiguration {
  public var strokeColor: CoreGraphics.CGColor
  public var gradientColors: [CoreGraphics.CGColor]
  public var circularTimeLineIdleWidth: CoreFoundation.CGFloat
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var defaultVideoRecordButtonColor: UIKit.UIColor
  public var defaultTakePhotoButtonColor: UIKit.UIColor
  public var videoRecordButtonColor: UIKit.UIColor
  public var takePhotoButtonColor: UIKit.UIColor
  public var externalCircleFullColor: CoreGraphics.CGColor
  public var externalCircleStrokeColor: CoreGraphics.CGColor
}
public enum RecorderPreviewScalingMode {
  case aspectFill
  case aspectFit
  public static func == (a: UnifiedVideoEditorSDK.RecorderPreviewScalingMode, b: UnifiedVideoEditorSDK.RecorderPreviewScalingMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PIPSettingsConfiguration {
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var dragIndicatorConfiguration: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var layoutSettingsButtonsConfiguration: [UnifiedVideoEditorSDK.PIPSelectableCellConfiguration]
}
public struct TrimVideoConfiguration {
  public var saveButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var backButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var trimTimeLineConfiguration: UnifiedVideoEditorSDK.TrimTimeLineConfiguration
  public var trimTimeLineHeight: CoreFoundation.CGFloat
  public var playerControlConfiguration: UnifiedVideoEditorSDK.PlayerControlConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var controlsPanelBackgroundColor: UIKit.UIColor
  public var trimmerPanelBackgroundColor: UIKit.UIColor
  public var timeLabelsConfiguration: UnifiedVideoEditorSDK.TextConfiguration
}
public struct TimeLineConfiguration {
  public var isTimeLineHidden: Swift.Bool
  public var timeLineBackgroundColor: UIKit.UIColor
  public var progressBarColor: UIKit.UIColor
  public var progressBarSelectColor: UIKit.UIColor
  public var itemsCornerRadius: CoreFoundation.CGFloat
  public var separatorWidth: CoreFoundation.CGFloat
  public var separatorColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
}
public struct TransitionActionConfiguration {
  public let imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public let height: CoreFoundation.CGFloat
  public let clickableWidth: CoreFoundation.CGFloat
  public let backgroundColor: UIKit.UIColor
  public let cornerRadius: CoreFoundation.CGFloat
  public let shadowColor: UIKit.UIColor
  public init(imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, height: CoreFoundation.CGFloat, clickableWidth: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, shadowColor: UIKit.UIColor)
}
@objc public class TrimTimeLineConfiguration : ObjectiveC.NSObject {
  public var controlsColor: UIKit.UIColor
  public var cursorColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var trimContentCornerRadius: CoreFoundation.CGFloat
  public var timelineTopBottomInset: CoreFoundation.CGFloat
  public var draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration
  public var transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]?
  public init(controlsColor: UIKit.UIColor, cursorColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat, trimContentCornerRadius: CoreFoundation.CGFloat, timelineTopBottomInset: CoreFoundation.CGFloat, draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration, transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]? = nil)
  @objc deinit
}
@objc public class CompositionTimelineConfiguration : ObjectiveC.NSObject {
  public var controlsColor: UIKit.UIColor
  public var cursorColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var contentCornerRadius: CoreFoundation.CGFloat
  public var timelineTopBottomInset: CoreFoundation.CGFloat
  public var draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration
  public var transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]?
  public init(controlsColor: UIKit.UIColor, cursorColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat, contentCornerRadius: CoreFoundation.CGFloat, timelineTopBottomInset: CoreFoundation.CGFloat, draggerConfiguration: UnifiedVideoEditorSDK.DraggerConfiguration, transitionIcons: [UnifiedVideoEditorSDK.TransitionType : UnifiedVideoEditorSDK.TransitionActionConfiguration]? = nil)
  @objc deinit
}
public struct DraggerConfiguration {
  public var backgroundConfiguraiton: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var numberOfLinesInDraggers: Swift.Int
  public var draggerLineSize: CoreFoundation.CGSize
  public var draggerLineBackgroundConfiguraion: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var draggerImageName: Swift.String?
  public var draggerSize: CoreFoundation.CGSize
  public init(backgroundConfiguraiton: UnifiedVideoEditorSDK.BackgroundConfiguration, draggerImageName: Swift.String?, draggerSize: CoreFoundation.CGSize, numberOfLinesInDraggers: Swift.Int, draggerLineSize: CoreFoundation.CGSize, draggerLineBackgroundConfiguraion: UnifiedVideoEditorSDK.BackgroundConfiguration)
}
public struct EditorConfiguration {
  public var additionalEffectsButtons: [UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration]
  public var additionalEffectsButtonsBottomOffset: CoreFoundation.CGFloat
  public var videoResolution: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var saveButton: UnifiedVideoEditorSDK.BanubaButtonConfiguration
  public var backButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var editDraftBackButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var openTrimButton: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration
  public var musicPanelConfiguration: UnifiedVideoEditorSDK.MusicPanelConfiguration
  public enum AddToDraftsFlow {
    case alert
    case button(_: UnifiedVideoEditorSDK.RoundedButtonConfiguration)
  }
  public var addToDraftsFlow: UnifiedVideoEditorSDK.EditorConfiguration.AddToDraftsFlow
  public var isVideoAspectFillEnabled: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
}
public struct SharingScreenConfiguration {
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var videoImageViewCornerRadius: CoreFoundation.CGFloat
  public var sharingVideoTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var closeButtonConfiguration: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var sharingModels: [UnifiedVideoEditorSDK.SharingServiceModel]
  public var sharingCellConfiguration: UnifiedVideoEditorSDK.SharingCellConfiguration
  public var facebookId: Swift.String
  public init(sharingModels: [UnifiedVideoEditorSDK.SharingServiceModel], videoImageViewCornerRadius: CoreFoundation.CGFloat, sharingVideoTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, sharingCellConfiguration: UnifiedVideoEditorSDK.SharingCellConfiguration, closeButtonConfiguration: UnifiedVideoEditorSDK.RoundedButtonConfiguration, facebookId: Swift.String)
}
public struct SharingCellConfiguration {
  public let titleTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public init(titleTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct GifPickerConfiguration {
  public var dragIndicatorColor: UIKit.UIColor
  public var regularFont: UIKit.UIFont
  public var boldFont: UIKit.UIFont
  public var activityConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public var cursorColor: UIKit.UIColor
  public var searchBarTextColor: UIKit.UIColor
  public var gifResolution: UnifiedVideoEditorSDK.GiphyResolution
  public var giphyAPIKey: Swift.String?
  public var preferredRating: Swift.String?
  public var tryAgainButtonColor: UIKit.UIColor
  public var mode: UnifiedVideoEditorSDK.GifPickerMode
}
public enum GifPickerMode : Swift.Equatable {
  case search
  case list([Swift.String])
  public static func == (a: UnifiedVideoEditorSDK.GifPickerMode, b: UnifiedVideoEditorSDK.GifPickerMode) -> Swift.Bool
}
public struct TrimVideosConfiguration {
  public var videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var backButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var nextButtonConfiguration: UnifiedVideoEditorSDK.ImageTextButtonConfiguration
  public var controlsPanelBackgroundColor: UIKit.UIColor
  public var playerControlConfiguration: UnifiedVideoEditorSDK.PlayerControlConfiguration
  public var videoPartsBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var aspectsButton: UnifiedVideoEditorSDK.ImageButtonConfiguration?
  public var timeLabelsConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var editVideoItemTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var editVideoItems: [UnifiedVideoEditorSDK.TrimVideoCompositionEditItem]
  public var addGalleryVideoButtonBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var addGalleryVideoImageButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var videoPartConfiguration: UnifiedVideoEditorSDK.TrimVideoPartConfiguration
  public var reorderingVideoToolTipLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var trimTimelineConfiguration: UnifiedVideoEditorSDK.TrimTimeLineConfiguration
  public var isGalleryButtonHidden: Swift.Bool
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
}
public struct TrimVideoPartConfiguration {
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var timeLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public init(borderWidth: CoreFoundation.CGFloat, borderColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, timeLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct TrimVideoCompositionEditItem {
  public enum TrimVideoCompositionEditItemType : Swift.CaseIterable {
    case rotate
    case split
    case delete
    case trim
    case volume
    public static func == (a: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType, b: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType]
    public static var allCases: [UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public let title: Swift.String
  public let icon: UnifiedVideoEditorSDK.ImageConfiguration
  public let type: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType
  public init(title: Swift.String, icon: UnifiedVideoEditorSDK.ImageConfiguration, type: UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType)
}
public struct FilterConfiguration {
  public var controlButtons: [UnifiedVideoEditorSDK.FilterControlButtonConfig]
  public var controlsPanelBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var resetButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var toolTipLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var cursorButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public var effectItemConfiguration: UnifiedVideoEditorSDK.EffectItemConfiguration
  public var doneButtonHeight: CoreFoundation.CGFloat?
  public var timelineHeight: CoreFoundation.CGFloat
  public var timelineLeftOffset: CoreFoundation.CGFloat
  public var timelineRightOffset: CoreFoundation.CGFloat
  public var filtersHeight: CoreFoundation.CGFloat
  public var preferredLutsOrder: [Swift.String]
  public var preferredMasksOrder: [Swift.String]
  public var preferredVideoEffectOrderAndSet: [UnifiedVideoEditorSDK.VisualEffectApplicatorType]
  public var colorEffectsURL: Foundation.URL
}
public typealias TimerOptionBarConfiguration = UnifiedVideoEditorSDK.HandsfreeConfiguration.TimerOptionBarConfiguration
public struct HandsfreeConfiguration {
  public struct TimerOptionBarConfiguration {
    public var selectorColor: UIKit.UIColor
    public var selectorTextColor: UIKit.UIColor
    public var selectorTextFont: UIKit.UIFont
    public var selectorBorderWidth: CoreFoundation.CGFloat
    public var selectorBorderColor: CoreGraphics.CGColor
    public var optionBackgroundColor: UIKit.UIColor
    public var optionCornerRadius: CoreFoundation.CGFloat
    public var optionTextColor: UIKit.UIColor
    public var optionTextFont: UIKit.UIFont
    public var backgroundColor: UIKit.UIColor
    public var backgroundViewColor: UIKit.UIColor
    public var cornerRadius: CoreFoundation.CGFloat
    public var sliderCornerRadius: CoreFoundation.CGFloat
    public var barCornerRadius: CoreFoundation.CGFloat
    public var selectorEdgeInsets: UIKit.UIEdgeInsets
    public var activeThumbAndLineColor: UIKit.UIColor
    public var inactiveThumbAndLineColor: UIKit.UIColor
    public var minVideoDuration: Swift.Double
    public var buttonCornerRadius: CoreFoundation.CGFloat
    public var buttonBackgroundColor: UIKit.UIColor
    public var modeTitleColor: UIKit.UIColor
    public var dragTitleColor: UIKit.UIColor
    public var dragTitleFont: UIKit.UIFont
    public var buttonTitleColor: UIKit.UIColor
    public var buttonTitleFont: UIKit.UIFont
    public var currentValueTextColor: UIKit.UIColor
    public var minimumValueTextColor: UIKit.UIColor
    public var maximumValueTextColor: UIKit.UIColor
    public var currentValueTextFont: UIKit.UIFont
    public var minimumValueTextFont: UIKit.UIFont
    public var maximumValueTextFont: UIKit.UIFont
    public var thumbLineViewColor: UIKit.UIColor
    public var thumbLineViewBackgroundColor: UIKit.UIColor
    public var cursorViewColor: UIKit.UIColor
    public init(selectorColor: UIKit.UIColor, selectorTextColor: UIKit.UIColor, selectorTextFont: UIKit.UIFont, selectorBorderWidth: CoreFoundation.CGFloat, selectorBorderColor: CoreGraphics.CGColor, optionBackgroundColor: UIKit.UIColor, optionCornerRadius: CoreFoundation.CGFloat, optionTextColor: UIKit.UIColor, optionTextFont: UIKit.UIFont, backgroundColor: UIKit.UIColor, backgroundViewColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, sliderCornerRadius: CoreFoundation.CGFloat, barCornerRadius: CoreFoundation.CGFloat, selectorEdgeInsets: UIKit.UIEdgeInsets, activeThumbAndLineColor: UIKit.UIColor, inactiveThumbAndLineColor: UIKit.UIColor, minVideoDuration: Swift.Double, buttonCornerRadius: CoreFoundation.CGFloat, buttonBackgroundColor: UIKit.UIColor, modeTitleColor: UIKit.UIColor, dragTitleColor: UIKit.UIColor, dragTitleFont: UIKit.UIFont, buttonTitleColor: UIKit.UIColor, buttonTitleFont: UIKit.UIFont, currentValueTextColor: UIKit.UIColor, minimumValueTextColor: UIKit.UIColor, maximumValueTextColor: UIKit.UIColor, currentValueTextFont: UIKit.UIFont, minimumValueTextFont: UIKit.UIFont, maximumValueTextFont: UIKit.UIFont, thumbLineViewColor: UIKit.UIColor, thumbLineViewBackgroundColor: UIKit.UIColor, cursorViewColor: UIKit.UIColor)
  }
  public var timerOptionBarConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration.TimerOptionBarConfiguration
  public init(timerOptionBarConfiguration: UnifiedVideoEditorSDK.HandsfreeConfiguration.TimerOptionBarConfiguration)
}
public class ProgressViewConfiguration {
  public var messageConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var tooltipMessageConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var cancelButtonTextConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var cancelButtonBorderConfiguration: UnifiedVideoEditorSDK.BorderButtonConfiguration
  public var cancelButtonBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundViewBlurStyle: UIKit.UIBlurEffect.Style
  public var progressBarColor: UIKit.UIColor
  public var progressBarHeight: CoreFoundation.CGFloat
  public var progressBarCornerRadius: CoreFoundation.CGFloat
  public init(messageConfiguration: UnifiedVideoEditorSDK.TextConfiguration, tooltipMessageConfiguration: UnifiedVideoEditorSDK.TextConfiguration, cancelButtonTextConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration, cancelButtonBorderConfiguration: UnifiedVideoEditorSDK.BorderButtonConfiguration, cancelButtonBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, backgroundViewBlurStyle: UIKit.UIBlurEffect.Style, progressBarColor: UIKit.UIColor, progressBarHeight: CoreFoundation.CGFloat, progressBarCornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
public struct BeautyIntensityConfiguration {
  public var sliderThumbSize: CoreFoundation.CGFloat
  public var sliderTintColor: UIKit.UIColor
  public init(sliderThumbSize: CoreFoundation.CGFloat, sliderTintColor: UIKit.UIColor)
}
public struct AudioPartSelectionViewConfiguration {
  public static var musicLibraryDark: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration {
    get
  }
  public static var musicLibraryLight: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration {
    get
  }
  public static var soundstripe: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class AudioPartSelectionView : UIKit.UIView, UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) final public var didScrollHandler: ((CoreMedia.CMTimeRange) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) final public func set(audioStartOffset: Foundation.TimeInterval = .zero, audioDuration: Foundation.TimeInterval, videoDuration: Foundation.TimeInterval)
  @_Concurrency.MainActor(unsafe) final public func set(playbackProgress: Swift.Double)
  @_Concurrency.MainActor(unsafe) final public func showAudioAmplitude(samples: [Swift.Float])
  @_Concurrency.MainActor(unsafe) final public func apply(configuration: UnifiedVideoEditorSDK.AudioPartSelectionViewConfiguration)
  @_Concurrency.MainActor(unsafe) final public func stopSelectionAnimationIfNeeded()
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) final public func setPlayedRangeOverlayViewHidden(_ isHidden: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func updatePlayedRangeOverlayViewLayer(completion: (() -> Swift.Void)? = nil)
  @objc deinit
}
public enum TrackDonwloadStatus : Swift.Int {
  case inProgress
  case done
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol AudioBrowserTrackApplyable {
  @objc var track: UnifiedVideoEditorSDK.AudioBrowserTrack { get set }
}
@_hasMissingDesignatedInitializers @objc public class AudioBrowserTrack : ObjectiveC.NSObject {
  public var taskId: Swift.String?
  public var uuid: Foundation.UUID
  public var downloadLink: Swift.String?
  public var downloadStatus: UnifiedVideoEditorSDK.TrackDonwloadStatus?
  public var name: Swift.String
  public var additionalName: Swift.String?
  public var duration: Foundation.TimeInterval?
  public var url: Foundation.URL?
  public var coverURL: Foundation.URL?
  public var isSaved: Swift.Bool {
    get
  }
  public var avAsset: AVFoundation.AVAsset? {
    get
  }
  @objc public init(uuid: Foundation.UUID, name: Swift.String, additionalName: Swift.String?, url: Foundation.URL?, coverURL: Foundation.URL?)
  public func setupDuration(_ duration: Foundation.TimeInterval? = nil)
  public func createAsset(withData: Foundation.Data) throws
  public func deleteFile() throws
  @objc deinit
}
extension CoreFoundation.CGSize : UnifiedVideoEditorSDK.KingfisherCompatibleValue {
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base == CoreFoundation.CGSize {
  public func resize(to size: CoreFoundation.CGSize, for contentMode: UnifiedVideoEditorSDK.ContentMode) -> CoreFoundation.CGSize
  public func constrained(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func filling(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func constrainedRect(for size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint) -> CoreFoundation.CGRect
}
public protocol ExternalViewControllerFactory {
  var musicEditorFactory: (any UnifiedVideoEditorSDK.MusicEditorExternalViewControllerFactory)? { get set }
  var countdownTimerViewFactory: (any UnifiedVideoEditorSDK.CountdownTimerViewFactory)? { get set }
  var exposureViewFactory: (any UnifiedVideoEditorSDK.AnimatableViewFactory)? { get set }
  var galleryViewControllerFactory: (any UnifiedVideoEditorSDK.GalleryViewControllerFactory)? { get set }
  var progressViewControllerFactory: (any UnifiedVideoEditorSDK.ProgressViewControllerFactory)? { get set }
}
extension UnifiedVideoEditorSDK.ExternalViewControllerFactory {
  public var galleryViewControllerFactory: (any UnifiedVideoEditorSDK.GalleryViewControllerFactory)? {
    get
    set
  }
  public var progressViewControllerFactory: (any UnifiedVideoEditorSDK.ProgressViewControllerFactory)? {
    get
    set
  }
}
public enum DrawableFigure : Swift.String, Swift.Codable {
  case circle
  case square
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Combine.Publisher {
  public func map<T>(to value: T) -> Combine.Publishers.Map<Self, T>
  public func convertToResult() -> Combine.AnyPublisher<Swift.Result<Self.Output, Self.Failure>, Swift.Never>
  public func mapSuccess<T, U, E>(_ transform: @escaping (T) -> Swift.Result<U, any Swift.Error>) -> Combine.Publishers.Map<Self, Swift.Result<U, any Swift.Error>> where E : Swift.Error, Self.Failure == Swift.Never, Self.Output == Swift.Result<T, E>
}
extension Combine.AnyPublisher {
  public static func just(_ output: Output) -> Combine.AnyPublisher<Output, Failure>
}
extension Dispatch.DispatchQueue.SchedulerTimeType.Stride {
  public static var searchFieldDebouncingTime: Dispatch.DispatchQueue.SchedulerTimeType.Stride {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class PIPShapeDrawer : ObjectiveC.NSObject {
  @objc deinit
}
extension UnifiedVideoEditorSDK.PIPShapeDrawer : UnifiedVideoEditorSDK.PIPShapeable {
  public func set(shape: (any UnifiedVideoEditorSDK.PIPShape)?)
  public func set(shapeType: UnifiedVideoEditorSDK.PIPShapeBuilder.PIPShapeType)
}
public protocol KFOptionSetter {
  var options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo { get nonmutating set }
  var onFailureDelegate: UnifiedVideoEditorSDK.Delegate<UnifiedVideoEditorSDK.KingfisherError, Swift.Void> { get }
  var onSuccessDelegate: UnifiedVideoEditorSDK.Delegate<UnifiedVideoEditorSDK.RetrieveImageResult, Swift.Void> { get }
  var onProgressDelegate: UnifiedVideoEditorSDK.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> { get }
  var delegateObserver: Swift.AnyObject { get }
}
extension UnifiedVideoEditorSDK.KF.Builder : UnifiedVideoEditorSDK.KFOptionSetter {
  public var delegateObserver: Swift.AnyObject {
    get
  }
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func onProgress(_ block: UnifiedVideoEditorSDK.DownloadProgressBlock?) -> Self
  public func onSuccess(_ block: ((UnifiedVideoEditorSDK.RetrieveImageResult) -> Swift.Void)?) -> Self
  public func onFailure(_ block: ((UnifiedVideoEditorSDK.KingfisherError) -> Swift.Void)?) -> Self
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func targetCache(_ cache: UnifiedVideoEditorSDK.ImageCache) -> Self
  public func originalCache(_ cache: UnifiedVideoEditorSDK.ImageCache) -> Self
  public func downloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader) -> Self
  public func downloadPriority(_ priority: Swift.Float) -> Self
  public func forceRefresh(_ enabled: Swift.Bool = true) -> Self
  public func fromMemoryCacheOrRefresh(_ enabled: Swift.Bool = true) -> Self
  public func cacheMemoryOnly(_ enabled: Swift.Bool = true) -> Self
  public func waitForCache(_ enabled: Swift.Bool = true) -> Self
  public func onlyFromCache(_ enabled: Swift.Bool = true) -> Self
  public func backgroundDecode(_ enabled: Swift.Bool = true) -> Self
  public func callbackQueue(_ queue: UnifiedVideoEditorSDK.CallbackQueue) -> Self
  public func scaleFactor(_ factor: CoreFoundation.CGFloat) -> Self
  public func cacheOriginalImage(_ enabled: Swift.Bool = true) -> Self
  public func diskStoreWriteOptions(_ writingOptions: Foundation.Data.WritingOptions) -> Self
  public func loadDiskFileSynchronously(_ enabled: Swift.Bool = true) -> Self
  public func processingQueue(_ queue: UnifiedVideoEditorSDK.CallbackQueue?) -> Self
  public func alternativeSources(_ sources: [UnifiedVideoEditorSDK.Source]?) -> Self
  public func retry(_ strategy: (any UnifiedVideoEditorSDK.RetryStrategy)?) -> Self
  public func retry(maxCount: Swift.Int, interval: UnifiedVideoEditorSDK.DelayRetryStrategy.Interval = .seconds(3)) -> Self
  public func lowDataModeSource(_ source: UnifiedVideoEditorSDK.Source?) -> Self
  public func forceTransition(_ enabled: Swift.Bool = true) -> Self
  public func onFailureImage(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage?) -> Self
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func requestModifier(_ modifier: any UnifiedVideoEditorSDK.AsyncImageDownloadRequestModifier) -> Self
  public func requestModifier(_ modifyBlock: @escaping (inout Foundation.URLRequest) -> Swift.Void) -> Self
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func redirectHandler(_ handler: any UnifiedVideoEditorSDK.ImageDownloadRedirectHandler) -> Self
  public func redirectHandler(_ block: @escaping (UnifiedVideoEditorSDK.KF.RedirectPayload) -> Swift.Void) -> Self
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func setProcessor(_ processor: any UnifiedVideoEditorSDK.ImageProcessor) -> Self
  public func setProcessors(_ processors: [any UnifiedVideoEditorSDK.ImageProcessor]) -> Self
  public func appendProcessor(_ processor: any UnifiedVideoEditorSDK.ImageProcessor) -> Self
  public func roundCorner(radius: UnifiedVideoEditorSDK.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: UnifiedVideoEditorSDK.RectCorner = .all, backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor? = nil) -> Self
  public func blur(radius: CoreFoundation.CGFloat) -> Self
  public func overlay(color: UnifiedVideoEditorSDK.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5) -> Self
  public func tint(color: UnifiedVideoEditorSDK.KFCrossPlatformColor) -> Self
  public func blackWhite() -> Self
  public func cropping(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = .init(x: 0.5, y: 0.5)) -> Self
  public func downsampling(size: CoreFoundation.CGSize) -> Self
  public func resizing(referenceSize: CoreFoundation.CGSize, mode: UnifiedVideoEditorSDK.ContentMode = .none) -> Self
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func serialize(by cacheSerializer: any UnifiedVideoEditorSDK.CacheSerializer) -> Self
  public func serialize(as format: UnifiedVideoEditorSDK.ImageFormat, jpegCompressionQuality: CoreFoundation.CGFloat? = nil) -> Self
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func imageModifier(_ modifier: (any UnifiedVideoEditorSDK.ImageModifier)?) -> Self
  public func imageModifier(_ block: @escaping (inout UnifiedVideoEditorSDK.KFCrossPlatformImage) throws -> Swift.Void) -> Self
}
extension UnifiedVideoEditorSDK.KFOptionSetter {
  public func memoryCacheExpiration(_ expiration: UnifiedVideoEditorSDK.StorageExpiration?) -> Self
  public func memoryCacheAccessExtending(_ extending: UnifiedVideoEditorSDK.ExpirationExtending) -> Self
  public func diskCacheExpiration(_ expiration: UnifiedVideoEditorSDK.StorageExpiration?) -> Self
  public func diskCacheAccessExtending(_ extending: UnifiedVideoEditorSDK.ExpirationExtending) -> Self
}
public class EditorEffectModelBuilder {
  public init()
  public func gifModel(id: Swift.UInt, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  public func textModel(id: Swift.UInt, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  public func blurModel(id: Swift.UInt, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, rendererTexture: (any Metal.MTLTexture)?) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  public func makeModels(configs: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]], startId: Swift.UInt) -> [UnifiedVideoEditorSDK.VideoEditorFilterModel]
  public func makeModel(config: [UnifiedVideoEditorSDK.EditorEffectKey : Any], id: Swift.UInt) -> UnifiedVideoEditorSDK.VideoEditorFilterModel
  @objc deinit
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor? = nil) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func image(withRadius radius: UnifiedVideoEditorSDK.Radius, fit size: CoreFoundation.CGSize, roundingCorners corners: UnifiedVideoEditorSDK.RectCorner = .all, backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor? = nil) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func image(withRoundRadius radius: CoreFoundation.CGFloat, fit size: CoreFoundation.CGSize, roundingCorners corners: UnifiedVideoEditorSDK.RectCorner = .all, backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor? = nil) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func resize(to size: CoreFoundation.CGSize) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func resize(to targetSize: CoreFoundation.CGSize, for contentMode: UnifiedVideoEditorSDK.ContentMode) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func crop(to size: CoreFoundation.CGSize, anchorOn anchor: CoreFoundation.CGPoint) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func addingBorder(_ border: UnifiedVideoEditorSDK.Border) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func overlaying(with color: UnifiedVideoEditorSDK.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func tinted(with color: UnifiedVideoEditorSDK.KFCrossPlatformColor) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func adjusted(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func scaled(to scale: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public var decoded: UnifiedVideoEditorSDK.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
  public func decoded(on context: CoreGraphics.CGContext) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
public protocol PIPShape : AnyObject {
  var size: CoreFoundation.CGSize { get }
  var data: Swift.UnsafeMutablePointer<Swift.UInt8> { get }
}
public protocol PIPShapeable {
  func set(shape: (any UnifiedVideoEditorSDK.PIPShape)?)
  func set(shapeType: UnifiedVideoEditorSDK.PIPShapeBuilder.PIPShapeType)
}
@_hasMissingDesignatedInitializers public class PIPShapeBuilder {
  public enum PIPShapeType : Swift.Equatable {
    case none
    case oval
    case circle
    case roundRect(radius: CoreFoundation.CGFloat)
    case roundSquare(radius: CoreFoundation.CGFloat)
    public static func == (a: UnifiedVideoEditorSDK.PIPShapeBuilder.PIPShapeType, b: UnifiedVideoEditorSDK.PIPShapeBuilder.PIPShapeType) -> Swift.Bool
  }
  public static func buildShape(size: CoreFoundation.CGSize, path: CoreGraphics.CGPath) -> any UnifiedVideoEditorSDK.PIPShape
  @objc deinit
}
public struct RoundedButtonConfiguration {
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration?
  public var borderWidth: CoreFoundation.CGFloat?
  public var borderColor: CoreGraphics.CGColor?
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var titleSpacing: CoreFoundation.CGFloat?
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration?, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat? = nil, borderColor: CoreGraphics.CGColor? = nil, width: CoreFoundation.CGFloat = 70.0, height: CoreFoundation.CGFloat = 30.0, titleSpacing: CoreFoundation.CGFloat? = 2.0)
}
public struct AutoCutConfiguration {
  public var embeddingsDownloadUrl: Swift.String?
  public var musicApiSelectedTracksUrl: Swift.String?
  public init(embeddingsDownloadUrl: Swift.String?, musicApiSelectedTracksUrl: Swift.String?)
}
public enum DeviceModel : Swift.String {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPhoneSE2
  case iPhone12
  case iPhone12Mini
  case iPhone12Pro
  case iPhone12ProMax
  case iPhone13
  case iPhone13Mini
  case iPhone13Pro
  case iPhone13ProMax
  case iPhoneSE3
  case iPhone14
  case iPhone14Plus
  case iPhone14Pro
  case iPhone14ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPad8
  case iPad9
  case iPad10
  case iPadAir4
  case iPadAir5
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadMini6
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case iPadPro11Inch2
  case iPadPro12Inch4
  case iPadPro11Inch3
  case iPadPro12Inch5
  case iPadPro11Inch4
  case iPadPro12Inch6
  case simulator
  case unknown
  public static var current: UnifiedVideoEditorSDK.DeviceModel {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> UnifiedVideoEditorSDK.DeviceModel
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) public func addArrangedSubviews(_ subviews: [UIKit.UIView])
  @_Concurrency.MainActor(unsafe) public func removeAllArrangedSubviews()
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) public func addBackground(color: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat)
}
public enum ImageProcessItem {
  case image(UnifiedVideoEditorSDK.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor {
  var identifier: Swift.String { get }
  func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
extension UnifiedVideoEditorSDK.ImageProcessor {
  public func append(another: any UnifiedVideoEditorSDK.ImageProcessor) -> any UnifiedVideoEditorSDK.ImageProcessor
}
public struct DefaultImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public static let `default`: UnifiedVideoEditorSDK.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct RectCorner : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let topLeft: UnifiedVideoEditorSDK.RectCorner
  public static let topRight: UnifiedVideoEditorSDK.RectCorner
  public static let bottomLeft: UnifiedVideoEditorSDK.RectCorner
  public static let bottomRight: UnifiedVideoEditorSDK.RectCorner
  public static let all: UnifiedVideoEditorSDK.RectCorner
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = UnifiedVideoEditorSDK.RectCorner
  public typealias Element = UnifiedVideoEditorSDK.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreFoundation.CGFloat
  public let backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor?
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor? = nil)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public enum Radius {
  case widthFraction(CoreFoundation.CGFloat)
  case heightFraction(CoreFoundation.CGFloat)
  case point(CoreFoundation.CGFloat)
  public func compute(with size: CoreFoundation.CGSize) -> CoreFoundation.CGFloat
}
public struct RoundCornerImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let radius: UnifiedVideoEditorSDK.Radius
  public let roundingCorners: UnifiedVideoEditorSDK.RectCorner
  public let targetSize: CoreFoundation.CGSize?
  public let backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor?
  public init(cornerRadius: CoreFoundation.CGFloat, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: UnifiedVideoEditorSDK.RectCorner = .all, backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor? = nil)
  public init(radius: UnifiedVideoEditorSDK.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: UnifiedVideoEditorSDK.RectCorner = .all, backgroundColor: UnifiedVideoEditorSDK.KFCrossPlatformColor? = nil)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct Border {
  public var color: UnifiedVideoEditorSDK.KFCrossPlatformColor
  public var lineWidth: CoreFoundation.CGFloat
  public var radius: UnifiedVideoEditorSDK.Radius
  public var roundingCorners: UnifiedVideoEditorSDK.RectCorner
  public init(color: UnifiedVideoEditorSDK.KFCrossPlatformColor = .black, lineWidth: CoreFoundation.CGFloat = 4, radius: UnifiedVideoEditorSDK.Radius = .point(0), roundingCorners: UnifiedVideoEditorSDK.RectCorner = .all)
}
public struct BorderImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public var identifier: Swift.String {
    get
  }
  public let border: UnifiedVideoEditorSDK.Border
  public init(border: UnifiedVideoEditorSDK.Border)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public enum ContentMode {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: UnifiedVideoEditorSDK.ContentMode, b: UnifiedVideoEditorSDK.ContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ResizingImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreFoundation.CGSize
  public let targetContentMode: UnifiedVideoEditorSDK.ContentMode
  public init(referenceSize: CoreFoundation.CGSize, mode: UnifiedVideoEditorSDK.ContentMode = .none)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct BlurImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreFoundation.CGFloat
  public init(blurRadius: CoreFoundation.CGFloat)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct OverlayImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: UnifiedVideoEditorSDK.KFCrossPlatformColor
  public let fraction: CoreFoundation.CGFloat
  public init(overlay: UnifiedVideoEditorSDK.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct TintImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let tint: UnifiedVideoEditorSDK.KFCrossPlatformColor
  public init(tint: UnifiedVideoEditorSDK.KFCrossPlatformColor)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct ColorControlsProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreFoundation.CGFloat
  public let contrast: CoreFoundation.CGFloat
  public let saturation: CoreFoundation.CGFloat
  public let inputEV: CoreFoundation.CGFloat
  public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct BlackWhiteProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public init()
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct CroppingImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreFoundation.CGSize
  public let anchor: CoreFoundation.CGPoint
  public init(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5))
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct DownsamplingImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  public let size: CoreFoundation.CGSize
  public let identifier: Swift.String
  public init(size: CoreFoundation.CGSize)
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
infix operator |> : AdditionPrecedence
public func |> (left: any UnifiedVideoEditorSDK.ImageProcessor, right: any UnifiedVideoEditorSDK.ImageProcessor) -> any UnifiedVideoEditorSDK.ImageProcessor
public struct FormatIndicatedCacheSerializer : UnifiedVideoEditorSDK.CacheSerializer {
  public static let png: UnifiedVideoEditorSDK.FormatIndicatedCacheSerializer
  public static let jpeg: UnifiedVideoEditorSDK.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.FormatIndicatedCacheSerializer
  public static let gif: UnifiedVideoEditorSDK.FormatIndicatedCacheSerializer
  public func data(with image: UnifiedVideoEditorSDK.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
@_inheritsConvenienceInitializers public class RotateEffectDrawer : UnifiedVideoEditorSDK.VideoEditorEffectDrawer {
  required public init(rotation: UnifiedVideoEditorSDK.AssetRotation, isVideoFitsAspect: Swift.Bool)
  required public init()
  @objc deinit
}
extension UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.PlayerControlConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: any UnifiedVideoEditorSDK.ImageTextButtonConfigurationProtocol)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.BackButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.RoundedButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.RoundedButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.SaveButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.TextButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: UnifiedVideoEditorSDK.TextConfiguration?, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, forState controlState: UIKit.UIControl.State)
}
public enum AssetRotation : Swift.UInt8, Swift.Codable {
  case none
  case rotate90
  case rotate180
  case rotate270
  public init?(withAngle angle: CoreFoundation.CGFloat)
  public var angle: CoreFoundation.CGFloat {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func roundCorners(cornerMask: QuartzCore.CACornerMask, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func roundCorners(radius: CoreFoundation.CGFloat)
}
public enum StorageExpiration {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending {
  case none
  case cacheTime
  case expirationTime(_: UnifiedVideoEditorSDK.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class VideoEditorActivityIndicator : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func startAnimating()
  @_Concurrency.MainActor(unsafe) public func stopAnimating()
  @objc deinit
}
public protocol MusicEditorExternalViewControllerFactory : AnyObject {
  func makeTrackSelectionViewController(selectedAudioItem: (any UnifiedVideoEditorSDK.AudioItem)?) -> (any UnifiedVideoEditorSDK.TrackSelectionViewController)?
  func makeEffectSelectionViewController(selectedAudioItem: (any UnifiedVideoEditorSDK.AudioItem)?) -> (any UnifiedVideoEditorSDK.EffectSelectionViewController)?
  func makeRecorderCountdownAnimatableView() -> (any UnifiedVideoEditorSDK.MusicEditorCountdownAnimatableView)?
}
extension UnifiedVideoEditorSDK.MusicEditorExternalViewControllerFactory {
  public func makeTrackSelectionViewController() -> (any UnifiedVideoEditorSDK.TrackSelectionViewController)?
  public func makeEffectSelectionViewController() -> (any UnifiedVideoEditorSDK.EffectSelectionViewController)?
}
public protocol MusicEditorCountdownAnimatableView : UIKit.UIView {
  var countdownDigit: Swift.Int { get set }
  func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  func stop()
}
@_inheritsConvenienceInitializers public class BanubaMaskDrawer : UnifiedVideoEditorSDK.VideoEditorEffectDrawer {
  required public init()
  @objc deinit
}
public enum EditorEffectType : Swift.Int {
  case transition
  case blur
  case gif
  case text
  case time
  case color
  case visual
  case mask
  case transform
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol RenderEffect {
  @objc var name: Swift.String { get }
  @objc var isLoaded: Swift.Bool { get }
  @objc var isActive: Swift.Bool { get set }
  @objc func load()
  @objc func unload()
  @objc func apply(pixelBuffer: CoreVideo.CVPixelBuffer)
}
public struct MediaTrackTimeRange : Swift.Codable {
  public let startTime: CoreMedia.CMTime
  public let playingTimeRange: CoreMedia.CMTimeRange
  public init(startTime: CoreMedia.CMTime, playingTimeRange: CoreMedia.CMTimeRange)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public class MediaTrack : Swift.Codable {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var timeRange: UnifiedVideoEditorSDK.MediaTrackTimeRange
  final public let title: Swift.String?
  final public let additionalTitle: Swift.String?
  final public let isEditable: Swift.Bool
  public var id: CoreMedia.CMPersistentTrackID?
  public init(uuid: Foundation.UUID, id: CoreMedia.CMPersistentTrackID?, url: Foundation.URL, coverURL: Foundation.URL?, timeRange: UnifiedVideoEditorSDK.MediaTrackTimeRange, isEditable: Swift.Bool, title: Swift.String? = nil, additionalTitle: Swift.String? = nil)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
public protocol ReusableView : AnyObject {
}
extension UnifiedVideoEditorSDK.ReusableView {
  public static var reuseIdentifier: Swift.String {
    get
  }
}
@objc public class MaskPostprocessingService : ObjectiveC.NSObject {
  @objc public init(renderSize: CoreFoundation.CGSize)
  @objc deinit
}
extension UnifiedVideoEditorSDK.MaskPostprocessingService : UnifiedVideoEditorSDK.SDKMaskPostprocessServicing {
  @objc dynamic public func processVideoFrame(_ from: CoreVideo.CVPixelBuffer, to: CoreVideo.CVPixelBuffer, time: CoreMedia.CMTime)
  @objc dynamic public func surfaceCreated(with size: CoreFoundation.CGSize)
  @objc dynamic public func setEffectSize(_ size: CoreFoundation.CGSize)
  @objc dynamic public func loadEffect(path: Swift.String)
}
public struct AutoCutGalleryConfiguration {
  public let normalApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration
  public let disabledApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration
  public let normalNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration
  public let disabledNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration
  public let maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval
  public init(normalApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration, disabledApplyAutoCutButtonConfiguration: UnifiedVideoEditorSDK.ApplyAutoCutButtonConfiguration, normalNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration, disabledNextButtonConfiguration: UnifiedVideoEditorSDK.GalleryNextButtonConfiguration, maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval)
}
public struct ApplyAutoCutButtonConfiguration {
  public let borderColor: UIKit.UIColor
  public let iconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public let textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public init(borderColor: UIKit.UIColor, iconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, textConfiguration: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct GalleryNextButtonConfiguration {
  public let textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public let backgroundColor: UIKit.UIColor
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, backgroundColor: UIKit.UIColor)
}
extension Swift.Encodable {
  public func toDictionary(_ encoder: Foundation.JSONEncoder = JSONEncoder()) throws -> [Swift.String : Any]
  public func toString() throws -> Swift.String
}
public class Delegate<Input, Output> {
  public init()
  public func delegate<T>(on target: T, block: ((T, Input) -> Output)?) where T : AnyObject
  public func call(_ input: Input) -> Output?
  public func callAsFunction(_ input: Input) -> Output?
  @objc deinit
}
extension UnifiedVideoEditorSDK.Delegate where Input == () {
  public func call() -> Output?
  public func callAsFunction() -> Output?
}
extension UnifiedVideoEditorSDK.Delegate where Input == (), Output : UnifiedVideoEditorSDK.OptionalProtocol {
  public func call() -> Output
  public func callAsFunction() -> Output
}
extension UnifiedVideoEditorSDK.Delegate where Output : UnifiedVideoEditorSDK.OptionalProtocol {
  public func call(_ input: Input) -> Output
  public func callAsFunction(_ input: Input) -> Output
}
public protocol OptionalProtocol {
  static var _createNil: Self { get }
}
extension Swift.Optional : UnifiedVideoEditorSDK.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
public class ToastPresenter {
  public init(configuration: UnifiedVideoEditorSDK.ToastConfiguration, toastLifeTime: Foundation.TimeInterval? = nil)
  @objc deinit
  public func showToast(message: Swift.String)
}
public struct PIPSwitchCellConfiguration {
  public var identifier: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting
  public var selectedIdentifier: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: CoreGraphics.CGColor
  public var cornerRadius: CoreFoundation.CGFloat?
  public var backgroundColor: UIKit.UIColor
  public init(identifier: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting, selectedIdentifier: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting, textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, borderWidth: CoreFoundation.CGFloat, borderColor: CoreGraphics.CGColor, cornerRadius: CoreFoundation.CGFloat?, backgroundColor: UIKit.UIColor)
}
public struct PIPCameraCellConfiguration {
  public var identifier: UnifiedVideoEditorSDK.PIPCameraLayoutSetting
  public var selectedIdentifier: UnifiedVideoEditorSDK.PIPCameraLayoutSetting
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var selectedTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: CoreGraphics.CGColor
  public var cornerRadius: CoreFoundation.CGFloat?
  public var backgroundColor: UIKit.UIColor
  public init(identifier: UnifiedVideoEditorSDK.PIPCameraLayoutSetting, selectedIdentifier: UnifiedVideoEditorSDK.PIPCameraLayoutSetting, textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, selectedTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration, imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, borderWidth: CoreFoundation.CGFloat, borderColor: CoreGraphics.CGColor, cornerRadius: CoreFoundation.CGFloat?, backgroundColor: UIKit.UIColor)
}
public struct PIPSelectableCellConfiguration {
  public var identifier: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting
  public var switchCellConfiguration: UnifiedVideoEditorSDK.PIPSwitchCellConfiguration?
  public var cameraCellConfiguration: UnifiedVideoEditorSDK.PIPCameraCellConfiguration
  public var croppingCellConfiguration: UnifiedVideoEditorSDK.PIPCameraCellConfiguration?
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var borderWidth: CoreFoundation.CGFloat
  public var selectedBorderColor: CoreGraphics.CGColor
  public var deselectedBorderColor: CoreGraphics.CGColor
  public var isRoundedImageView: Swift.Bool
  public var cornerRadius: CoreFoundation.CGFloat?
  public var backgroundColor: UIKit.UIColor
  public init(identifier: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, switchCellConfiguration: UnifiedVideoEditorSDK.PIPSwitchCellConfiguration?, croppingCellConfiguration: UnifiedVideoEditorSDK.PIPCameraCellConfiguration? = nil, cameraCellConfiguration: UnifiedVideoEditorSDK.PIPCameraCellConfiguration, textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, borderWidth: CoreFoundation.CGFloat, selectedBorderColor: CoreGraphics.CGColor, deselectedBorderColor: CoreGraphics.CGColor, isRoundedImageView: Swift.Bool, cornerRadius: CoreFoundation.CGFloat?, backgroundColor: UIKit.UIColor)
}
public struct SpeedBarButtonsConfiguration {
  public var imageHalf: UnifiedVideoEditorSDK.ImageConfiguration?
  public var imageNormal: UnifiedVideoEditorSDK.ImageConfiguration?
  public var imageDouble: UnifiedVideoEditorSDK.ImageConfiguration?
  public var imageTriple: UnifiedVideoEditorSDK.ImageConfiguration?
  public var selectedTitleColor: UIKit.UIColor
  public var titleColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat?
  public init(imageHalf: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageNormal: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageDouble: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageTriple: UnifiedVideoEditorSDK.ImageConfiguration? = nil, selectedTitleColor: UIKit.UIColor, titleColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat?)
}
public struct AdditionalEffectsButtonConfiguration {
  public enum Position : Swift.Int {
    case top
    case bottom
    case center
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var identifier: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType
  public var imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
  public var selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?
  public var title: UnifiedVideoEditorSDK.TextButtonConfiguration?
  public var titlePosition: UnifiedVideoEditorSDK.TitlePosition?
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var position: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position?
  public var imageTitleSpacing: CoreFoundation.CGFloat?
  public var defaultTitleAlpha: CoreFoundation.CGFloat?
  public var selectedTitleAlpha: CoreFoundation.CGFloat?
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var contentInsets: CoreFoundation.CGFloat
  public init(identifier: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType, imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?, title: UnifiedVideoEditorSDK.TextButtonConfiguration? = nil, titlePosition: UnifiedVideoEditorSDK.TitlePosition? = nil, width: CoreFoundation.CGFloat = 50, height: CoreFoundation.CGFloat = 50, position: UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position? = nil, imageTitleSpacing: CoreFoundation.CGFloat? = nil, defaultTitleAlpha: CoreFoundation.CGFloat? = nil, selectedTitleAlpha: CoreFoundation.CGFloat? = nil, cornerRadius: CoreFoundation.CGFloat = .zero, backgroundColor: UIKit.UIColor = .clear, contentInsets: CoreFoundation.CGFloat = 8.5)
  public enum ButtonType : Swift.String {
    case link
    case color
    case sticker
    case text
    case time
    case sound
    case effects
    case toggle
    case flashlight
    case timer
    case speed
    case beauty
    case masks
    case muteSound
    case pip
    case blur
    case trimDraft
    case captions
    case autoCut
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum TitlePosition {
  case top
  case left
  case right
  case bottom
  public static func == (a: UnifiedVideoEditorSDK.TitlePosition, b: UnifiedVideoEditorSDK.TitlePosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol RecordButtonProvider {
  func getButton() -> any UnifiedVideoEditorSDK.RecordButton
}
@objc public enum DraftsFeatureConfig : Swift.Int, Swift.CaseIterable {
  case enabled = 0
  case enabledSaveToDraftsByDefault = 1
  case disabled = 2
  case enabledAskIfSaveNotExport = 3
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UnifiedVideoEditorSDK.DraftsFeatureConfig]
  public typealias RawValue = Swift.Int
  public static var allCases: [UnifiedVideoEditorSDK.DraftsFeatureConfig] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public struct FeatureConfiguration {
  public var isBlurEnabled: Swift.Bool
  public var isBlurEffectsExportable: Swift.Bool
  public var isOverlayEditorEnabled: Swift.Bool
  public var isDoubleTapForToggleCameraEnabled: Swift.Bool
  public var isMuteCameraAudioEnabled: Swift.Bool
  public var isVideoCoverSelectionEnabled: Swift.Bool
  public var supportsTrimRecordedVideo: Swift.Bool
  public var draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig
  public var isAspectsEnabled: Swift.Bool
  public var isSpeedBarEnabled: Swift.Bool
  public var isVideoFitsAspect: Swift.Bool
  public var openAutomaticallyPIPSettingsDropdown: Swift.Bool
  public var useTransitions: Swift.Bool
  public var isDraftSavedToastEnabled: Swift.Bool
  public static let `default`: UnifiedVideoEditorSDK.FeatureConfiguration
  public init(isOverlayEditorEnabled: Swift.Bool, isDoubleTapForToggleCameraEnabled: Swift.Bool, isMuteCameraAudioEnabled: Swift.Bool, isVideoCoverSelectionEnabled: Swift.Bool, supportsTrimRecordedVideo: Swift.Bool, draftsConfig: UnifiedVideoEditorSDK.DraftsFeatureConfig, isAspectsEnabled: Swift.Bool, isSpeedBarEnabled: Swift.Bool, isVideoFitsAspect: Swift.Bool, isBlurEnabled: Swift.Bool, isBlurEffectsExportable: Swift.Bool, openAutomaticallyPIPSettingsDropdown: Swift.Bool, useTransitions: Swift.Bool, isDraftSavedToastEnabled: Swift.Bool)
}
public struct RecorderEffectsConfiguration {
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var effectsHeight: CoreFoundation.CGFloat
  public var effectItemConfiguration: UnifiedVideoEditorSDK.EffectItemConfiguration
  public var effectAdditionalMediaPickerConfiguration: UnifiedVideoEditorSDK.EffectAdditionalMediaPickerConfiguration
  public var preferredLutsOrder: [Swift.String]
  public var preferredMasksOrder: [Swift.String]
  public init(cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, effectsHeight: CoreFoundation.CGFloat, effectItemConfiguration: UnifiedVideoEditorSDK.EffectItemConfiguration, effectAdditionalMediaPickerConfiguration: UnifiedVideoEditorSDK.EffectAdditionalMediaPickerConfiguration, preferredLutsOrder: [Swift.String], preferredMasksOrder: [Swift.String])
}
public struct EffectAdditionalMediaPickerConfiguration {
  public var galleryAssetItemConfiguration: UnifiedVideoEditorSDK.GalleryAssetItemConfiguration
  public var infoLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var allowGalleryAccessButtonConfiguration: UnifiedVideoEditorSDK.BanubaButtonConfiguration
  public var noMediaLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var openGalleryButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public init(galleryAssetItemConfiguration: UnifiedVideoEditorSDK.GalleryAssetItemConfiguration, infoLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, allowGalleryAccessButtonConfiguration: UnifiedVideoEditorSDK.BanubaButtonConfiguration, noMediaLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, openGalleryButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration)
}
public struct GalleryAssetItemConfiguration {
  public var durationConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var cornerRadius: CoreFoundation.CGFloat
  public var selectionColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var normalImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var activityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
}
public struct MusicPanelConfiguration {
  public var floatingLineViewConfiguration: UnifiedVideoEditorSDK.TextConfiguration?
  public var floatingLineViewWidth: CoreFoundation.CGFloat?
  public var backroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration?
  public var removeMusicButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var musicPanelImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration
}
public struct TimerConfiguration {
  public struct TimerOptionConfiguration : Swift.Equatable {
    public var button: UnifiedVideoEditorSDK.ImageButtonConfiguration
    public var startingTimerSeconds: Swift.Int
    public var stoppingTimerSeconds: Swift.Int
    public var description: Swift.String?
    public static func == (lhs: UnifiedVideoEditorSDK.TimerConfiguration.TimerOptionConfiguration, rhs: UnifiedVideoEditorSDK.TimerConfiguration.TimerOptionConfiguration) -> Swift.Bool
    public init(button: UnifiedVideoEditorSDK.ImageButtonConfiguration, startingTimerSeconds: Swift.Int, stoppingTimerSeconds: Swift.Int, description: Swift.String? = nil)
  }
  public var defaultButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var options: [UnifiedVideoEditorSDK.TimerConfiguration.TimerOptionConfiguration]
  public var soundPath: Swift.String?
}
public struct GalleryVideoPartsConfiguration {
  public var addGalleryVideoPartImageName: Swift.String
  public var videoPartConfiguration: UnifiedVideoEditorSDK.GalleryVideoPartsConfiguration.GalleryVideoPartConfiguration
  public init(addGalleryVideoPartImageName: Swift.String, videoPartConfiguration: UnifiedVideoEditorSDK.GalleryVideoPartsConfiguration.GalleryVideoPartConfiguration)
  public struct GalleryVideoPartConfiguration {
    public var selectionColor: UIKit.UIColor
    public var durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
    public var cornerRadius: CoreFoundation.CGFloat
    public var imageCornerRadius: CoreFoundation.CGFloat
    public var imageInsets: UIKit.UIEdgeInsets
    public var scissorsImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?
    public init(selectionColor: UIKit.UIColor, durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, cornerRadius: CoreFoundation.CGFloat, imageCornerRadius: CoreFoundation.CGFloat, imageInsets: UIKit.UIEdgeInsets, scissorsImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?)
  }
}
public struct EffectItemConfiguration {
  public var noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var titleStyle: UnifiedVideoEditorSDK.TextConfiguration
  public var defaultStateTitleAlpha: CoreFoundation.CGFloat
  public var selectionColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var borderWidth: CoreFoundation.CGFloat
  public var selectWhenHighlight: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var imageInsets: UIKit.UIEdgeInsets
  public var imageCornerRadius: CoreFoundation.CGFloat
  public var imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration?
  public var alwaysShowTitle: Swift.Bool
  public var showMasksTitle: Swift.Bool
  public var showEffectsTitle: Swift.Bool
  public var downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration?
  public var progressViewFactory: (any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory)?
  public init(noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration, titleStyle: UnifiedVideoEditorSDK.TextConfiguration, defaultStateTitleAlpha: CoreFoundation.CGFloat, selectionColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, borderWidth: CoreFoundation.CGFloat, selectWhenHighlight: Swift.Bool, backgroundColor: UIKit.UIColor, imageInsets: UIKit.UIEdgeInsets, imageCornerRadius: CoreFoundation.CGFloat, imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration? = nil, alwaysShowTitle: Swift.Bool, showMasksTitle: Swift.Bool, showEffectsTitle: Swift.Bool, downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration? = nil, progressViewFactory: (any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory)? = nil)
}
public struct BanubaButtonConfiguration {
  public var imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration?
  public var title: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var titlePosition: UnifiedVideoEditorSDK.TitlePosition
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var background: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var imageTitleSpacing: CoreFoundation.CGFloat
  public init(title: UnifiedVideoEditorSDK.TextButtonConfiguration, titlePosition: UnifiedVideoEditorSDK.TitlePosition = .bottom, width: CoreFoundation.CGFloat = 50, height: CoreFoundation.CGFloat = 50, background: UnifiedVideoEditorSDK.BackgroundConfiguration, imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil, imageTitleSpacing: CoreFoundation.CGFloat = 0.0)
}
public struct TimeLabelConfiguration {
  public var textInsets: UIKit.UIEdgeInsets
  public var cornerRadius: CoreFoundation.CGFloat
  public var defaultColor: UIKit.UIColor
  public var errorColor: UIKit.UIColor
  public var style: UnifiedVideoEditorSDK.TextConfiguration
  public init(textInsets: UIKit.UIEdgeInsets, cornerRadius: CoreFoundation.CGFloat, defaultColor: UIKit.UIColor, errorColor: UIKit.UIColor, style: UnifiedVideoEditorSDK.TextConfiguration)
}
public struct VideoCoverSelectionConfiguration {
  public var cancelButton: UnifiedVideoEditorSDK.BanubaButtonConfiguration
  public var doneButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var titleLabel: UnifiedVideoEditorSDK.TextConfiguration?
  public var toolTipLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var selectGalleryImageButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration
  public var deleteGalleryImageConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var previewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var thumbnailsCursorConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var numberOfThumbnails: Swift.Int
  public var galleryImageCompressionQuality: CoreFoundation.CGFloat
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var isGalleryButtonHidden: Swift.Bool
  public var bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var timelineCornerRadius: CoreFoundation.CGFloat
  public init(cancelButton: UnifiedVideoEditorSDK.BanubaButtonConfiguration, doneButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration, titleLabel: UnifiedVideoEditorSDK.TextConfiguration?, toolTipLabel: UnifiedVideoEditorSDK.TextConfiguration, selectGalleryImageButton: UnifiedVideoEditorSDK.RoundedButtonConfiguration, deleteGalleryImageConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, previewBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, thumbnailsCursorConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration, numberOfThumbnails: Swift.Int, galleryImageCompressionQuality: CoreFoundation.CGFloat, preferredStatusBarStyle: UIKit.UIStatusBarStyle, isGalleryButtonHidden: Swift.Bool, bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, timelineCornerRadius: CoreFoundation.CGFloat)
}
public struct FilterControlButtonConfig {
  public enum `Type` : Swift.String {
    case cancel
    case play
    case done
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type`
  public let imageName: Swift.String
  public let selectedImageName: Swift.String?
  public let imageEdgeInsets: UIKit.UIEdgeInsets?
  public var tintColor: UIKit.UIColor?
  public var image: UIKit.UIImage?
  public var selectedImage: UIKit.UIImage?
  public init(type: UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type`, imageName: Swift.String, selectedImageName: Swift.String?, imageEdgeInsets: UIKit.UIEdgeInsets? = nil, tintColor: UIKit.UIColor? = nil)
}
@objc public class ImageConfiguration : ObjectiveC.NSObject, UnifiedVideoEditorSDK.ImageConfigurationProtocol {
  public var imageName: Swift.String
  @objc public var tintColor: UIKit.UIColor?
  @objc public var image: UIKit.UIImage? {
    @objc get
  }
  public init(imageName: Swift.String, tintColor: UIKit.UIColor? = nil)
  public init(image: UIKit.UIImage, tintColor: UIKit.UIColor? = nil)
  @objc deinit
}
public struct ImageButtonConfiguration : UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol {
  public var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public init(imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration, selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil)
  public mutating func setTintColor(_ tintColor: UIKit.UIColor)
}
public struct ImageTextButtonConfiguration : UnifiedVideoEditorSDK.ImageTextButtonConfigurationProtocol {
  public var imageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public var style: UnifiedVideoEditorSDK.TextConfiguration?
  public init(imageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil, selectedImageConfiguration: UnifiedVideoEditorSDK.ImageConfiguration? = nil, style: UnifiedVideoEditorSDK.TextConfiguration? = nil)
  public mutating func setTintColor(_ tintColor: UIKit.UIColor)
}
public struct DraftsConfiguration {
  public var backButton: UnifiedVideoEditorSDK.BackButtonConfiguration
  public var title: UnifiedVideoEditorSDK.TextConfiguration
  public var draftItem: UnifiedVideoEditorSDK.DraftItemConfiguration
  public var backgroundColor: UIKit.UIColor
  public var emptyDraftsImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var emptyDraftsLabel: UnifiedVideoEditorSDK.TextConfiguration
}
public struct ActionMenuConfiguration {
  public var dragIndicatorColor: UIKit.UIColor
  public var bacgroundViewCornerRadius: CoreFoundation.CGFloat
  public var previewImageViewCornerRadius: CoreFoundation.CGFloat
}
public struct DraftItemConfiguration {
  public var infoLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var subinfoLabel: UnifiedVideoEditorSDK.TextConfiguration
  public var menuButtonImage: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var menuButtonBackgroundColor: UIKit.UIColor
  public var menuButtonImageEdgeInsets: UIKit.UIEdgeInsets
  public var cornerRadius: CoreFoundation.CGFloat
  public var menuItems: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType]
  public init(infoLabel: UnifiedVideoEditorSDK.TextConfiguration, subinfoLabel: UnifiedVideoEditorSDK.TextConfiguration, menuButtonImage: UnifiedVideoEditorSDK.ImageButtonConfiguration, menuButtonBackgroundColor: UIKit.UIColor, menuButtonImageEdgeInsets: UIKit.UIEdgeInsets, cornerRadius: CoreFoundation.CGFloat, menuItems: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType])
}
public enum DraftMenuItemType {
  case edite
  case remove
  public static func == (a: UnifiedVideoEditorSDK.DraftMenuItemType, b: UnifiedVideoEditorSDK.DraftMenuItemType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct DraftMenuItem {
  public var type: UnifiedVideoEditorSDK.DraftMenuItemType
  public var name: UnifiedVideoEditorSDK.TextConfiguration
  public var image: UnifiedVideoEditorSDK.ImageConfiguration?
  public init(type: UnifiedVideoEditorSDK.DraftMenuItemType, name: UnifiedVideoEditorSDK.TextConfiguration, image: UnifiedVideoEditorSDK.ImageConfiguration?)
}
public struct EffectListItemConfiguration {
  public enum `Type` : Swift.Equatable {
    case aspect(UnifiedVideoEditorSDK.AspectRatio)
    case transition(UnifiedVideoEditorSDK.TransitionType)
    public static func == (a: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, b: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`) -> Swift.Bool
  }
  public var effect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`
  public var icon: UnifiedVideoEditorSDK.ImageConfiguration?
  public var title: UnifiedVideoEditorSDK.TextConfiguration
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var selectedColor: UIKit.UIColor
  public init(effect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, icon: UnifiedVideoEditorSDK.ImageConfiguration?, title: UnifiedVideoEditorSDK.TextConfiguration, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, selectedColor: UIKit.UIColor)
}
public struct EffectsListConfiguration {
  public var cancelButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var doneButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var playPauseButton: UnifiedVideoEditorSDK.PlayerControlConfiguration?
  public var backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var backgroundControlsViewColor: UIKit.UIColor
  public var effects: [UnifiedVideoEditorSDK.EffectListItemConfiguration]
  public var defaultEffect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`
  public var primaryAspect: UnifiedVideoEditorSDK.AspectRatio?
  public init(cancelButton: UnifiedVideoEditorSDK.ImageButtonConfiguration, doneButton: UnifiedVideoEditorSDK.ImageButtonConfiguration, playPauseButton: UnifiedVideoEditorSDK.PlayerControlConfiguration?, backgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, backgroundControlsViewColor: UIKit.UIColor, effects: [UnifiedVideoEditorSDK.EffectListItemConfiguration], defaultEffect: UnifiedVideoEditorSDK.EffectListItemConfiguration.`Type`, primaryAspect: UnifiedVideoEditorSDK.AspectRatio? = nil)
}
public struct VideoOverlayItemViewConfiguration {
  public var scaleIconWidth: CoreFoundation.CGFloat
  public var scaleIconHeight: CoreFoundation.CGFloat
  public var overlaySelectedBorderWidth: CoreFoundation.CGFloat
  public var overlaySelectedBorderColor: CoreGraphics.CGColor
  public var scaleIconImageName: Swift.String
  public var blurItemMinSize: CoreFoundation.CGSize
  public init(scaleIconWidth: CoreFoundation.CGFloat, scaleIconHeight: CoreFoundation.CGFloat, overlaySelectedBorderWidth: CoreFoundation.CGFloat, overlaySelectedBorderColor: CoreGraphics.CGColor, scaleIconImageName: Swift.String, blurItemMinSize: CoreFoundation.CGSize)
}
public struct VideoEditorEffectItemConfiguration {
  public var noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var defaultTitleStyle: UnifiedVideoEditorSDK.TextConfiguration
  public var selectedTitleStyle: UnifiedVideoEditorSDK.TextConfiguration
  public var selectionColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration?
  public var downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration?
  public var progressViewFactory: any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory
  public init(noEffectImage: UnifiedVideoEditorSDK.ImageConfiguration, defaultTitleStyle: UnifiedVideoEditorSDK.TextConfiguration, selectedTitleStyle: UnifiedVideoEditorSDK.TextConfiguration, selectionColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, imagePlaceholder: UnifiedVideoEditorSDK.ImageConfiguration? = nil, downloadIcon: UnifiedVideoEditorSDK.ImageConfiguration? = nil, progressViewFactory: any UnifiedVideoEditorSDK.ProgressAnimatableViewFactory = CircularProgressViewFactory())
}
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : UnifiedVideoEditorSDK.ImageProcessor {
  var filter: UnifiedVideoEditorSDK.Filter { get }
}
extension UnifiedVideoEditorSDK.CIImageProcessor {
  public func process(item: UnifiedVideoEditorSDK.ImageProcessItem, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public struct Filter {
  public init(transform: @escaping UnifiedVideoEditorSDK.Transformer)
  public static var tint: (_ color: UnifiedVideoEditorSDK.KFCrossPlatformColor) -> UnifiedVideoEditorSDK.Filter
  public typealias ColorElement = (CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat)
  public static var colorControl: (_ arg: UnifiedVideoEditorSDK.Filter.ColorElement) -> UnifiedVideoEditorSDK.Filter
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public func apply(_ filter: UnifiedVideoEditorSDK.Filter) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
@objc @_inheritsConvenienceInitializers public class VideoImageEffectDrawersFactory : ObjectiveC.NSObject {
  public static let normalDrawer: any UnifiedVideoEditorSDK.VideoImageEffectDrawable
  public static func drawer(for image: CoreGraphics.CGImage) -> any UnifiedVideoEditorSDK.VideoImageEffectDrawable
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class AlertViewController : UIKit.UIViewController, UnifiedVideoEditorSDK.NibLoadable {
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var contextView: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var backgroundView: UIKit.UIView!
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  public enum AlertType {
    case info
    case selection(_: Swift.String?, _: Swift.String?)
    case reset(_: Swift.String?, _: Swift.String?, _: Swift.String?)
    case missedPermission
    case recordingWithoutMask
  }
  public enum ButtonType {
    case agreeButton
    case refuseButton
    case additionalButton
    public static func == (a: UnifiedVideoEditorSDK.AlertViewController.ButtonType, b: UnifiedVideoEditorSDK.AlertViewController.ButtonType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var titleText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var messageText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var alertType: UnifiedVideoEditorSDK.AlertViewController.AlertType? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.AlertViewConfiguration?
  @_Concurrency.MainActor(unsafe) public var actionHandler: ((Swift.Bool, UnifiedVideoEditorSDK.AlertViewController.ButtonType) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class AutoCutEffectsStack {
  final public var isEmpty: Swift.Bool {
    get
  }
  final public func addEffect(_ effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
  final public func getAllEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  final public func getAllEffects() -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
public struct ImageLoadingResult {
  public let image: UnifiedVideoEditorSDK.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
}
public struct DownloadTask {
  public let sessionTask: UnifiedVideoEditorSDK.SessionDataTask
  public let cancelToken: UnifiedVideoEditorSDK.SessionDataTask.CancelToken
  public func cancel()
}
open class ImageDownloader {
  public static let `default`: UnifiedVideoEditorSDK.ImageDownloader
  open var downloadTimeout: Swift.Double
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var sessionDelegate: UnifiedVideoEditorSDK.SessionDelegate {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: (any UnifiedVideoEditorSDK.ImageDownloaderDelegate)?
  weak open var authenticationChallengeResponder: (any UnifiedVideoEditorSDK.AuthenticationChallengeResponsible)?
  public init(name: Swift.String)
  @objc deinit
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.ImageLoadingResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.ImageLoadingResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.ImageLoadingResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
}
extension UnifiedVideoEditorSDK.ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension UnifiedVideoEditorSDK.ImageDownloader : UnifiedVideoEditorSDK.AuthenticationChallengeResponsible {
}
extension UnifiedVideoEditorSDK.ImageDownloader : UnifiedVideoEditorSDK.ImageDownloaderDelegate {
}
extension Swift.Double {
  public func rounded(toPlaces places: Swift.Int, rule: Swift.FloatingPointRoundingRule? = nil) -> Swift.Double
}
extension Swift.CaseIterable where Self : Swift.Equatable {
  public var next: Self {
    get
  }
}
@objc public protocol AREffect {
  @objc var title: Swift.String { get }
  @objc var previewImage: Foundation.URL { get }
  @objc var downloadLink: Foundation.URL { get }
  @objc var isDownloaded: Swift.Bool { get }
  @objc var localURL: Foundation.URL? { get set }
  @objc var type: Swift.String? { get }
}
public protocol EffectsApplicatorServicing : AnyObject {
  var blurApplicatorService: any UnifiedVideoEditorSDK.BlurApplicatorServicing { get }
  init(editor: any UnifiedVideoEditorSDK.VideoEditorServicing, effectConfigHolder: any UnifiedVideoEditorSDK.EffectsHolderServicing)
  func applyVisualEffectApplicatorType(_ type: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
  func applyAutoCutVisualEffect(applicatorType: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, effectId: Swift.UInt)
  func applySpeedEffectType(_ type: UnifiedVideoEditorSDK.SpeedEffectType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
  func applyOverlayEffectType(_ type: UnifiedVideoEditorSDK.OverlayEffectApplicatorType, effectInfo: UnifiedVideoEditorSDK.VideoEditorEffectInfo)
  func addTransformEffect(atStartTime start: CoreMedia.CMTime, end: CoreMedia.CMTime, rotation: UnifiedVideoEditorSDK.AssetRotation, isVideoFitsAspect: Swift.Bool)
  func applyTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, effectInfo: UnifiedVideoEditorSDK.TransitionEffectInfo)
  func applyAutoCutTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
}
public class EffectApplicator : UnifiedVideoEditorSDK.EffectsApplicatorServicing {
  final public let blurApplicatorService: any UnifiedVideoEditorSDK.BlurApplicatorServicing
  required public init(editor: any UnifiedVideoEditorSDK.VideoEditorServicing, effectConfigHolder: any UnifiedVideoEditorSDK.EffectsHolderServicing)
  @objc deinit
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyVisualEffectApplicatorType(_ type: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
  public func applyAutoCutVisualEffect(applicatorType: UnifiedVideoEditorSDK.VisualEffectApplicatorType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, effectId: Swift.UInt)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applySpeedEffectType(_ type: UnifiedVideoEditorSDK.SpeedEffectType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyOverlayEffectType(_ type: UnifiedVideoEditorSDK.OverlayEffectApplicatorType, effectInfo: UnifiedVideoEditorSDK.VideoEditorEffectInfo)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyColorEffect(name: Swift.String, lutUrl: Foundation.URL, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime, removeSameType: Swift.Bool, effectId: Swift.UInt)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func addTransformEffect(atStartTime start: CoreMedia.CMTime, end: CoreMedia.CMTime, rotation: UnifiedVideoEditorSDK.AssetRotation, isVideoFitsAspect: Swift.Bool)
}
extension UnifiedVideoEditorSDK.EffectApplicator {
  public func applyTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, effectInfo: UnifiedVideoEditorSDK.TransitionEffectInfo)
  public func applyAutoCutTransitionEffect(type: UnifiedVideoEditorSDK.TransitionType, startTime: CoreMedia.CMTime, endTime: CoreMedia.CMTime)
}
public protocol NibLoadable : AnyObject {
  static var nib: UIKit.UINib { get }
}
extension UnifiedVideoEditorSDK.NibLoadable {
  public static var nib: UIKit.UINib {
    get
  }
}
extension UnifiedVideoEditorSDK.NibLoadable where Self : UIKit.UIView {
  public static func loadFromNib() -> Self
}
@_inheritsConvenienceInitializers public class ColorEffectDrawer : UnifiedVideoEditorSDK.VideoEditorEffectDrawer {
  required public init()
  @objc deinit
}
public protocol VideoEditorImageAssetProtocol : AnyObject {
  var duration: Foundation.TimeInterval { get }
  var image: CoreGraphics.CGImage? { get }
  var shouldUseImageEffect: Swift.Bool { get }
  func getOrPreloadImage() -> CoreGraphics.CGImage?
  func unloadImage()
}
public class VideoEditorFilterModel {
  public var id: Swift.UInt {
    get
  }
  public var tokenId: Swift.String {
    get
  }
  final public let filterType: UnifiedVideoEditorSDK.EditorEffectType
  final public let name: Swift.String
  final public let path: Swift.String
  final public let contentLocationType: UnifiedVideoEditorSDK.ContentLocationType
  public var preview: Foundation.URL?
  public var additionalParameters: [Swift.String : Any]?
  public var rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)? {
    get
  }
  convenience public init(name: Swift.String, type: UnifiedVideoEditorSDK.EditorEffectType, contentLocationType: UnifiedVideoEditorSDK.ContentLocationType = .local, renderer: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)?, path: Swift.String = "", id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, preview: Foundation.URL? = nil, additionalParameters: [Swift.String : Any]?)
  public init(name: Swift.String, type: UnifiedVideoEditorSDK.EditorEffectType, contentLocationType: UnifiedVideoEditorSDK.ContentLocationType = .local, renderer: (any UnifiedVideoEditorSDK.CompositionRenderering.Type)?, path: Swift.String = "", speed: UnifiedVideoEditorSDK.EffectSpeed = .normal, transition: UnifiedVideoEditorSDK.TransitionType = .normal, id: Swift.UInt, tokenId: Swift.String, rendererInstance: (any UnifiedVideoEditorSDK.CompositionRenderering)?, preview: Foundation.URL? = nil, additionalParameters: [Swift.String : Any]?)
  @objc deinit
}
public func BNBLocalizedString(_ key: Swift.String) -> Swift.String
public enum ImageFormat {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: UnifiedVideoEditorSDK.ImageFormat, b: UnifiedVideoEditorSDK.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : UnifiedVideoEditorSDK.KingfisherCompatibleValue {
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: UnifiedVideoEditorSDK.ImageFormat {
    get
  }
  public func contains(jpeg marker: UnifiedVideoEditorSDK.ImageFormat.JPEGMarker) -> Swift.Bool
}
public enum VideoResolution : Swift.String {
  case uhd3840x2160
  case qhd2560x1440
  case hd1920x1080
  case hd1280x720
  case md960x540
  case default854x480
  public var isFullHDEnabled: Swift.Bool {
    get
  }
  public var aptureSessionPreset: AVFoundation.AVCaptureSession.Preset {
    get
  }
  public var assetExportPreset: Swift.String {
    get
  }
  public var size: CoreFoundation.CGSize {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CameraVideoResolution {
  case auto
  case vga854x480
  case hd1280x720
  case hd1920x1080
  public var aptureSessionPreset: AVFoundation.AVCaptureSession.Preset? {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  public static func == (a: UnifiedVideoEditorSDK.CameraVideoResolution, b: UnifiedVideoEditorSDK.CameraVideoResolution) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct VideoResolutionConfiguration {
  public var `default`: UnifiedVideoEditorSDK.VideoResolution
  public var cameraVideoResolution: UnifiedVideoEditorSDK.CameraVideoResolution
  public let resolutions: [UnifiedVideoEditorSDK.DeviceModel : UnifiedVideoEditorSDK.VideoResolution]
  public let thumbnailHeights: [UnifiedVideoEditorSDK.DeviceModel : CoreFoundation.CGFloat]
  public let defaultThumbnailHeight: CoreFoundation.CGFloat
  public var current: UnifiedVideoEditorSDK.VideoResolution {
    get
  }
  public var currentThumbnailHeight: CoreFoundation.CGFloat {
    get
  }
  public init(default: UnifiedVideoEditorSDK.VideoResolution, cameraVideoResolution: UnifiedVideoEditorSDK.CameraVideoResolution = .auto, resolutions: [UnifiedVideoEditorSDK.DeviceModel : UnifiedVideoEditorSDK.VideoResolution], thumbnailHeights: [UnifiedVideoEditorSDK.DeviceModel : CoreFoundation.CGFloat], defaultThumbnailHeight: CoreFoundation.CGFloat)
}
extension AVFoundation.AVCaptureSession.Preset {
  public mutating func downgrade()
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func dropShadow(_ offset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), blur: CoreFoundation.CGFloat = 1, opacity: Swift.Float = 1)
}
public struct ToastConfiguration {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var cornerRadius: CoreFoundation.CGFloat
  public var textColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: UIKit.UIColor
  public var contentInsets: UIKit.UIEdgeInsets
  public var insets: UIKit.UIEdgeInsets
  public var icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public init(kern: Swift.Double, font: UIKit.UIFont, cornerRadius: CoreFoundation.CGFloat, textColor: UIKit.UIColor = .white, backgroundColor: UIKit.UIColor = .black, borderWidth: CoreFoundation.CGFloat = .zero, borderColor: UIKit.UIColor = .clear, contentInsets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 15.0,
      left: 15.0,
      bottom: 15.0,
      right: 15.0
    ), insets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 70.0,
      left: 16.0,
      bottom: .zero,
      right: 16.0
    ), icon: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? = nil)
}
extension UnifiedVideoEditorSDK.ToastConfiguration {
  public static var `default`: UnifiedVideoEditorSDK.ToastConfiguration {
    get
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public class func loadFromNib() -> Self
}
public protocol AspectsServicing {
  func setupWithVideoResolution(_ videoResolution: UnifiedVideoEditorSDK.VideoResolution)
  func getAspectedVideoSize(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> CoreFoundation.CGSize
  func getAspectRatio(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> Swift.Double
}
public class AspectsService : UnifiedVideoEditorSDK.AspectsServicing {
  public var videoResolution: UnifiedVideoEditorSDK.VideoResolution
  public init()
  public func setupWithVideoResolution(_ videoResolution: UnifiedVideoEditorSDK.VideoResolution)
  public func getAspectedVideoSize(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> CoreFoundation.CGSize
  public func getAspectRatio(forAsset asset: AVFoundation.AVAsset, withAspectRatio aspectRatio: UnifiedVideoEditorSDK.AspectRatio) -> Swift.Double
  @objc deinit
}
public struct CaptionLanguageConfiguration {
  public var selectedIcon: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
}
public enum SharedLocalizedStrings {
  public enum Errors {
    public static let noInternetConnection: Swift.String
  }
  public enum Common {
    public static let ok: Swift.String
    public static let yes: Swift.String
    public static let no: Swift.String
  }
  public enum Alert {
    public static let settings: Swift.String
    public static let refuseSettings: Swift.String
  }
  public enum Gallery {
    public static let damagedFile: Swift.String
    public static let exportVideoFailed: Swift.String
  }
  public enum AutoCut {
  }
}
public protocol Placeholder {
  func add(to imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView)
  func remove(from imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView)
}
extension UIKit.UIImage : UnifiedVideoEditorSDK.Placeholder {
  public func add(to imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView)
  public func remove(from imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView)
}
extension UnifiedVideoEditorSDK.Placeholder where Self : UIKit.UIView {
  public func add(to imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView)
  public func remove(from imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView)
}
extension Swift.String {
  public func height(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
  public func width(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension UnifiedVideoEditorSDK.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
@objc @_hasMissingDesignatedInitializers public class PIPPlayer : UnifiedVideoEditorSDK.PIPShapeDrawer {
  final public let assetNaturalSize: CoreFoundation.CGSize
  public var currentTime: CoreMedia.CMTime {
    get
  }
  public var isPlaying: Swift.Bool {
    get
  }
  public var isReadyToProvideData: Swift.Bool {
    get
  }
  public init(asset: AVFoundation.AVAsset)
  public func setVolume(_ volume: Swift.Float)
  public func startPlaying()
  public func stopPlaying()
  public func seek(to time: Foundation.TimeInterval)
  public func draw(renderEncoder: any Metal.MTLRenderCommandEncoder, fullRenderSize: CoreFoundation.CGSize, relativeLeftTopPoint: CoreFoundation.CGPoint, scale: CoreFoundation.CGFloat)
  @objc override dynamic public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @objc deinit
}
extension Swift.Array where Element : Swift.Hashable {
  public func uniqued() -> [Element]
}
@_hasMissingDesignatedInitializers public class MetalVerticesAndUVData {
  public static let quadVertexData: [Swift.Float]
  public static func quadVertexData(scale: Swift.Float) -> [Swift.Float]
  public static let defaultTextureCoordinates: [Swift.Float]
  @objc deinit
}
public struct ImagePoints {
  public init(leftTop: CoreFoundation.CGPoint, rightTop: CoreFoundation.CGPoint, leftBottom: CoreFoundation.CGPoint, rightBottom: CoreFoundation.CGPoint)
  public var leftTop: CoreFoundation.CGPoint
  public var rightTop: CoreFoundation.CGPoint
  public var leftBottom: CoreFoundation.CGPoint
  public var rightBottom: CoreFoundation.CGPoint
  public func applying(_ t: CoreFoundation.CGAffineTransform) -> UnifiedVideoEditorSDK.ImagePoints
}
public class ImageEffectInfo {
  public enum ImageSource {
    case `static`(_: CoreGraphics.CGImage)
    case dynamic(_: any UnifiedVideoEditorSDK.VideoEditorEffectImageProvider)
  }
  final public let imageSource: UnifiedVideoEditorSDK.ImageEffectInfo.ImageSource
  final public let imagePoints: UnifiedVideoEditorSDK.ImagePoints
  public init(imageSource: UnifiedVideoEditorSDK.ImageEffectInfo.ImageSource, imagePoints: UnifiedVideoEditorSDK.ImagePoints)
  @objc deinit
}
@objc public class CameraLutStage : ObjectiveC.NSObject {
  @objc public var name: Swift.String
  @objc public var isActive: Swift.Bool
  public init(file url: Foundation.URL)
  @objc deinit
}
extension UnifiedVideoEditorSDK.CameraLutStage : UnifiedVideoEditorSDK.RenderEffect {
  @objc dynamic public var isLoaded: Swift.Bool {
    @objc get
  }
  @objc dynamic public func load()
  @objc dynamic public func unload()
  @objc dynamic public func apply(pixelBuffer: CoreVideo.CVPixelBuffer)
}
public struct MetalBlendingParameters {
  public init(isBlendingEnabled: Swift.Bool, sourceRGBBlendFactor: Metal.MTLBlendFactor, destinationRGBBlendFactor: Metal.MTLBlendFactor, sourceAlphaBlendFactor: Metal.MTLBlendFactor, destinationAlphaBlendFactor: Metal.MTLBlendFactor)
}
public class MetalHelper {
  final public let commandQueue: any Metal.MTLCommandQueue
  final public let depthStencilState: any Metal.MTLDepthStencilState
  public init(libraryBundle: Foundation.Bundle)
  public func rgbaTextureForPixelBuffer(_ pixelBuffer: CoreVideo.CVPixelBuffer) -> (any Metal.MTLTexture)?
  public func createMonochromeTexture(textureData: Swift.UnsafeMutablePointer<Swift.UInt8>, width: Swift.Int, height: Swift.Int) -> any Metal.MTLTexture
  public func createRenderPipeline(vertexFunctionName: Swift.String, fragmentFunctionName: Swift.String, pixelFormat: Metal.MTLPixelFormat = .bgra8Unorm, depthPixelFormat: Metal.MTLPixelFormat? = nil, blendParameters: UnifiedVideoEditorSDK.MetalBlendingParameters? = nil, bundle: Foundation.Bundle = Bundle.main, label: Swift.String? = nil) -> (any Metal.MTLRenderPipelineState)?
  public func setupRenderPassDescriptor(destinationTexture: any Metal.MTLTexture, useBufferFetch: Swift.Bool = false) -> Metal.MTLRenderPassDescriptor
  public func setupRenderPassDescriptor(destinationTexture: any Metal.MTLTexture, depth: any Metal.MTLTexture) -> Metal.MTLRenderPassDescriptor
  public func makeBuffer<T>(array: [T]) -> any Metal.MTLBuffer
  public func makeBuffer(bytes pointer: Swift.UnsafeRawPointer, length: Swift.Int, options: Metal.MTLResourceOptions = []) -> any Metal.MTLBuffer
  public func makeTexture(descriptor: Metal.MTLTextureDescriptor) -> any Metal.MTLTexture
  public func makeDefaultUVBuffer() -> any Metal.MTLBuffer
  public func makeDefaultVertexBuffer() -> any Metal.MTLBuffer
  @objc deinit
}
extension Metal.MTLBuffer {
  public func replaceData<T>(with newData: [T])
}
@_hasMissingDesignatedInitializers public class ConnectionListener {
  final public let onConnectionChanged: ((UnifiedVideoEditorSDK.Connection) -> ())
  @objc deinit
}
public protocol ReachabilityServicing {
  var currentConnection: UnifiedVideoEditorSDK.Connection { get }
  var isInternetAvailable: Swift.Bool { get }
  func listenConnection(onConnectionChanged: @escaping ((UnifiedVideoEditorSDK.Connection) -> ())) -> UnifiedVideoEditorSDK.ConnectionListener
  func stopListenConnection(for connectionListener: UnifiedVideoEditorSDK.ConnectionListener)
}
public struct ReachabilityServiceBuilder {
  public static func build() -> (any UnifiedVideoEditorSDK.ReachabilityServicing)?
}
public typealias BackgroundTextureSettings = (galleryItem: any UnifiedVideoEditorSDK.GalleryItem, backgroundColor: UIKit.UIColor)
public protocol SDKEffectTextureServicing {
  var selectedBackgroundTextureSettings: UnifiedVideoEditorSDK.BackgroundTextureSettings? { get }
  func effectAddImageTexture(image: UIKit.UIImage, backgroundTextureSettings: UnifiedVideoEditorSDK.BackgroundTextureSettings)
  func effectAddVideoTexture(asset: AVFoundation.AVURLAsset, backgroundTextureSettings: UnifiedVideoEditorSDK.BackgroundTextureSettings)
  func unloadEffectTexture()
  func reloadTexturePreview(startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, itemDuration: Foundation.TimeInterval)
  func reloadCurrentTexture(imageSize: CoreFoundation.CGSize)
  func setupDefaultImageTexture()
  func stopVideoTextureIfNeeded()
}
extension Dispatch.DispatchQueue {
  public static func checkAndPerformOnMainThreadAsync(_ block: @escaping () -> Swift.Void)
}
public struct BlurCoordinateParams : Swift.Codable {
  public var center: CoreFoundation.CGPoint
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var radius: CoreFoundation.CGFloat
  public var absoluteCenter: CoreFoundation.CGPoint
  public var absoluteRadius: CoreFoundation.CGFloat
  public static var zero: UnifiedVideoEditorSDK.BlurCoordinateParams {
    get
  }
  public init(center: CoreFoundation.CGPoint, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, radius: CoreFoundation.CGFloat)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol EffectSelectionViewControllerDelegate : AnyObject {
  func effectSelectionViewController(viewController: any UnifiedVideoEditorSDK.EffectSelectionViewController, didSelectFile url: Foundation.URL, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func effectSelectionViewControllerDidCancel(viewController: any UnifiedVideoEditorSDK.EffectSelectionViewController)
}
public protocol EffectSelectionViewController : UIKit.UIViewController {
  var effectSelectionDelegate: (any UnifiedVideoEditorSDK.EffectSelectionViewControllerDelegate)? { get set }
}
extension BNBSdkCore.BNBFrameData {
  public class func create(cvBuffer: CoreVideo.CVPixelBuffer, faceOrientation: Swift.Int = 0, cameraOrientation: BNBSdkCore.BNBCameraOrientation = .deg90, requireMirroring: Swift.Bool = false, fieldOfView: Swift.Float = 60) -> BNBSdkCore.BNBFrameData?
}
@_hasMissingDesignatedInitializers public class MetalHelperHolder {
  public static let shared: UnifiedVideoEditorSDK.MetalHelperHolder
  final public let metalHelper: UnifiedVideoEditorSDK.MetalHelper
  @objc deinit
}
extension UIKit.UIImage {
  public static func orientation(byRotation rotation: UnifiedVideoEditorSDK.AssetRotation) -> UIKit.UIImage.Orientation
}
public enum EffectType {
  case mask
  case effect
  case videoEditorEffect
  public static func == (a: UnifiedVideoEditorSDK.EffectType, b: UnifiedVideoEditorSDK.EffectType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AppliedEffectsStack : UnifiedVideoEditorSDK.EffectStack {
  public func getAllEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  public func getAllEffects() -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
@objc public class BackgroundConfiguration : ObjectiveC.NSObject {
  public var cornerRadius: CoreFoundation.CGFloat
  public var color: UIKit.UIColor
  public init(cornerRadius: CoreFoundation.CGFloat, color: UIKit.UIColor)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class License : ObjectiveC.NSObject {
  @objc public var token: Swift.String {
    get
  }
  @objc public var clientId: Swift.String {
    get
  }
  @objc public var maxFaces: Swift.Int32 {
    get
  }
  @objc public var collectAnalytics: Swift.Bool {
    get
  }
  @objc public var supportsAnalytics: Swift.Bool {
    get
  }
  @objc public var videoEditorSupportsFaceAR: Swift.Bool {
    get
  }
  @objc public var hasFaceARFeatures: Swift.Bool {
    get
  }
  @objc public var supportsPiP: Swift.Bool {
    get
  }
  @objc public var supportsMusicLibrary: Swift.Bool {
    get
  }
  @objc public var supportsSoundstripe: Swift.Bool {
    get
  }
  @objc public var supportsBgSeparation: Swift.Bool {
    get
  }
  @objc public var supportsCaptions: Swift.Bool {
    get
  }
  @objc public var supportsAutoCut: Swift.Bool {
    get
  }
  @objc public var postProcessingEffects: [Swift.Int] {
    get
  }
  @objc public var arCloudURL: Swift.String? {
    get
  }
  @objc public var timeBomb: UnifiedVideoEditorSDK.TimeBomb? {
    get
  }
  @objc public var supportsFHD: Swift.Bool {
    get
  }
  @objc public var isExportAPIEnabled: Swift.Bool {
    get
  }
  @objc public var isPlaybackAPIEnabled: Swift.Bool {
    get
  }
  @objc public var isVESDKEnabled: Swift.Bool {
    get
  }
  @objc public var isPhotoEditorSDKEnabled: Swift.Bool {
    get
  }
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc public static func getLicense(fromToken token: Swift.String) -> UnifiedVideoEditorSDK.License?
  public func getLicenseState(completion: @escaping ((BNBLicenseUtils.XBNBLicenseStatus) -> Swift.Void))
  @objc deinit
}
@objc public protocol AudioBrowserConfigApplyable {
  @objc var config: UnifiedVideoEditorSDK.AudioBrowserConfig { get set }
}
@objc public enum AudioBrowserMusicSource : Swift.Int, Swift.CaseIterable {
  case mubert = 1
  case localStorageWithMyFiles = 2
  case allSources = 3
  case soundstripe = 4
  case predefinedList = 5
  case musicLibrary = 6
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UnifiedVideoEditorSDK.AudioBrowserMusicSource]
  public typealias RawValue = Swift.Int
  public static var allCases: [UnifiedVideoEditorSDK.AudioBrowserMusicSource] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class AudioBrowserConfig : ObjectiveC.NSObject {
  public static var shared: UnifiedVideoEditorSDK.AudioBrowserConfig
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var localMusicButtonImage: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var myFilesButtonTitle: Swift.String
  public var myFilesTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var coverPercentage: Swift.Double
  public var categorySelectionConfig: UnifiedVideoEditorSDK.CategorySelectionConfig
  public var preCategorySelectionConfig: UnifiedVideoEditorSDK.PreCategorySelectionConfig
  public var trackSelectionConfig: UnifiedVideoEditorSDK.TrackSelectionConfig
  public var myLibraryTrackSelectionConfig: UnifiedVideoEditorSDK.MyLibraryTrackSelectionConfig
  public var toastConfiguration: UnifiedVideoEditorSDK.ToastConfiguration
  public var mubertAudioConfig: UnifiedVideoEditorSDK.MubertAudioConfig
  public var internetConnectionViewConfig: UnifiedVideoEditorSDK.ActionViewConfig
  public var myLibraryPermissionViewConfig: UnifiedVideoEditorSDK.ActionViewConfig
  public var errorViewConfig: UnifiedVideoEditorSDK.ErrorViewConfig
  public var activityIndicatorConfig: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public var selectedTrackViewConfiguration: UnifiedVideoEditorSDK.SelectedTrackViewConfiguration
  public var showMoreTrackConfiguration: UnifiedVideoEditorSDK.ShowMoreTrackConfig
  public var musicSource: UnifiedVideoEditorSDK.AudioBrowserMusicSource
  public var predefinedList: [UnifiedVideoEditorSDK.AudioBrowserTrack]
  @objc required convenience override dynamic public init()
  public init(cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, localMusicButtonImage: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, myFilesButtonTitle: Swift.String, myFilesTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration, titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration, coverPercentage: Swift.Double, categorySelectionConfig: UnifiedVideoEditorSDK.CategorySelectionConfig, preCategorySelectionConfig: UnifiedVideoEditorSDK.PreCategorySelectionConfig, trackSelectionConfig: UnifiedVideoEditorSDK.TrackSelectionConfig, myLibraryTrackSelectionConfig: UnifiedVideoEditorSDK.MyLibraryTrackSelectionConfig, toastConfiguration: UnifiedVideoEditorSDK.ToastConfiguration, mubertAudioConfig: UnifiedVideoEditorSDK.MubertAudioConfig, internetConnectionViewConfig: UnifiedVideoEditorSDK.ActionViewConfig, errorViewConfig: UnifiedVideoEditorSDK.ErrorViewConfig, activityIndicatorConfig: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration, myLibraryPermissionViewConfig: UnifiedVideoEditorSDK.ActionViewConfig, selectedTrackViewConfiguration: UnifiedVideoEditorSDK.SelectedTrackViewConfiguration, showMoreTrackConfiguration: UnifiedVideoEditorSDK.ShowMoreTrackConfig, musicSource: UnifiedVideoEditorSDK.AudioBrowserMusicSource, predefinedList: [UnifiedVideoEditorSDK.AudioBrowserTrack])
  public func setPrimaryColor(_ primaryColor: UIKit.UIColor)
  @objc deinit
}
public struct MubertAudioConfig {
  public var token: Swift.String
  public var license: Swift.String
  public var categoryTracksAmount: Swift.Int
  public var trackDuration: Swift.String
  public var trackBitrate: Swift.String
  public var trackIntencity: Swift.String
  public var trackFormat: Swift.String
}
public struct CategorySelectionConfig {
  public var backButtonImageName: Swift.String
  public var searchBarTintColor: UIKit.UIColor
  public var searchBarBackgroundColor: UIKit.UIColor
  public var searchBarTextColor: UIKit.UIColor
  public var searchBarStyle: UIKit.UIBarStyle
  public var searchBarPlaceholder: UnifiedVideoEditorSDK.TextConfiguration
  public var searchBarPlaceholderText: Swift.String
  public var searchBarText: UnifiedVideoEditorSDK.TextConfiguration
  public var tableViewColor: UIKit.UIColor
  public var cellColor: UIKit.UIColor
  public var titleViewColor: UIKit.UIColor
  public var titleViewCornerRadius: CoreFoundation.CGFloat
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var categoryImageNames: [Swift.String]
  public var categoryImagesTintColor: UIKit.UIColor
  public var selectedImageName: Swift.String
}
public struct PreCategorySelectionConfig {
  public var backButtonImageName: Swift.String
  public var searchBarTintColor: UIKit.UIColor
  public var searchBarBackgroundColor: UIKit.UIColor
  public var searchBarTextColor: UIKit.UIColor
  public var searchBarStyle: UIKit.UIBarStyle
  public var searchBarPlaceholder: UnifiedVideoEditorSDK.TextConfiguration
  public var searchBarPlaceholderText: Swift.String
  public var seacrhBarText: UnifiedVideoEditorSDK.TextConfiguration
  public var tableViewColor: UIKit.UIColor
  public var cellColor: UIKit.UIColor
  public var titleViewColor: UIKit.UIColor
  public var titleViewCornerRadius: CoreFoundation.CGFloat
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var categoryImageName: Swift.String
}
public struct TrackSelectionConfig {
  public var backButtonImageName: Swift.String
  public var searchBarTintColor: UIKit.UIColor
  public var searchBarBackgroundColor: UIKit.UIColor
  public var searchBarTextColor: UIKit.UIColor
  public var searchBarStyle: UIKit.UIBarStyle
  public var searchBarPlaceholder: UnifiedVideoEditorSDK.TextConfiguration
  public var searchBarPlaceholderText: Swift.String
  public var searchBarText: UnifiedVideoEditorSDK.TextConfiguration
  public var tableViewColor: UIKit.UIColor
  public var cellColor: UIKit.UIColor
  public var cellPlayingColor: UIKit.UIColor
  public var playPauseButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var downloadButtonTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var downloadButtonTitle: Swift.String
  public var stopUsingButtonTitle: Swift.String
  public var progressViewBackgroundColor: UIKit.UIColor
  public var progressViewFillColor: UIKit.UIColor
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var durationTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var progressBackgroundColor: CoreGraphics.CGColor
  public var progressFillColor: CoreGraphics.CGColor
  public var cancelDownloadButton: UnifiedVideoEditorSDK.ImageButtonConfiguration
}
public struct MyLibraryTrackSelectionConfig {
  public var backButtonImageName: Swift.String
  public var searchBarTintColor: UIKit.UIColor
  public var searchBarBackgroundColor: UIKit.UIColor
  public var searchBarTextColor: UIKit.UIColor
  public var searchBarStyle: UIKit.UIBarStyle
  public var searchBarPlaceholder: UnifiedVideoEditorSDK.TextConfiguration
  public var searchBarPlaceholderText: Swift.String
  public var searchBarText: UnifiedVideoEditorSDK.TextConfiguration
  public var tableViewColor: UIKit.UIColor
  public var cellColor: UIKit.UIColor
  public var cellPlayingColor: UIKit.UIColor
  public var playPauseButtonConfiguration: UnifiedVideoEditorSDK.ImageButtonConfiguration
  public var useButtonTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var useButtonTitle: Swift.String
  public var progressViewBackgroundColor: UIKit.UIColor
  public var progressViewFillColor: UIKit.UIColor
  public var titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var durationTitleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
}
public struct ShowMoreTrackConfig {
  public var trackTextButtonColor: UIKit.UIColor
  public var activityIndicatorConfig: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
}
public struct ErrorViewConfig {
  public var commonErrorImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var emptySelectionImage: UnifiedVideoEditorSDK.ImageConfiguration
  public var messageConfig: UnifiedVideoEditorSDK.TextConfiguration
}
public struct ActionViewConfig {
  public var title: Swift.String
  public var titleConfig: UnifiedVideoEditorSDK.TextConfiguration
  public var message: Swift.String
  public var messageConfig: UnifiedVideoEditorSDK.TextConfiguration
  public var buttonTitle: Swift.String
  public var buttonTitleConfig: UnifiedVideoEditorSDK.TextConfiguration
  public var buttonColor: UIKit.UIColor
  public var buttonCornerRadius: CoreFoundation.CGFloat
}
public struct SelectedTrackViewConfiguration {
  public let imageConfiuguration: UnifiedVideoEditorSDK.ImageConfiguration
  public let titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public let stopUsingButtonTitle: Swift.String
  public let stopUsingButtonConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public let backgroundColor: UIKit.UIColor
  public init(imageConfiuguration: UnifiedVideoEditorSDK.ImageConfiguration, titleConfiguration: UnifiedVideoEditorSDK.TextConfiguration, stopUsingButtonTitle: Swift.String, stopUsingButtonConfiguration: UnifiedVideoEditorSDK.TextConfiguration, backgroundColor: UIKit.UIColor)
}
@objc public class VideoTimeLineCollectionViewHandler : ObjectiveC.NSObject {
  final public let collectionView: UIKit.UICollectionView
  final public let timeLineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource
  final public let cornerRadius: CoreFoundation.CGFloat
  public init(collectionView: UIKit.UICollectionView, timeLineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, cornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler {
  public func applyContentInset(appliedWidth: CoreFoundation.CGFloat, cursorOffset: CoreFoundation.CGFloat? = nil)
  public func applyContentOffset(_ offset: CoreFoundation.CGPoint)
  public func cellSize() -> CoreFoundation.CGSize
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler : UnifiedVideoEditorSDK.TimeLineDataSourceDelegate {
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc dynamic public func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any UnifiedVideoEditorSDK.TimeLineDataSource)
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
}
extension UnifiedVideoEditorSDK.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
}
public typealias Bitrate = Swift.Int
public class ExportVideoInfo {
  public enum Resolution : Swift.String {
    case ultraHd2160
    case qhd1440
    case fullHd1080
    case hd720
    case md540
    case md480
    case ld360
    case original
    public var size: CoreFoundation.CGSize {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public let resolution: UnifiedVideoEditorSDK.ExportVideoInfo.Resolution
  final public let aspect: UnifiedVideoEditorSDK.AspectRatio?
  final public let exportSettings: UnifiedVideoEditorSDK.ExportVideoSettings
  final public let audioSettings: [Swift.String : Any]?
  public init(resolution: UnifiedVideoEditorSDK.ExportVideoInfo.Resolution, aspect: UnifiedVideoEditorSDK.AspectRatio? = nil, useHEVCCodecIfPossible: Swift.Bool, frameRate: Swift.Int = 30, scalingMode: Swift.String = AVVideoScalingModeResize, audioSettings: [Swift.String : Any]? = VESettings.audio)
  public static func setupOriginalSize(size: CoreFoundation.CGSize)
  @objc deinit
}
public struct ExportVideoInfoFactory {
  public static func assetExportSettings(resolution: UnifiedVideoEditorSDK.VideoResolution, aspect: UnifiedVideoEditorSDK.AspectRatio? = nil, useHEVCCodecIfPossible: Swift.Bool, frameRate: Swift.Int = 30, scalingMode: Swift.String = AVVideoScalingModeResize, audioSettings: [Swift.String : Any]?) -> UnifiedVideoEditorSDK.ExportVideoInfo
}
@_hasMissingDesignatedInitializers public class ExportVideoSettings {
  final public let width: Swift.Int
  final public let height: Swift.Int
  final public let aspect: UnifiedVideoEditorSDK.AspectRatio?
  final public let bitrate: UnifiedVideoEditorSDK.Bitrate
  final public let frameRate: Swift.Int
  final public let codecType: AVFoundation.AVVideoCodecType
  final public let scalingMode: Swift.String
  public var options: [Swift.String : Any] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class VideoAspectRatioCalculator {
  public static func calculateVideoAspectRatio(withVideoSize videoSize: CoreFoundation.CGSize) -> Swift.Double
  public static func adjustVideoSize(_ videoSize: CoreFoundation.CGSize, withAspectRatio aspectRatio: Swift.Double) -> CoreFoundation.CGSize
  @objc deinit
}
extension UIKit.UIColor {
  convenience public init?(colorParams: UnifiedVideoEditorSDK.ColorParams)
}
public enum KF {
  public static func source(_ source: UnifiedVideoEditorSDK.Source?) -> UnifiedVideoEditorSDK.KF.Builder
  public static func resource(_ resource: (any UnifiedVideoEditorSDK.Resource)?) -> UnifiedVideoEditorSDK.KF.Builder
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> UnifiedVideoEditorSDK.KF.Builder
  public static func dataProvider(_ provider: (any UnifiedVideoEditorSDK.ImageDataProvider)?) -> UnifiedVideoEditorSDK.KF.Builder
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> UnifiedVideoEditorSDK.KF.Builder
}
extension UnifiedVideoEditorSDK.KF {
  @_hasMissingDesignatedInitializers public class Builder {
    public var options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo
    final public let onFailureDelegate: UnifiedVideoEditorSDK.Delegate<UnifiedVideoEditorSDK.KingfisherError, Swift.Void>
    final public let onSuccessDelegate: UnifiedVideoEditorSDK.Delegate<UnifiedVideoEditorSDK.RetrieveImageResult, Swift.Void>
    final public let onProgressDelegate: UnifiedVideoEditorSDK.Delegate<(Swift.Int64, Swift.Int64), Swift.Void>
    @objc deinit
  }
}
extension UnifiedVideoEditorSDK.KF.Builder {
  @discardableResult
  public func set(to imageView: UnifiedVideoEditorSDK.KFCrossPlatformImageView) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func set(to attachment: UIKit.NSTextAttachment, attributedView: @autoclosure @escaping () -> UnifiedVideoEditorSDK.KFCrossPlatformView) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func set(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setBackground(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> UnifiedVideoEditorSDK.DownloadTask?
}
extension UnifiedVideoEditorSDK.KF.Builder {
  public func placeholder(_ placeholder: (any UnifiedVideoEditorSDK.Placeholder)?) -> Self
  public func placeholder(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage?) -> Self
}
extension UnifiedVideoEditorSDK.KF.Builder {
  public func transition(_ transition: UnifiedVideoEditorSDK.ImageTransition) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func keepCurrentImageWhileLoading(_ enabled: Swift.Bool = true) -> Self
  public func onlyLoadFirstFrame(_ enabled: Swift.Bool = true) -> Self
  public func progressiveJPEG(_ progressive: UnifiedVideoEditorSDK.ImageProgressive? = .init()) -> Self
}
extension UnifiedVideoEditorSDK.KF.Builder {
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  public func loadImmediately(_ start: Swift.Bool = true) -> Self
}
extension UnifiedVideoEditorSDK.KF {
  public struct RedirectPayload {
    public let task: UnifiedVideoEditorSDK.SessionDataTask
    public let response: Foundation.HTTPURLResponse
    public let newRequest: Foundation.URLRequest
    public let completionHandler: (Foundation.URLRequest?) -> Swift.Void
  }
}
extension AVFoundation.AVAssetTrack {
  public var fixedPreferredTransform: CoreFoundation.CGAffineTransform {
    get
  }
}
public protocol PlayerStateStorable {
  var playerState: Swift.Bool { get set }
}
public protocol VoiceChangeable : AnyObject {
  var queue: Dispatch.DispatchQueue { get set }
  var volume: Swift.Float { get set }
  var isConfigured: Swift.Bool { get }
  func process(file url: Foundation.URL, completion: ((Swift.Bool, (any Swift.Error)?) -> Swift.Void)?)
  func process(file url: Foundation.URL) throws
}
public enum VoiceChangerError : Swift.Error {
  case cantCreateAssetExportSession
  case exportSessionCantExportAudio
  public static func == (a: UnifiedVideoEditorSDK.VoiceChangerError, b: UnifiedVideoEditorSDK.VoiceChangerError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum VideoRecordSpeed : Swift.Int, Swift.CaseIterable {
  case half
  case normal
  case double
  case triple
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UnifiedVideoEditorSDK.VideoRecordSpeed]
  public typealias RawValue = Swift.Int
  public static var allCases: [UnifiedVideoEditorSDK.VideoRecordSpeed] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RetryContext {
  final public let source: UnifiedVideoEditorSDK.Source
  final public let error: UnifiedVideoEditorSDK.KingfisherError
  public var retriedCount: Swift.Int
  public var userInfo: Any? {
    get
  }
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy {
  func retry(context: UnifiedVideoEditorSDK.RetryContext, retryHandler: @escaping (UnifiedVideoEditorSDK.RetryDecision) -> Swift.Void)
}
public struct DelayRetryStrategy : UnifiedVideoEditorSDK.RetryStrategy {
  public enum Interval {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: (_ retriedCount: Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: UnifiedVideoEditorSDK.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: UnifiedVideoEditorSDK.DelayRetryStrategy.Interval = .seconds(3))
  public func retry(context: UnifiedVideoEditorSDK.RetryContext, retryHandler: @escaping (UnifiedVideoEditorSDK.RetryDecision) -> Swift.Void)
}
extension Foundation.NSNotification.Name {
  public static let videoEditorPlayerCurrentTimeChanged: Foundation.Notification.Name
}
public protocol VideoEditorPlayable : AnyObject {
  var isPlaying: Swift.Bool { get }
  var playerItem: AVFoundation.AVPlayerItem? { get }
  var avPlayer: AVFoundation.AVPlayer { get }
  var currentTime: CoreMedia.CMTime { get }
  var videoDuration: CoreMedia.CMTime { get }
  var playingRange: CoreMedia.CMTimeRange { get }
  var isMuted: Swift.Bool { get set }
  var audioMix: AVFoundation.AVAudioMix? { get set }
  var playerDelegate: (any UnifiedVideoEditorSDK.VideoEditorPlayerDelegate)? { get set }
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool, range: CoreMedia.CMTimeRange)
  func pause()
  func seek(to time: CoreMedia.CMTime)
  func smoothlySeek(to time: CoreMedia.CMTime)
  func seek(to time: CoreMedia.CMTime, completion: @escaping (_ isFinished: Swift.Bool) -> Swift.Void)
  func reloadPreview(shouldAutoStart: Swift.Bool)
}
public protocol VideoEditorPlayerDelegate : AnyObject {
  func playerPlaysFrame(_ player: any UnifiedVideoEditorSDK.VideoEditorPlayable, atTime time: CoreMedia.CMTime)
  func playerDidEndPlaying(_ player: any UnifiedVideoEditorSDK.VideoEditorPlayable)
}
public class VideoSequenceItem {
  @_hasMissingDesignatedInitializers public class VideoInfo {
    final public let duration: Foundation.TimeInterval
    final public let resolution: CoreFoundation.CGSize
    @objc deinit
  }
  final public let uuidString: Swift.String
  final public let url: Foundation.URL
  public var videoInfo: UnifiedVideoEditorSDK.VideoSequenceItem.VideoInfo {
    get
    set
  }
  final public let isGalleryAsset: Swift.Bool
  final public let isSlideShow: Swift.Bool
  final public let isPIP: Swift.Bool
  final public let isCopy: Swift.Bool
  public var rotation: UnifiedVideoEditorSDK.AssetRotation
  final public let preview: UIKit.UIImage?
  final public let originalAssetResolution: CoreFoundation.CGSize?
  public var previewUrl: Foundation.URL?
  public var speed: Swift.Double {
    get
  }
  public var name: Swift.String {
    get
  }
  public var transition: UnifiedVideoEditorSDK.TransitionType
  public init(uuidString: Swift.String, assetUrl url: Foundation.URL, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool, isCopy: Swift.Bool, rotation: UnifiedVideoEditorSDK.AssetRotation, preview: UIKit.UIImage?, previewUrl: Foundation.URL?, transition: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize?)
  public func tryReplaceVideo(at videoUrl: Foundation.URL) -> Swift.Bool
  @objc deinit
}
@objc public class VideoSequence : ObjectiveC.NSObject {
  final public let folderURL: Foundation.URL
  public var modificationDate: Foundation.Date {
    get
    set
  }
  public var preview: UIKit.UIImage?
  public var videos: [UnifiedVideoEditorSDK.VideoSequenceItem]
  public var sequenceId: Swift.String {
    get
  }
  public var durations: [Foundation.TimeInterval] {
    get
  }
  public var initialDurations: [Foundation.TimeInterval] {
    get
  }
  public var isGallerySequence: Swift.Bool {
    get
  }
  public var removedVideos: [UnifiedVideoEditorSDK.VideoSequenceItem] {
    get
  }
  required public init(folderURL: Foundation.URL)
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public func remove()
  public func removeVideos()
  @discardableResult
  public func deleteVideo(_ video: UnifiedVideoEditorSDK.VideoSequenceItem) -> Swift.Bool
  public var hasRemovedVideos: Swift.Bool {
    get
  }
  public func restoreRemovedVideos()
  @discardableResult
  public func removeVideo(_ video: UnifiedVideoEditorSDK.VideoSequenceItem) -> Swift.Bool
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public static func generateName() -> Swift.String
}
extension UnifiedVideoEditorSDK.VideoSequence {
  @discardableResult
  public func addVideo(uuidString: Swift.String = UUID().uuidString, at url: Foundation.URL, speed: Swift.Double = 1.0, isGalleryAsset: Swift.Bool = false, isSlideShow: Swift.Bool, isPIP: Swift.Bool = false, isRemovedVideo: Swift.Bool = false, rotation: UnifiedVideoEditorSDK.AssetRotation = .none, preview: UIKit.UIImage? = nil, shouldMoveFile: Swift.Bool = true, shouldUseUniqName: Swift.Bool = true, transition: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize? = nil) -> UnifiedVideoEditorSDK.VideoSequenceItem?
  @discardableResult
  public func addVideoCopy(uuidString: Swift.String, at url: Foundation.URL, speed: Swift.Double = 1.0, isGalleryAsset: Swift.Bool, isSlideShow: Swift.Bool, isPIP: Swift.Bool, isRemoved: Swift.Bool = false, rotation: UnifiedVideoEditorSDK.AssetRotation = .none, preview: UIKit.UIImage? = nil, transition: UnifiedVideoEditorSDK.TransitionType, originalAssetResolution: CoreFoundation.CGSize? = nil) -> UnifiedVideoEditorSDK.VideoSequenceItem?
  public func didUpdateVideo(_ video: UnifiedVideoEditorSDK.VideoSequenceItem)
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public typealias SequnceVideos = (originalVideos: [UnifiedVideoEditorSDK.VideoSequenceItem], videos: [UnifiedVideoEditorSDK.VideoSequenceItem])
  public func getVideoFileNames(in directory: Foundation.URL) -> UnifiedVideoEditorSDK.VideoSequence.SequnceVideos
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public func totalDuration(isSpeedCountingEnabled: Swift.Bool = true) -> Foundation.TimeInterval
  public func getDurations(isSpeedCountingEnabled: Swift.Bool = true) -> [Foundation.TimeInterval]
}
extension UnifiedVideoEditorSDK.VideoSequence {
  public static func restore(folder: Foundation.URL) -> UnifiedVideoEditorSDK.VideoSequence
}
extension UnifiedVideoEditorSDK.VideoSequence {
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
}
@objc public protocol EffectSubtypeModificationsEventListener {
  @objc func didChangeEffectSubtype(_ subtypeName: Swift.String)
  @objc func didInitiateEffectSubtype(_ subtypeName: Swift.String)
}
@objc public protocol SDKEffectsTextureServicing {
  @objc func effectAddImageTexture(image: UIKit.UIImage, backgroundColor: UIKit.UIColor)
  @objc func setupDefaultImageTexture()
  @objc func stopVideoTextureIfNeeded()
  @objc func effectAddVideoTexture(asset: AVFoundation.AVURLAsset, backgroundColor: UIKit.UIColor)
  @objc func effectReloadTexturePreview(startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, itemDuration: Foundation.TimeInterval)
  @objc func unloadEffectTexture()
}
@objc public protocol SDKEffectsServicing : UnifiedVideoEditorSDK.SDKEffectsTextureServicing {
  @objc var isMaskLoaded: Swift.Bool { get }
  @objc func loadMask(name: Swift.String, synchronous: Swift.Bool)
  @objc func enableBlur()
  @objc func effectDidBeginApplying()
  @objc func effectDidEndApplying()
  @objc func effectDidResetApplying()
  @objc func effectDidChangeState()
  @objc func unloadMask()
  @objc func removeAllFilters()
  @objc func applyFilter(_ filter: any UnifiedVideoEditorSDK.RenderEffect)
  @objc func removeFilter(_ filter: any UnifiedVideoEditorSDK.RenderEffect)
  @objc func setEffectSubtypeModificationsEventListener(_ listener: any UnifiedVideoEditorSDK.EffectSubtypeModificationsEventListener)
  @objc func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
}
public protocol EffectsServicing {
  func apply(effect: any UnifiedVideoEditorSDK.RenderEffect)
  func remove(effect: any UnifiedVideoEditorSDK.RenderEffect)
  func removeAll()
}
public protocol SDKCameraChangedDelegate : AnyObject {
  func sdkDidChangeCamera(cameraStartedCompletion: (() -> Swift.Void)?)
  func sdkWillChangeCamera()
}
public protocol SDKCameraServicing {
  var videoRecordSpeed: UnifiedVideoEditorSDK.VideoRecordSpeed { get set }
  var cameraChangedDelegate: (any UnifiedVideoEditorSDK.SDKCameraChangedDelegate)? { get set }
  var renderQueue: Dispatch.DispatchQueue? { get }
  var autoStart: Swift.Bool { get set }
  var allowProcessing: Swift.Bool { get set }
  var isLoaded: Swift.Bool { get }
  func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
  func setupCamera()
  func setupPostprocessing()
  func destroy()
  func start(completion: @escaping () -> Swift.Void)
  func stop()
  func stop(completion: (() -> Swift.Void)?)
  func applyFilter(_ filter: UnifiedVideoEditorSDK.EffectModel)
  func removeFilter(_ filter: UnifiedVideoEditorSDK.EffectModel)
  func removeAllFilters()
  func startRenderLoop()
  func stopRenderLoop()
  func loadMask(name: Swift.String, synchronous: Swift.Bool)
  func unloadMask()
  func setRenderTarget(view: UIKit.UIView)
  func removeRenderTarget()
  func toggleBeautification() -> Swift.Bool
  func discardAppliedChanges()
  func setupDefaultState()
  func configurePhotoModeIfNeeded(isFrontCamera: Swift.Bool, isEnableTorch: Swift.Bool)
  func getRendererView() -> UIKit.UIView
  func takeSnapshot(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  func replaceCamera(_ camera: any UnifiedVideoEditorSDK.CameraModule, completion: (() -> Swift.Void)?)
  func addFPSListener(_ listener: ((_ fpsInfo: Foundation.NSAttributedString) -> Swift.Void)?)
}
public class SDKCameraService : UnifiedVideoEditorSDK.SDKCameraServicing {
  weak public var cameraChangedDelegate: (any UnifiedVideoEditorSDK.SDKCameraChangedDelegate)?
  public var videoRecordSpeed: UnifiedVideoEditorSDK.VideoRecordSpeed
  public var isLoaded: Swift.Bool {
    get
  }
  public var autoStart: Swift.Bool {
    get
    set
  }
  public var allowProcessing: Swift.Bool {
    get
    set
  }
  public var renderQueue: Dispatch.DispatchQueue? {
    get
  }
  required public init(cameraModule: any UnifiedVideoEditorSDK.CameraModule, masksPostprocessingServicing: (any UnifiedVideoEditorSDK.SDKMaskPostprocessServicing)?)
  @objc deinit
}
extension UnifiedVideoEditorSDK.SDKCameraService {
  public func setupCamera()
  public func setupPostprocessing()
  public func destroy()
}
extension UnifiedVideoEditorSDK.SDKCameraService {
  public func configurePhotoModeIfNeeded(isFrontCamera: Swift.Bool, isEnableTorch: Swift.Bool)
}
extension UnifiedVideoEditorSDK.SDKCameraService {
  public func replaceCamera(_ camera: any UnifiedVideoEditorSDK.CameraModule, completion: (() -> Swift.Void)?)
}
extension UnifiedVideoEditorSDK.SDKCameraService {
  public func start(completion: @escaping () -> Swift.Void)
  public func stop()
  public func stop(completion: (() -> Swift.Void)?)
  public func takeSnapshot(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
}
extension UnifiedVideoEditorSDK.SDKCameraService {
  public func effectsPaths(includeBeautyEffect: Swift.Bool) -> [Swift.String]
  public func applyFilter(_ filter: UnifiedVideoEditorSDK.EffectModel)
  public func removeFilter(_ filter: UnifiedVideoEditorSDK.EffectModel)
  public func removeAllFilters()
  public func loadMask(name: Swift.String, synchronous: Swift.Bool)
  public func unloadMask()
  public func toggleBeautification() -> Swift.Bool
  public func discardAppliedChanges()
  public func setupDefaultState()
}
extension UnifiedVideoEditorSDK.SDKCameraService {
  public func startRenderLoop()
  public func stopRenderLoop()
  public func setRenderTarget(view: UIKit.UIView)
  public func removeRenderTarget()
  public func getRendererView() -> UIKit.UIView
  public func addFPSListener(_ listener: ((_ fpsInfo: Foundation.NSAttributedString) -> Swift.Void)?)
}
@objc public protocol SDKBeautyEffectManaging {
  @objc var isBeautificationEnabled: Swift.Bool { get set }
  @objc var supportsIntensity: Swift.Bool { get }
  @objc var intensity: Swift.Double { get set }
  @objc func toggleBeautification() -> Swift.Bool
  @objc func resetIntensity()
}
@_hasMissingDesignatedInitializers public class SessionDataTask {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
  }
  final public let originalURL: Foundation.URL?
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class FeedbackAlertViewController : UIKit.UIViewController {
  public enum ActionTypes {
    case agree
    case refuse
    case cancel
    public static func == (a: UnifiedVideoEditorSDK.FeedbackAlertViewController.ActionTypes, b: UnifiedVideoEditorSDK.FeedbackAlertViewController.ActionTypes) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var actionHandler: ((UnifiedVideoEditorSDK.FeedbackAlertViewController.ActionTypes) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UnifiedVideoEditorSDK.FeedbackAlertViewController {
  @_Concurrency.MainActor(unsafe) public static func makeAlertViewController() -> UnifiedVideoEditorSDK.FeedbackAlertViewController
}
@objc public class SmallActivityIndicatorConfiguration : ObjectiveC.NSObject {
  @objc public enum GradientTypeAdapter : Swift.Int {
    case color
    case image
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public class GradientType : ObjectiveC.NSObject {
    public var type: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter
    public var color: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientColorConfiguration?
    public var image: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
    public init(type: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter, color: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientColorConfiguration?, image: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?)
    @objc deinit
  }
  @objc public class GradientColorConfiguration : ObjectiveC.NSObject {
    public var angle: CoreFoundation.CGFloat
    public var colors: [CoreGraphics.CGColor]
    public init(angle: CoreFoundation.CGFloat, colors: [CoreGraphics.CGColor])
    @objc deinit
  }
  public var gradientType: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType
  public var activityLineWidth: CoreFoundation.CGFloat
  public init(gradientType: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType, activityLineWidth: CoreFoundation.CGFloat)
  @objc deinit
}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType {
  @objc public static func color(_ color: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientColorConfiguration) -> UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType
  @objc public static func image(_ image: any UnifiedVideoEditorSDK.ImageConfigurationProtocol) -> UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientType
}
public struct SaveButtonConfiguration {
  public var textConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var inactiveTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var text: Swift.String
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var inactiveBackgroundColor: UIKit.UIColor
  public init(textConfiguration: UnifiedVideoEditorSDK.TextConfiguration, inactiveTextConfiguration: UnifiedVideoEditorSDK.TextConfiguration, text: Swift.String, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, inactiveBackgroundColor: UIKit.UIColor)
}
public protocol EffectsHolderServicing : AnyObject {
  init(license: UnifiedVideoEditorSDK.License)
  var transitionEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] { get }
  var speedEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] { get }
  var visualEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] { get }
}
@objc final public class EditorEffectsConfigHolder : ObjectiveC.NSObject, UnifiedVideoEditorSDK.EffectsHolderServicing {
  public init(license: UnifiedVideoEditorSDK.License)
  public init(token: Swift.String)
  final public var transitionEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] {
    get
  }
  final public var speedEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] {
    get
  }
  final public var visualEffectsConfig: [[UnifiedVideoEditorSDK.EditorEffectKey : Any]] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SliderRounderCalculator {
  public typealias Result = (rounded: Swift.Float, displayed: Swift.String)
  public static func getRoundedVolumeValue(_ volume: Swift.Float, wasChanged: Swift.Bool) -> UnifiedVideoEditorSDK.SliderRounderCalculator.Result
  @objc deinit
}
public struct GalleryLayoutConfiguration {
  public var numberOfItemsPerRow: Swift.Int
  public var interitemSpacing: CoreFoundation.CGFloat
  public var edgeInsets: UIKit.UIEdgeInsets
  public init(numberOfItemsPerRow: Swift.Int, interitemSpacing: CoreFoundation.CGFloat, edgeInsets: UIKit.UIEdgeInsets)
}
public protocol VideoMetadataStorageDelegate : AnyObject {
  func videoMetadataStorageDidStartStoring(_ videoMetadataStorage: UnifiedVideoEditorSDK.VideoMetadataStorage)
}
public class VideoMetadataStorage {
  weak public var delegate: (any UnifiedVideoEditorSDK.VideoMetadataStorageDelegate)?
  public var videoSequence: UnifiedVideoEditorSDK.VideoSequence? {
    get
  }
  public var videoMetadata: UnifiedVideoEditorSDK.VideoMetadata? {
    get
  }
  public var videoEditorMetadata: UnifiedVideoEditorSDK.VideoEditorMetadata? {
    get
  }
  public var videoEditorTrimMetadata: UnifiedVideoEditorSDK.VideoEditorTrimMetadata? {
    get
  }
  public var audioTracks: [UnifiedVideoEditorSDK.AudioTrack]? {
    get
  }
  public var videoCoverMetadata: UnifiedVideoEditorSDK.VideoCoverMetadata? {
    get
  }
  public var musicEditorMetadata: UnifiedVideoEditorSDK.MusicEditorMetadata? {
    get
  }
  public var cameraSessionMetadata: UnifiedVideoEditorSDK.CameraSessionMetadata? {
    get
  }
  required public init(videoSequence: UnifiedVideoEditorSDK.VideoSequence? = nil, fileManager: Foundation.FileManager = FileManager.default)
  @objc deinit
  public func update(metadata: [UnifiedVideoEditorSDK.AudioTrack], trackVolumes: [Swift.Int32 : Swift.Float], pipVolume: Swift.Float?, videoVolume: Swift.Float)
  public func update(musicEditorTracks: [UnifiedVideoEditorSDK.MusicEditorTrack], trackVolumes: [Swift.Int32 : Swift.Float], pipVolume: Swift.Float?, videoVolume: Swift.Float)
  public func update(metadata: UnifiedVideoEditorSDK.CameraSessionMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoEditorTrimMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoEditorMetadata)
  public func update(metadata: UnifiedVideoEditorSDK.VideoCoverMetadata)
  public func reset()
  public func setupCurrentSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  public func videoMetadata(forVideoSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence?) -> UnifiedVideoEditorSDK.VideoMetadata?
  public func videoEditorTrimMetadata(for videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> UnifiedVideoEditorSDK.VideoEditorTrimMetadata?
  public func videoCoverMetadata(forVideoSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence?) -> UnifiedVideoEditorSDK.VideoCoverMetadata?
  public func replaceMetadata(ofVideoSequence destinationSequence: UnifiedVideoEditorSDK.VideoSequence, withVideoSequence sourceSequence: UnifiedVideoEditorSDK.VideoSequence)
  public func duplicateMetadata(ofVideoSequence sourceSequence: UnifiedVideoEditorSDK.VideoSequence, toVideoSequence destinationSequence: UnifiedVideoEditorSDK.VideoSequence)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var spinCircleLayer: QuartzCore.CAShapeLayer
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func startAnimating()
  @_Concurrency.MainActor(unsafe) public func stopAnimating()
  @objc deinit
}
@objc public protocol ImageConfigurationProtocol {
  @objc var image: UIKit.UIImage? { get }
  @objc var tintColor: UIKit.UIColor? { get }
}
public class BanubaImageConfiguration : UnifiedVideoEditorSDK.ImageConfigurationProtocol {
  @objc final public let image: UIKit.UIImage?
  @objc final public let tintColor: UIKit.UIColor?
  public init(image: UIKit.UIImage?, tintColor: UIKit.UIColor? = nil)
  @objc deinit
}
@objc public protocol AudioBrowserServiceAdoptable {
  @objc func play()
  @objc func play(playProgressHandler: @escaping (Swift.Float) -> Swift.Void)
  @objc func play(in range: CoreMedia.CMTimeRange, playProgressHandler: ((Swift.Float) -> Swift.Void)?)
  @objc func pause()
  @objc func resume()
  @objc func load(trackUrl: Foundation.URL) throws
  @objc func unload()
  @objc func autoRepeat(repeat: Swift.Bool)
  @objc func seekToStart()
  @objc func seekToTime(_ time: Foundation.TimeInterval)
  @objc var audioBrowserServiceDelegate: (any UnifiedVideoEditorSDK.AudioBrowserPlayerDelegate)? { get set }
}
@objc public protocol AudioBrowserPlayerDelegate {
  @objc func playerPlaysFrameAtTime(_ time: Foundation.TimeInterval)
  @objc func didEndPlaying()
}
@objc public class ExternalAudioConfiguration : ObjectiveC.NSObject {
  @objc final public let url: Foundation.URL
  @objc final public let offset: Foundation.TimeInterval
  @objc final public let preferredVolume: Swift.Float
  public init(url: Foundation.URL, offset: Foundation.TimeInterval, preferredVolume: Swift.Float)
  @objc deinit
}
@objc public protocol SDKOutputServicing {
  @objc var isRecording: Swift.Bool { get }
  @objc var isEnoughDiskSpaceForRecording: Swift.Bool { get }
  @objc func startVideoCapturing(fileURL: Foundation.URL?, startTimeForVideoTexture: Swift.Double, externalAudioConfiguration: UnifiedVideoEditorSDK.ExternalAudioConfiguration?, progress: @escaping (CoreMedia.CMTime) -> Swift.Void, didStart: (() -> Swift.Void)?, shouldSkipFrame: (() -> Swift.Bool)?, periodicProgressTimeInterval: Foundation.TimeInterval, boundaryTimes: [Foundation.NSValue], boundaryHandler: @escaping (CoreMedia.CMTime) -> Swift.Void, totalDuration: Foundation.TimeInterval, itemDuration: Foundation.TimeInterval, completion: @escaping (Swift.Bool, (any Swift.Error)?) -> Swift.Void)
  @objc func stopVideoCapturing(cancel: Swift.Bool)
}
@objc public class TimeBomb : ObjectiveC.NSObject, Swift.Codable {
  @objc public var yearBegin: Swift.Int, monBegin: Swift.Int, dayBegin: Swift.Int, yearEnd: Swift.Int
  @objc public var monEnd: Swift.Int, dayEnd: Swift.Int
  @objc public var isExpired: Swift.Bool {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@objc public protocol SDKInputServicingDelegate {
  @objc func willOutput(pixelBuffer: CoreVideo.CVPixelBuffer)
}
@objc public protocol SDKInputServicing {
  @objc var isFrontCamera: Swift.Bool { get }
  @objc var zoomFactor: Swift.Float { get }
  @objc var currentCameraSessionType: UnifiedVideoEditorSDK.CameraModuleSessionType { get }
  @objc var inputDelegate: (any UnifiedVideoEditorSDK.SDKInputServicingDelegate)? { get set }
  @objc func focus(at point: CoreFoundation.CGPoint, useContinuousDetection: Swift.Bool)
  @objc func setZoomFactor(_ zoomFactor: Swift.Float) -> Swift.Float
  @objc func toggleCamera(completion: @escaping () -> ())
  @objc func startCamera()
  @objc func startAudioCapturing()
  @objc func stopAudioCapturing()
  @objc func setCameraSessionType(_ type: UnifiedVideoEditorSDK.CameraModuleSessionType)
  @objc @discardableResult
  func setTorch(mode: AVFoundation.AVCaptureDevice.TorchMode) -> AVFoundation.AVCaptureDevice.TorchMode
  @objc func toggleTorch() -> AVFoundation.AVCaptureDevice.TorchMode
}
public enum OverlayPopoverActionsPosition {
  case bottomLeft(_: CoreFoundation.CGPoint)
  case topLeft(_: CoreFoundation.CGPoint)
  case topRight(_: CoreFoundation.CGPoint)
  case bottomRight(_: CoreFoundation.CGPoint)
  case center
}
public struct PopoverAlertViewConfiguration {
  public var mainBackgroundColor: UIKit.UIColor
  public var actionsViewBackgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var actionCellHeight: CoreFoundation.CGFloat
  public var hideAnimated: Swift.Bool
  public static var `default`: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration {
    get
  }
  public init(mainBackgroundColor: UIKit.UIColor, actionsViewBackgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, actionCellHeight: CoreFoundation.CGFloat, hideAnimated: Swift.Bool)
}
public struct OverlayPopoverActionConfiguration {
  public init(leftImage: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, rightImage: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?, title: UnifiedVideoEditorSDK.TextConfiguration, titleImageInset: CoreFoundation.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class PopoverAlertViewController : UIKit.UIViewController, UnifiedVideoEditorSDK.NibLoadable {
  public enum ActionType {
    case edit(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
    case delete(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
    case discardChanges(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
    case updateDraft(UnifiedVideoEditorSDK.OverlayPopoverActionConfiguration)
  }
  @_Concurrency.MainActor(unsafe) public var configuration: UnifiedVideoEditorSDK.PopoverAlertViewConfiguration
  @_Concurrency.MainActor(unsafe) public var actions: [UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType]
  @_Concurrency.MainActor(unsafe) public var actionsPosition: UnifiedVideoEditorSDK.OverlayPopoverActionsPosition
  @_Concurrency.MainActor(unsafe) public var resultCompletion: ((UnifiedVideoEditorSDK.PopoverAlertViewController.ActionType) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UnifiedVideoEditorSDK.PopoverAlertViewController : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
public protocol ImageDownloaderDelegate : AnyObject {
  func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didDownload data: Foundation.Data, with dataTask: UnifiedVideoEditorSDK.SessionDataTask) -> Foundation.Data?
  func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didDownload image: UnifiedVideoEditorSDK.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  func isValidStatusCode(_ code: Swift.Int, for downloader: UnifiedVideoEditorSDK.ImageDownloader) -> Swift.Bool
  func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
}
extension UnifiedVideoEditorSDK.ImageDownloaderDelegate {
  public func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  public func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  public func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didDownload image: UnifiedVideoEditorSDK.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  public func isValidStatusCode(_ code: Swift.Int, for downloader: UnifiedVideoEditorSDK.ImageDownloader) -> Swift.Bool
  public func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didDownload data: Foundation.Data, with task: UnifiedVideoEditorSDK.SessionDataTask) -> Foundation.Data?
  public func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  public func imageDownloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
}
public protocol AnimatableViewFactory {
  func makeAnimatableView() -> any UnifiedVideoEditorSDK.AnimatableView
}
public typealias ExternalDraft = UnifiedVideoEditorSDK.VideoSequence
@_hasMissingDesignatedInitializers public class DraftsService {
  public func getDrafts() -> [UnifiedVideoEditorSDK.ExternalDraft]
  public func removeExternalDraft(_ externalDraft: UnifiedVideoEditorSDK.ExternalDraft) -> Swift.Bool
  public func getPreviewForVideoSequence(_ externalDraft: UnifiedVideoEditorSDK.ExternalDraft, thumbnailHeight: CoreFoundation.CGFloat, completion: ((_ preview: UIKit.UIImage?) -> Swift.Void)?)
  @objc deinit
}
public enum AnalyticsEffectType : Swift.String, Swift.CaseIterable {
  case mask
  case filter
  case speed
  case beautification
  case timer
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UnifiedVideoEditorSDK.AnalyticsEffectType]
  public typealias RawValue = Swift.String
  public static var allCases: [UnifiedVideoEditorSDK.AnalyticsEffectType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@objc(BNBAnalyticsManager) public class BNBAnalyticsManager : ObjectiveC.NSObject {
  public var license: UnifiedVideoEditorSDK.License {
    get
  }
  public var cameraEffects: [UnifiedVideoEditorSDK.AnalyticsEffectType : [Swift.String?]]
  public init(license: UnifiedVideoEditorSDK.License)
  @objc deinit
}
extension UnifiedVideoEditorSDK.BNBAnalyticsManager {
  public func sendEvent(withType type: UnifiedVideoEditorSDK.BNBInformerEventType)
}
public struct TransitionEffectInfo {
  public var type: UnifiedVideoEditorSDK.TransitionEffectType {
    get
  }
  public var start: CoreMedia.CMTime {
    get
  }
  public var end: CoreMedia.CMTime {
    get
  }
  public init(type: UnifiedVideoEditorSDK.TransitionEffectType, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public var imageFrameCount: Swift.Int? {
    get
    set
  }
  public var imageSource: ImageIO.CGImageSource? {
    get
  }
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public var normalized: UnifiedVideoEditorSDK.KFCrossPlatformImage {
    get
  }
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public func pngRepresentation() -> Foundation.Data?
  public func jpegRepresentation(compressionQuality: CoreFoundation.CGFloat) -> Foundation.Data?
  public func gifRepresentation() -> Foundation.Data?
  public func data(format: UnifiedVideoEditorSDK.ImageFormat, compressionQuality: CoreFoundation.CGFloat = 1.0) -> Foundation.Data?
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public static func animatedImage(data: Foundation.Data, options: UnifiedVideoEditorSDK.ImageCreatingOptions) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
  public static func image(data: Foundation.Data, options: UnifiedVideoEditorSDK.ImageCreatingOptions) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public class AudioServiceItem : UnifiedVideoEditorSDK.AudioItem {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var title: Swift.String?
  public var additionalTitle: Swift.String?
  public var isEditable: Swift.Bool
  public var timeRange: CoreMedia.CMTimeRange?
  public init(uuid: Foundation.UUID, url: Foundation.URL, coverURL: Foundation.URL?, title: Swift.String?, additionalTitle: Swift.String?, isEditable: Swift.Bool, timeRange: CoreMedia.CMTimeRange? = nil)
  @objc deinit
}
public protocol AudioPlayerDelegate : AnyObject {
  func playerPlaysFrameAtTime(_ time: Foundation.TimeInterval)
  func didEndPlaying()
}
public protocol AudioServicing {
  var player: AVFAudio.AVAudioPlayer? { get set }
  var delegate: (any UnifiedVideoEditorSDK.AudioPlayerDelegate)? { get set }
  var rate: Swift.Float { get set }
  var currentAudio: UnifiedVideoEditorSDK.AudioServiceItem? { get }
  var duration: Foundation.TimeInterval? { get }
  func autoRepeat(repeat: Swift.Bool, delay: Swift.Double)
  func seekToStart()
  func seekToStart(isEnabled: Swift.Bool)
  func seek(to: Foundation.TimeInterval)
  func load(item: UnifiedVideoEditorSDK.AudioServiceItem) throws
  func unload()
  func toggle()
  func play()
  func pause()
  func setRate(_ rate: Swift.Float)
  func setDelegate(_ delegate: any UnifiedVideoEditorSDK.AudioPlayerDelegate)
  func changeVolume(volume: Swift.Float)
  func createAudioDirectory()
}
@objc @_inheritsConvenienceInitializers public class AudioService : ObjectiveC.NSObject, UnifiedVideoEditorSDK.AudioServicing {
  weak public var delegate: (any UnifiedVideoEditorSDK.AudioPlayerDelegate)?
  public var currentAudio: UnifiedVideoEditorSDK.AudioServiceItem?
  public var player: AVFAudio.AVAudioPlayer?
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var playingTimeRange: CoreMedia.CMTimeRange?
  public var rate: Swift.Float {
    get
    set
  }
  public func autoRepeat(repeat: Swift.Bool)
  public func autoRepeat(repeat: Swift.Bool, delay: Swift.Double = .zero)
  public func seekToStart(isEnabled: Swift.Bool)
  public func createAudioDirectory()
  public func setRate(_ rate: Swift.Float)
  public func changeVolume(volume: Swift.Float)
  public func load(item: UnifiedVideoEditorSDK.AudioServiceItem) throws
  public func load(trackUrl: Foundation.URL) throws
  public func unload()
  public func toggle()
  public func play()
  public func pause()
  public func seekToStart()
  public func seek(to: Foundation.TimeInterval)
  public func setDelegate(_ delegate: any UnifiedVideoEditorSDK.AudioPlayerDelegate)
  @objc override dynamic public init()
  @objc deinit
}
extension UnifiedVideoEditorSDK.AudioService : AVFAudio.AVAudioPlayerDelegate {
  @objc dynamic public func audioPlayerDidFinishPlaying(_ player: AVFAudio.AVAudioPlayer, successfully flag: Swift.Bool)
}
extension UnifiedVideoEditorSDK.AudioServicing {
  public var musicTrack: UnifiedVideoEditorSDK.MediaTrack? {
    get
  }
}
@_hasMissingDesignatedInitializers public class CancelExportHandler {
  public func cancel()
  @objc deinit
}
public class VEExport {
  public init?(videoEditorService: UnifiedVideoEditorSDK.VideoEditorService)
  @discardableResult
  public func exportVideo(to fileURL: Foundation.URL, using exportVideoInfo: UnifiedVideoEditorSDK.ExportVideoInfo, watermarkFilterModel: UnifiedVideoEditorSDK.VideoEditorFilterModel?, exportProgress: ((Swift.Float) -> Swift.Void)?, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  @discardableResult
  public func exportAudio(to fileURL: Foundation.URL, audioSettings: [Swift.String : Any] = VESettings.audio, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  @discardableResult
  public func exportSlideshowImages(_ images: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol], to fileUrl: Foundation.URL? = nil, videoResolution: UnifiedVideoEditorSDK.VideoResolution, completion: ((Foundation.URL, (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler
  @discardableResult
  public func exportAudio(to fileURL: Foundation.URL, from asset: AVFoundation.AVAsset, audioSettings: [Swift.String : Any] = VESettings.audio, completion: ((_ error: (any Swift.Error)?) -> Swift.Void)?) -> UnifiedVideoEditorSDK.CancelExportHandler?
  @objc deinit
}
public protocol ExternalLogListener {
  func log(message: Swift.String)
  func log(error: Swift.String)
}
@_hasMissingDesignatedInitializers open class Logger {
  public static var externalListener: (any UnifiedVideoEditorSDK.ExternalLogListener)?
  open class func logError(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logDegug(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logInfo(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logFault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  open class func logDefault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "", file: Swift.String = #fileID, line: Swift.Int = #line)
  @objc deinit
}
public struct CaptionsConfiguration {
  public var captionsUploadUrl: Swift.String?
  public var captionsTranscribeUrl: Swift.String?
  public var apiKey: Swift.String?
  public var progressBarColor: UIKit.UIColor
  public var progressBarBackgroundColor: UIKit.UIColor
  public var supportedLanguages: [UnifiedVideoEditorSDK.CaptionsLanguage]
  public var languageConfiguration: UnifiedVideoEditorSDK.CaptionLanguageConfiguration
}
public protocol ExternalMaskProviding {
  var didReceiveExternalMasks: (([any UnifiedVideoEditorSDK.ExternalMask]) -> Swift.Void)? { get set }
  var masks: [any UnifiedVideoEditorSDK.ExternalMask] { get }
  func requestMask(_ mask: any UnifiedVideoEditorSDK.ExternalMask, statusUpdateHandler: ((UnifiedVideoEditorSDK.ExternalMaskStatus) -> Swift.Void)?)
  func cancelMaskDownloading(_ mask: any UnifiedVideoEditorSDK.ExternalMask)
  func requestMaskPreview(_ mask: any UnifiedVideoEditorSDK.ExternalMask, completion: ((UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)?)
}
public protocol ExternalMask {
  var id: Swift.UInt { get }
  var maskType: Swift.String? { get }
  var name: Swift.String { get }
  var url: Foundation.URL { get }
  var previewImageURL: Foundation.URL { get }
  var status: UnifiedVideoEditorSDK.ExternalMaskStatus { get }
}
public enum ExternalMaskStatus : Swift.Equatable {
  case startDownloading
  case notDownloaded
  case downloaded(path: Foundation.URL, shouldApply: Swift.Bool)
  case downloading(progress: Swift.Float)
  case error(any Swift.Error)
  public static let downloadEffectMaxProgress: Swift.Float
  public static let downloadEffectMinProgress: Swift.Float
  public static func == (lhs: UnifiedVideoEditorSDK.ExternalMaskStatus, rhs: UnifiedVideoEditorSDK.ExternalMaskStatus) -> Swift.Bool
}
public struct VideoSequenceNameDuplacatesFinder {
  public let sequenceName: Swift.String
  public init(sequenceName: Swift.String)
  public func findDuplicates(inSequenceNames sequenceNames: [Swift.String]) -> [Swift.String]
  public func getIndex(fromName: Swift.String?) -> Swift.Int?
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class BaseTrackSelectionViewController : UIKit.UINavigationController, UnifiedVideoEditorSDK.TrackSelectionViewController {
  @_Concurrency.MainActor(unsafe) weak public var trackSelectionDelegate: (any UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate)?
  @available(iOS 5.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol TrackSelectionViewControllerDelegate : AnyObject {
  func trackSelectionViewController(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, timeRange: CoreMedia.CMTimeRange?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func trackSelectionViewControllerDidCancel(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController)
  func trackSelectionViewControllerDiscardCurrentTrack(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController)
}
extension UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewController(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL? = nil, timeRange: CoreMedia.CMTimeRange? = nil, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
}
extension UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewControllerDiscardCurrentTrack(viewController: any UnifiedVideoEditorSDK.TrackSelectionViewController)
}
public protocol TrackSelectionViewController : UIKit.UIViewController {
  var trackSelectionDelegate: (any UnifiedVideoEditorSDK.TrackSelectionViewControllerDelegate)? { get set }
}
@objc public class EffectModel : ObjectiveC.NSObject {
  public var id: Swift.UInt
  public var url: Foundation.URL?
  public var name: Swift.String?
  public init(id: Swift.UInt, url: Foundation.URL)
  public init(id: Swift.UInt, name: Swift.String)
  @objc deinit
}
public class VideoEditorEffectDrawer : UnifiedVideoEditorSDK.CompositionRenderering {
  public var renderer: (any UnifiedVideoEditorSDK.EffectRenderer)? {
    get
  }
  required public init()
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, effect: any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol, additionalParameters: [Swift.String : Any]?)
  public func cleanUpResources()
  @objc deinit
}
public enum VideoTextAlignment : Swift.Int {
  case left
  case center
  case right
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension CoreFoundation.CGRect {
  public func getCenter() -> CoreFoundation.CGPoint
}
@objc @_inheritsConvenienceInitializers public class SDKLogger : ObjectiveC.NSObject {
  public static func debugPrint(_ text: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public struct EffectIDs {
  public static let colorEffectStartId: Swift.UInt
  public static let maskEffectStartId: Swift.UInt
  public static let speedEffectStartId: Swift.UInt
  public static let visualEffectStartId: Swift.UInt
  public static let transformEffectId: Swift.UInt
  public static let blurEffectId: Swift.UInt
}
@_hasMissingDesignatedInitializers public class BanubaMaskRenderer : UnifiedVideoEditorSDK.EffectRenderer {
  public static var postprocessServicing: (any UnifiedVideoEditorSDK.SDKMaskPostprocessServicing)?
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String, additionalParameters: [Swift.String : Any]?)
  @objc deinit
  public static func destroy()
  public static func loadEffectPath(_ path: Swift.String)
}
public protocol ReflectedStringConvertible : Swift.CustomStringConvertible {
}
extension UnifiedVideoEditorSDK.ReflectedStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol ImageModifier {
  func modify(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
public struct AnyImageModifier : UnifiedVideoEditorSDK.ImageModifier {
  public init(modify: @escaping (UnifiedVideoEditorSDK.KFCrossPlatformImage) throws -> UnifiedVideoEditorSDK.KFCrossPlatformImage)
  public func modify(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : UnifiedVideoEditorSDK.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : UnifiedVideoEditorSDK.ImageModifier {
  public init()
  public func modify(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : UnifiedVideoEditorSDK.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: UnifiedVideoEditorSDK.KFCrossPlatformImage) -> UnifiedVideoEditorSDK.KFCrossPlatformImage
}
@objc extension UIKit.UIImage {
  @objc convenience dynamic public init?(bgraDataNoCopy: Foundation.NSData, width: Swift.Int, height: Swift.Int)
  @objc dynamic public func makeBgraPixelBuffer() -> CoreVideo.CVPixelBuffer?
}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration {
  public static var config: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration {
    get
  }
}
extension UnifiedVideoEditorSDK.FullScreenActivityConfiguration {
  public static var config: UnifiedVideoEditorSDK.FullScreenActivityConfiguration {
    get
  }
}
extension UnifiedVideoEditorSDK.WatermarkConfiguration {
  public static var config: UnifiedVideoEditorSDK.WatermarkConfiguration {
    get
  }
}
public protocol EffectsManagement : AnyObject {
  func getStoredEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  func getCurrentAppliedEffects(type: UnifiedVideoEditorSDK.EditorEffectType) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  func applyEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime, removeSameType: Swift.Bool, isAutoCutEffect: Swift.Bool)
  func startCurrentEffect(effectModel: UnifiedVideoEditorSDK.VideoEditorFilterModel, at: CoreMedia.CMTime)
  func endCurrentEffect(at: CoreMedia.CMTime)
  func undoEffect(uuid: Swift.String) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  func undoLast(type: UnifiedVideoEditorSDK.EditorEffectType) -> (any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol)?
  func undoAll(type: UnifiedVideoEditorSDK.EditorEffectType)
  func undoAll(except: UnifiedVideoEditorSDK.EditorEffectType)
  func undoAll()
  func getSpeed(at time: CoreMedia.CMTime) -> Swift.Float
  func changeEffectTimeRange(with uuid: Swift.String, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
  func hasChangesInAppliedEffects() -> Swift.Bool
  func storeStack()
  func restoreStack()
}
@objc public protocol AlbumModel {
  @objc var name: Swift.String? { get set }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var assetCollection: Photos.PHAssetCollection { get }
}
@objc public class AlbumViewModel : ObjectiveC.NSObject, UnifiedVideoEditorSDK.AlbumModel {
  final public let model: UnifiedVideoEditorSDK.ItemCollectionModel
  @objc final public let assetCollection: Photos.PHAssetCollection
  @objc public var name: Swift.String?
  @objc public var preview: UIKit.UIImage?
  public var itemsCount: Swift.Int
  public init(collection: UnifiedVideoEditorSDK.ItemCollectionModel)
  public func requestPreview(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc deinit
}
public protocol ExportScalable {
  func exportScaled(outputUrl: Foundation.URL, quality: Swift.String, trimData: UnifiedVideoEditorSDK.VideoTrimData?, completion: (((any Swift.Error)?) -> Swift.Void)?)
}
public protocol AssetEditable {
  func addTracks(_ tracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo], atIndex index: Swift.Int)
  func removeTrack(at index: Swift.Int)
  func removeTrack(_ track: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo)
  func moveTrack(fromIndex: Swift.Int, toIndex: Swift.Int)
  func reorderTracks(withTracks reorderedTracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo])
}
public struct VideoEditorAssetMusicTrack {
  public let track: UnifiedVideoEditorSDK.MediaTrack
  public let trackId: CoreMedia.CMPersistentTrackID
}
public class VideoEditorAsset {
  public var composition: AVFoundation.AVMutableComposition!
  public var instructions: [any AVFoundation.AVVideoCompositionInstructionProtocol]? {
    get
  }
  public var errors: [any Swift.Error] {
    get
  }
  public var tracksInfo: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo] {
    get
  }
  final public let videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration
  public var videoResolutionCurrentSize: CoreFoundation.CGSize?
  public var fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat>
  public var musicTracks: [UnifiedVideoEditorSDK.VideoEditorAssetMusicTrack] {
    get
  }
  public init(tracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo], isDebugModeOn: Swift.Bool = false, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> = CGFloat(0)...CGFloat(0), videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration)
  convenience public init(sequence: UnifiedVideoEditorSDK.VideoSequence, isGalleryAssets: Swift.Bool, isSlideShow: Swift.Bool, isDebugModeOn: Swift.Bool = false, fillAspectRatioRange: Swift.ClosedRange<CoreFoundation.CGFloat> = CGFloat(0)...CGFloat(0), videoResolutionConfiguration: UnifiedVideoEditorSDK.VideoResolutionConfiguration)
  public func reloadComposition()
  public func loadNonExistingThumbnails(completion: (() -> ())?)
  public func getPartIndex(at time: CoreMedia.CMTime) -> Swift.Int?
  @objc deinit
}
extension UnifiedVideoEditorSDK.VideoEditorAsset {
  public func changeMusicTrackPosition(_ musicTrack: UnifiedVideoEditorSDK.MediaTrack) -> Swift.Bool
  public func hasMusicTrack(with trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  @discardableResult
  public func addMusicTrack(_ musicTrack: UnifiedVideoEditorSDK.MediaTrack) -> (compositionTrack: AVFoundation.AVMutableCompositionTrack, assetTrack: AVFoundation.AVAssetTrack)?
  @discardableResult
  public func removeMusic(trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  public func removeAllMusic()
}
extension UnifiedVideoEditorSDK.VideoEditorAsset : UnifiedVideoEditorSDK.ExportScalable {
  public func exportScaled(outputUrl: Foundation.URL, quality: Swift.String, trimData: UnifiedVideoEditorSDK.VideoTrimData?, completion: (((any Swift.Error)?) -> Swift.Void)?)
}
extension UnifiedVideoEditorSDK.VideoEditorAsset : UnifiedVideoEditorSDK.AssetEditable {
  public func addTracks(_ tracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo], atIndex index: Swift.Int)
  public func removeTrack(at index: Swift.Int)
  public func removeTrack(_ track: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo)
  public func moveTrack(fromIndex: Swift.Int, toIndex: Swift.Int)
  public func reorderTracks(withTracks reorderedTracks: [UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo])
}
public enum MemoryStorage {
  public class Backend<T> where T : UnifiedVideoEditorSDK.CacheCostCalculable {
    public var config: UnifiedVideoEditorSDK.MemoryStorage.Config {
      get
      set
    }
    public init(config: UnifiedVideoEditorSDK.MemoryStorage.Config)
    public func removeExpired()
    public func store(value: T, forKey key: Swift.String, expiration: UnifiedVideoEditorSDK.StorageExpiration? = nil)
    public func value(forKey key: Swift.String, extendingExpiration: UnifiedVideoEditorSDK.ExpirationExtending = .cacheTime) -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func remove(forKey key: Swift.String)
    public func removeAll()
    @objc deinit
  }
}
extension UnifiedVideoEditorSDK.MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: UnifiedVideoEditorSDK.StorageExpiration
    public var cleanInterval: Foundation.TimeInterval
    public var keepWhenEnteringBackground: Swift.Bool
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class CircularProgressView : UIKit.UIView, UnifiedVideoEditorSDK.ProgressAnimatableView {
  @_Concurrency.MainActor(unsafe) public var progressColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shadowColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var progress: Swift.Float {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shadowLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var progressLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSublayers(of layer: QuartzCore.CALayer)
  @_Concurrency.MainActor(unsafe) public func resetProgress()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class VideoCompositionRenderQueue {
  public static let queue: Dispatch.DispatchQueue
  @objc deinit
}
public class ShapeDrawer : UnifiedVideoEditorSDK.CompositionRenderering {
  public var shapeTexture: (any Metal.MTLTexture)?
  required public init()
  public init(renderer: any UnifiedVideoEditorSDK.EffectRenderer)
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source allSources: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, effect: any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol, additionalParameters: [Swift.String : Any]?)
  @objc deinit
}
public protocol ImageTextButtonConfigurationProtocol {
  var imageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? { get set }
  var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? { get set }
  var style: UnifiedVideoEditorSDK.TextConfiguration? { get set }
}
public struct GalleryItemConfiguration {
  public var orderNumberBackgroudColor: UIKit.UIColor
  public var orderNumberSelectedBackgroudColor: UIKit.UIColor
  public var orderNumberTitleColor: UIKit.UIColor
  public var orderNumberTitleFont: UIKit.UIFont
  public var orderNumberBorderWidth: CoreFoundation.CGFloat
  public var orderNumberSelectedBorderWidth: CoreFoundation.CGFloat
  public var orderNumberBorderColor: UIKit.UIColor
  public var durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var durationLabelBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var durationLabelAlignment: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment
  public var activityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration
  public var cornerRadius: CoreFoundation.CGFloat
  public init(orderNumberBackgroudColor: UIKit.UIColor, orderNumberSelectedBackgroudColor: UIKit.UIColor, orderNumberTitleColor: UIKit.UIColor, orderNumberTitleFont: UIKit.UIFont, orderNumberBorderWidth: CoreFoundation.CGFloat, orderNumberSelectedBorderWidth: CoreFoundation.CGFloat, orderNumberBorderColor: UIKit.UIColor, durationLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, durationLabelBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, durationLabelAlignment: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment, activityIndicatorConfiguration: UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration, cornerRadius: CoreFoundation.CGFloat)
  public enum DurationLabelAlignment {
    case left
    case right
    public static func == (a: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment, b: UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol TextEditSelectionColorBehavior {
  func setColorView(_ view: UIKit.UIView, selected: Swift.Bool, animated: Swift.Bool)
}
public class EffectMetalRenderer : UnifiedVideoEditorSDK.EffectRenderer {
  required public init()
  public func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, startTime: CoreMedia.CMTime, path: Swift.String, additionalParameters: [Swift.String : Any]?)
  @objc deinit
}
public enum RenderBehavior {
  case fullScreen
  case verticalSplitUp
  case verticalSplitDown
  case horizontalSplitLeft
  case horizontalSplitRight
  case pip
  public static func == (a: UnifiedVideoEditorSDK.RenderBehavior, b: UnifiedVideoEditorSDK.RenderBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class DefaultExposureViewFactory : UnifiedVideoEditorSDK.AnimatableViewFactory {
  public init()
  public func makeAnimatableView() -> any UnifiedVideoEditorSDK.AnimatableView
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class ExposureAnimationView : UIKit.UIView, UnifiedVideoEditorSDK.AnimatableView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func draw(_ rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) public func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func stop()
  @objc deinit
}
extension UIKit.UIColor {
  public var colorComponents: (red: CoreFoundation.CGFloat, green: CoreFoundation.CGFloat, blue: CoreFoundation.CGFloat, alpha: CoreFoundation.CGFloat)? {
    get
  }
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
  convenience public init(rgb: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
}
@_hasMissingDesignatedInitializers public class EffectStack {
  public func getAllEffects(at time: CoreMedia.CMTime, from: [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func embed(toView view: UIKit.UIView, topOffset: CoreFoundation.CGFloat = .zero, leftOffset: CoreFoundation.CGFloat = .zero, rightOffset: CoreFoundation.CGFloat = .zero, bottomOffset: CoreFoundation.CGFloat = .zero, forceLayoutPass: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func unembed()
}
public struct PlayerControlConfiguration {
  public var playButtonImageName: Swift.String
  public var pauseButtonImageName: Swift.String
  public var tintColor: UIKit.UIColor?
  public var playImage: UIKit.UIImage?
  public var pauseImage: UIKit.UIImage?
  public init(playButtonImageName: Swift.String, pauseButtonImageName: Swift.String, tintColor: UIKit.UIColor? = nil)
  public init(playImage: UIKit.UIImage?, pauseImage: UIKit.UIImage?)
}
@_hasMissingDesignatedInitializers public class AudioMixer {
  public struct VolumeDefaults {
    public static let mutedVolume: Swift.Float
    public static let defaultVolume: Swift.Float
  }
  public func getAudioMix(for asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  public func resetTrackVolumeToDefault(trackId: CoreMedia.CMPersistentTrackID)
  public func setVolume(_ volume: Swift.Float, forTrackId trackId: CoreMedia.CMPersistentTrackID)
  public func volume(forTrackId trackId: CoreMedia.CMPersistentTrackID) -> Swift.Float
  public func isVolumeDefault(forTrackId trackId: CoreMedia.CMPersistentTrackID) -> Swift.Bool
  public func mutedMusicMix(asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  public func mutedAudioMix(asset: AVFoundation.AVAsset?) -> AVFoundation.AVAudioMix?
  @objc deinit
}
public struct ItemCollectionModel {
  public var assetCollection: Photos.PHAssetCollection
  public var previewAsset: Photos.PHAsset?
}
public protocol GalleryAdapter : AnyObject {
  var changesHandler: UnifiedVideoEditorSDK.GalleryManager.ChangesHandler? { get set }
  func checkAccessStatus(completion: @escaping (Swift.Bool) -> ())
  func getPreviewImageForGallery(completion: @escaping (UIKit.UIImage?) -> ())
  func fetchMediaAsset(from album: Photos.PHAssetCollection?, type: Photos.PHAssetMediaType, limit: Swift.Int?) -> [any UnifiedVideoEditorSDK.GalleryItem]
  func fetchSmartAlbums() -> [UnifiedVideoEditorSDK.ItemCollectionModel]
  func register()
}
extension UnifiedVideoEditorSDK.GalleryAdapter {
  public func fetchMediaAsset(from album: Photos.PHAssetCollection?, type: Photos.PHAssetMediaType, limit: Swift.Int? = nil) -> [any UnifiedVideoEditorSDK.GalleryItem]
}
@objc final public class GalleryManager : ObjectiveC.NSObject, UnifiedVideoEditorSDK.GalleryAdapter {
  final public let videoResolution: UnifiedVideoEditorSDK.VideoResolution
  final public let minimumDurationFromGallery: Foundation.TimeInterval
  final public var changesHandler: UnifiedVideoEditorSDK.GalleryManager.ChangesHandler?
  public typealias ChangesHandler = ((Photos.PHChange, [Photos.PHAsset]?, [Photos.PHAsset]?) -> Swift.Void)
  final public var authorizationStatus: Photos.PHAuthorizationStatus {
    get
  }
  final public var isCollectionsObserve: Swift.Bool
  required public init(isManuallyRegister: Swift.Bool, videoResolution: UnifiedVideoEditorSDK.VideoResolution, minimumDurationFromGallery: Foundation.TimeInterval)
  final public func register()
  final public func getPreviewImageForGallery(completion: @escaping (UIKit.UIImage?) -> ())
  final public func fetchAssets(in collection: Photos.PHAssetCollection, options: Photos.PHFetchOptions) -> Photos.PHFetchResult<Photos.PHAsset>
  @objc deinit
}
extension UnifiedVideoEditorSDK.GalleryManager : Photos.PHPhotoLibraryChangeObserver {
  @objc final public func photoLibraryDidChange(_ changeInstance: Photos.PHChange)
}
extension UnifiedVideoEditorSDK.GalleryManager {
  final public func fetchCollections(isNeedToStoreAssets: Swift.Bool) -> [UnifiedVideoEditorSDK.ItemCollectionModel]
  final public func fetchSmartAlbums() -> [UnifiedVideoEditorSDK.ItemCollectionModel]
  final public func fetchPhotoAndVideoAssets() -> [UnifiedVideoEditorSDK.BanubaGalleryItem]
  final public func fetchMediaAsset(from album: Photos.PHAssetCollection? = nil, type: Photos.PHAssetMediaType, limit: Swift.Int?) -> [any UnifiedVideoEditorSDK.GalleryItem]
  final public func checkAccessStatus(completion: @escaping (Swift.Bool) -> ())
}
extension UnifiedVideoEditorSDK.GalleryManager {
  public static func requestAccessIfNeeded(completion: @escaping (Swift.Bool) -> ())
}
public protocol VideoEditorEffectImageProvider {
  func provideImage(for textureSize: CoreFoundation.CGSize) -> UIKit.UIImage
}
public struct VideoEditorEffectInfo {
  public let uuid: Swift.String
  public let image: UIKit.UIImage?
  public let imageProvider: (any UnifiedVideoEditorSDK.VideoEditorEffectImageProvider)?
  public let relativeScreenPoints: UnifiedVideoEditorSDK.ImagePoints?
  public let start: CoreMedia.CMTime
  public let end: CoreMedia.CMTime
  public init(uuid: Swift.String, image: UIKit.UIImage? = nil, imageProvider: (any UnifiedVideoEditorSDK.VideoEditorEffectImageProvider)? = nil, relativeScreenPoints: UnifiedVideoEditorSDK.ImagePoints? = nil, start: CoreMedia.CMTime, end: CoreMedia.CMTime)
}
public protocol ImageButtonConfigurationProtocol {
  var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol { get set }
  var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? { get set }
}
public struct BanubaImageButtonConfiguration : UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol {
  public var imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?
  public init(imageConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, selectedImageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)? = nil)
}
@_hasMissingDesignatedInitializers public class VideoEditorTrackRotationCalculator {
  public static func getTrackRotation(_ track: UnifiedVideoEditorSDK.VideoEditorAssetTrackInfo) -> UnifiedVideoEditorSDK.AssetRotation
  @objc deinit
}
@objc public protocol GalleryViewControllerDelegate {
  @objc func galleryViewController(_ controller: UnifiedVideoEditorSDK.GalleryViewController, didStartExportWith progressHandler: UnifiedVideoEditorSDK.ProgressHandler)
  @objc func galleryViewController(_ controller: UnifiedVideoEditorSDK.GalleryViewController, didEndExportWith error: (any Swift.Error)?, hideProgressViewCompletion: @escaping () -> Swift.Void)
  @objc func galleryViewControllerDidClose(_ controller: UnifiedVideoEditorSDK.GalleryViewController)
  @objc func galleryViewControllerDone(_ controller: UnifiedVideoEditorSDK.GalleryViewController, withGalleryItems items: [any UnifiedVideoEditorSDK.GalleryItem])
  @objc func galleryViewControllerDoneForAutoCut(_ controller: UnifiedVideoEditorSDK.GalleryViewController, withGalleryItems items: [any UnifiedVideoEditorSDK.GalleryItem])
  @objc func galleryViewController(_ controller: UnifiedVideoEditorSDK.GalleryViewController, presentMessage message: Swift.String)
}
@objc public enum GalleryMediaType : Swift.Int, Swift.CaseIterable {
  case video
  case photo
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UnifiedVideoEditorSDK.GalleryMediaType]
  public typealias RawValue = Swift.Int
  public static var allCases: [UnifiedVideoEditorSDK.GalleryMediaType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class GallerySelectionBehaviour : ObjectiveC.NSObject {
  final public let maximumSelectedCount: Swift.Int
  final public let selectedItemsCount: Swift.Int?
  final public let isMultiselectModeEnabled: Swift.Bool
  final public let minimumGalleryVideoDuration: Foundation.TimeInterval
  final public let allowedMediaTypes: [UnifiedVideoEditorSDK.GalleryMediaType]
  final public let slideshowDuration: Foundation.TimeInterval
  public init(maximumSelectedCount: Swift.Int, selectedItemsCount: Swift.Int? = nil, isMultiselectModeEnabled: Swift.Bool, minimumGalleryVideoDuration: Foundation.TimeInterval, allowedMediaTypes: [UnifiedVideoEditorSDK.GalleryMediaType], slideshowDuration: Foundation.TimeInterval)
  public var isAdditionalItemsRequired: Swift.Bool {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class GalleryViewController : UIKit.UIViewController, UnifiedVideoEditorSDK.AlertPresentable {
  @_Concurrency.MainActor(unsafe) weak open var delegate: (any UnifiedVideoEditorSDK.GalleryViewControllerDelegate)?
  @_Concurrency.MainActor(unsafe) open var configuration: UnifiedVideoEditorSDK.GalleryConfiguration?
  @_Concurrency.MainActor(unsafe) open var selectionBehaviour: UnifiedVideoEditorSDK.GallerySelectionBehaviour?
  @_Concurrency.MainActor(unsafe) open func useAlbum(_ albumView: any UnifiedVideoEditorSDK.AlbumModel)
  @_Concurrency.MainActor(unsafe) open func cancelExport()
  @_Concurrency.MainActor(unsafe) open func retryExport()
  @_Concurrency.MainActor(unsafe) open func getAlertViewController() -> UnifiedVideoEditorSDK.AlertViewController?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class AlbumsViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) weak open var delegate: (any UnifiedVideoEditorSDK.AlbumsViewControllerDelegate)?
  @_Concurrency.MainActor(unsafe) open var configuration: UnifiedVideoEditorSDK.AlbumsConfiguration?
  @_Concurrency.MainActor(unsafe) open var selectedAlbum: (any UnifiedVideoEditorSDK.AlbumModel)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public protocol AlbumsViewControllerDelegate {
  @objc func albumsViewController(_ controller: UnifiedVideoEditorSDK.AlbumsViewController, didSelect album: any UnifiedVideoEditorSDK.AlbumModel)
  @objc func albumsViewControllerDidClose(_ controller: UnifiedVideoEditorSDK.AlbumsViewController)
}
@_inheritsConvenienceInitializers @objc public class ProgressHandler : ObjectiveC.NSObject {
  public var callback: ((Swift.Double) -> Swift.Void)?
  @objc override dynamic public init()
  @objc deinit
}
public enum FileExtension {
  public enum Video : Swift.String {
    case mp4
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  @discardableResult
  public func setImage(with source: UnifiedVideoEditorSDK.Source?, attributedView: @autoclosure @escaping () -> UnifiedVideoEditorSDK.KFCrossPlatformView, placeholder: UnifiedVideoEditorSDK.KFCrossPlatformImage? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any UnifiedVideoEditorSDK.Resource)?, attributedView: @autoclosure @escaping () -> UnifiedVideoEditorSDK.KFCrossPlatformView, placeholder: UnifiedVideoEditorSDK.KFCrossPlatformImage? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  public func cancelDownloadTask()
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  public var taskIdentifier: UnifiedVideoEditorSDK.Source.Identifier.Value? {
    get
  }
}
extension Swift.Int32 {
  public static let `default`: CoreMedia.CMTimeScale
}
@objc public enum PIPSwitchLayoutSettings : Swift.Int {
  case switchVerticallyUP
  case switchVerticallyDown
  case switchHorizontalRight
  case switchHorizontalLeft
  case switchCameraPiP
  case switchVideoPiP
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum PIPCameraLayoutSettings : Swift.Int {
  case round
  case square
  case original
  case centered
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum PIPPlayerLayoutSettings : Swift.Int {
  case floating
  case topBottom
  case react
  case leftRight
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum RenderBehaviorAdapter : Swift.Int {
  case fullScreen
  case verticalSplitUp
  case verticalSplitDown
  case horizontalSplitLeft
  case horizontalSplitRight
  case pip
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum PIPShapeAdapter : Swift.Int {
  case none
  case oval
  case circle
  case roundRect
  case roundSquare
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class PIPSwitchLayoutSetting : ObjectiveC.NSObject {
  @objc final public let setting: UnifiedVideoEditorSDK.PIPSwitchLayoutSettings
  @objc public init(setting: UnifiedVideoEditorSDK.PIPSwitchLayoutSettings)
  @objc public static var switchVerticallyUP: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting {
    @objc get
  }
  @objc public static var switchVerticallyDown: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting {
    @objc get
  }
  @objc public static var switchHorizontalRight: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting {
    @objc get
  }
  @objc public static var switchHorizontalLeft: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting {
    @objc get
  }
  @objc public static var switchCameraPip: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting {
    @objc get
  }
  @objc public static var switchVideoPip: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting {
    @objc get
  }
  public static func == (lhs: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting, rhs: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting) -> Swift.Bool
  @objc deinit
}
@objc public class PIPCameraLayoutSetting : ObjectiveC.NSObject {
  @objc final public let setting: UnifiedVideoEditorSDK.PIPCameraLayoutSettings
  @objc public init(setting: UnifiedVideoEditorSDK.PIPCameraLayoutSettings)
  @objc public static var round: UnifiedVideoEditorSDK.PIPCameraLayoutSetting {
    @objc get
  }
  @objc public static var square: UnifiedVideoEditorSDK.PIPCameraLayoutSetting {
    @objc get
  }
  @objc public static var original: UnifiedVideoEditorSDK.PIPCameraLayoutSetting {
    @objc get
  }
  @objc public static var centered: UnifiedVideoEditorSDK.PIPCameraLayoutSetting {
    @objc get
  }
  public static func == (lhs: UnifiedVideoEditorSDK.PIPCameraLayoutSetting, rhs: UnifiedVideoEditorSDK.PIPCameraLayoutSetting) -> Swift.Bool
  @objc deinit
}
@objc public class PIPPlayerLayoutSetting : ObjectiveC.NSObject {
  @objc final public let setting: UnifiedVideoEditorSDK.PIPPlayerLayoutSettings
  @objc public init(setting: UnifiedVideoEditorSDK.PIPPlayerLayoutSettings)
  @objc public static var floating: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting {
    @objc get
  }
  @objc public static var topBottom: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting {
    @objc get
  }
  @objc public static var react: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting {
    @objc get
  }
  @objc public static var leftRight: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting {
    @objc get
  }
  public static func == (lhs: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, rhs: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting) -> Swift.Bool
  @objc deinit
}
@objc public class PIPShapeTypeAdapter : ObjectiveC.NSObject {
  @objc final public let setting: UnifiedVideoEditorSDK.PIPShapeAdapter
  @objc final public let radius: CoreFoundation.CGFloat
  @objc public init(setting: UnifiedVideoEditorSDK.PIPShapeAdapter, radius: CoreFoundation.CGFloat = .zero)
  @objc public static var none: UnifiedVideoEditorSDK.PIPShapeTypeAdapter {
    @objc get
  }
  @objc public static var oval: UnifiedVideoEditorSDK.PIPShapeTypeAdapter {
    @objc get
  }
  @objc public static var circle: UnifiedVideoEditorSDK.PIPShapeTypeAdapter {
    @objc get
  }
  @objc public static func roundRect(radius: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.PIPShapeTypeAdapter
  @objc public static func roundSquare(radius: CoreFoundation.CGFloat) -> UnifiedVideoEditorSDK.PIPShapeTypeAdapter
  public static func == (lhs: UnifiedVideoEditorSDK.PIPShapeTypeAdapter, rhs: UnifiedVideoEditorSDK.PIPShapeTypeAdapter) -> Swift.Bool
  @objc deinit
}
@objc public protocol SDKPIPServicing {
  @objc var isPIPSessionAlreadySetup: Swift.Bool { get set }
  @objc var isPIPSession: Swift.Bool { get set }
  @objc var isPIPPlayerReadyToProvideData: Swift.Bool { get }
  @objc var pipVideoURL: Foundation.URL? { get set }
  @objc var pipSwitchSetting: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting? { get set }
  @objc var pipPlayerSetting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting? { get set }
  @objc var pipCameraSetting: UnifiedVideoEditorSDK.PIPCameraLayoutSetting? { get set }
  @objc func seekPIPPlayer(to time: Foundation.TimeInterval)
  @objc func startPIPPlayer()
  @objc func stopPIPPlayer()
  @objc func setupPIPSession(withVideoURL url: Foundation.URL, playerSetting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, cameraSetting: UnifiedVideoEditorSDK.PIPCameraLayoutSetting, switchSetting: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting)
  @objc func startPIPSessionIfNeeded(withSetting setting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, completion: (() -> Swift.Void)?)
  @objc func applyPIPCameraSettingIfNeeded(_ setting: UnifiedVideoEditorSDK.PIPCameraLayoutSetting, restoreSession: Swift.Bool)
  @objc func applyPIPPlayerSettingIfNeeded(_ setting: UnifiedVideoEditorSDK.PIPPlayerLayoutSetting, restoreSession: Swift.Bool)
  @objc func applyPIPSwitchSettingIfNeeded(_ setting: UnifiedVideoEditorSDK.PIPSwitchLayoutSetting, restoreSession: Swift.Bool)
  @objc func setPIPPlayerVolume(_ volume: Swift.Float)
}
public class AverageSum {
  public init(name: Swift.String, skipFirstCount: Swift.Int, autoprint: Swift.Bool = true, autoprintInterval: Swift.UInt = 100)
  @objc deinit
}
@_inheritsConvenienceInitializers public class AverageTimeSum : UnifiedVideoEditorSDK.AverageSum {
  public func begin()
  public func end()
  override public init(name: Swift.String, skipFirstCount: Swift.Int, autoprint: Swift.Bool = super, autoprintInterval: Swift.UInt = super)
  @objc deinit
}
public struct WatermarkConfiguration {
  public var watermark: UnifiedVideoEditorSDK.ImageConfiguration
  public var size: CoreFoundation.CGSize
  public var sharedOffset: CoreFoundation.CGFloat
  public var position: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition
  public var id: Swift.UInt?
  public enum WatermarkPosition {
    case leftTop
    case leftBottom
    case rightTop
    case rightBottom
    public static func == (a: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition, b: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var expiredWatermarkId: Swift.UInt
  public static var expiredWatermark: UnifiedVideoEditorSDK.WatermarkConfiguration {
    get
  }
  public init(watermark: UnifiedVideoEditorSDK.ImageConfiguration, size: CoreFoundation.CGSize, sharedOffset: CoreFoundation.CGFloat, position: UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition, id: Swift.UInt? = nil)
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct KingfisherWrapper<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol KingfisherCompatible : AnyObject {
}
public protocol KingfisherCompatibleValue {
}
extension UnifiedVideoEditorSDK.KingfisherCompatible {
  public var kf: UnifiedVideoEditorSDK.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UnifiedVideoEditorSDK.KingfisherCompatibleValue {
  public var kf: UnifiedVideoEditorSDK.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UIKit.UIImage : UnifiedVideoEditorSDK.KingfisherCompatible {
}
extension UIKit.UIImageView : UnifiedVideoEditorSDK.KingfisherCompatible {
}
extension UIKit.UIButton : UnifiedVideoEditorSDK.KingfisherCompatible {
}
extension UIKit.NSTextAttachment : UnifiedVideoEditorSDK.KingfisherCompatible {
}
public struct AlertViewConfiguration {
  public var backgroundColor: UIKit.UIColor
  public var alertBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var resetButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var resetCancelTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var additionalButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var refuseButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var agreeButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var titleTextConfig: UnifiedVideoEditorSDK.TextConfiguration
  public var messageTextConfig: UnifiedVideoEditorSDK.TextConfiguration
  public var spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat
  public var titleAndMessageInsets: UIKit.UIEdgeInsets
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public init(backgroundColor: UIKit.UIColor, alertBackgroundConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, resetButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, resetCancelTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, refuseButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, agreeButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, additionalButtonTextConfig: UnifiedVideoEditorSDK.TextButtonConfiguration, titleTextConfig: UnifiedVideoEditorSDK.TextConfiguration, messageTextConfig: UnifiedVideoEditorSDK.TextConfiguration, spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat, titleAndMessageInsets: UIKit.UIEdgeInsets, preferredStatusBarStyle: UIKit.UIStatusBarStyle)
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImageView {
  @discardableResult
  public func setImage(with source: UnifiedVideoEditorSDK.Source?, placeholder: (any UnifiedVideoEditorSDK.Placeholder)? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with source: UnifiedVideoEditorSDK.Source?, placeholder: (any UnifiedVideoEditorSDK.Placeholder)? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any UnifiedVideoEditorSDK.Resource)?, placeholder: (any UnifiedVideoEditorSDK.Placeholder)? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any UnifiedVideoEditorSDK.Resource)?, placeholder: (any UnifiedVideoEditorSDK.Placeholder)? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with provider: (any UnifiedVideoEditorSDK.ImageDataProvider)?, placeholder: (any UnifiedVideoEditorSDK.Placeholder)? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func setImage(with provider: (any UnifiedVideoEditorSDK.ImageDataProvider)?, placeholder: (any UnifiedVideoEditorSDK.Placeholder)? = nil, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)? = nil) -> UnifiedVideoEditorSDK.DownloadTask?
  public func cancelDownloadTask()
}
extension UnifiedVideoEditorSDK.KingfisherWrapper where Base : UIKit.UIImageView {
  public var taskIdentifier: UnifiedVideoEditorSDK.Source.Identifier.Value? {
    get
  }
  public var indicatorType: UnifiedVideoEditorSDK.IndicatorType {
    get
    set
  }
  public var indicator: (any UnifiedVideoEditorSDK.Indicator)? {
    get
  }
  public var placeholder: (any UnifiedVideoEditorSDK.Placeholder)? {
    get
  }
}
extension UnifiedVideoEditorSDK.CompositionRenderering {
  public var className: Swift.String {
    get
  }
  public static var className: Swift.String {
    get
  }
  public func cleanUpResources()
}
public protocol CompositionRenderering : AnyObject {
  init()
  func render(in pixelBuffer: CoreVideo.CVPixelBuffer, source: CoreVideo.CVPixelBuffer, sampleTime: CoreMedia.CMTime, effect: any UnifiedVideoEditorSDK.EditorCompositionEffectProtocol, additionalParameters: [Swift.String : Any]?)
  func cleanUpResources()
}
@objc public class GalleryConfiguration : ObjectiveC.NSObject {
  public var videoResolution: UnifiedVideoEditorSDK.VideoResolution
  public var galleryItemConfiguration: UnifiedVideoEditorSDK.GalleryItemConfiguration
  public var closeButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol
  public var albumButtonConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var albumArrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol
  public var collectionInfoHeaderConfiguration: UnifiedVideoEditorSDK.CollectionInfoHeaderConfiguration
  public var galleryItemPreviewViewConfiguration: UnifiedVideoEditorSDK.GalleryItemPreviewViewConfiguration
  public var nextButtonConfiguration: UnifiedVideoEditorSDK.SaveButtonConfiguration
  public var noItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var layoutConfiguration: UnifiedVideoEditorSDK.GalleryLayoutConfiguration
  public var topBarBlurColor: UIKit.UIColor
  public var clearSelectionButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol
  public var galleryTypeButton: UnifiedVideoEditorSDK.TextButtonConfiguration
  public var galleryTypeUnderlineColor: UIKit.UIColor
  public var isPhotoSequenceAnimationEnabled: Swift.Bool
  public var importItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration
  public var bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration
  public var visibleTabsInGallery: [UnifiedVideoEditorSDK.GalleryMediaType]
  public var isCloseButtonHidden: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var maximumSelectedCountFromGallery: Swift.Int
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var alertConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration
  public var autoCutGalleryConfiguration: UnifiedVideoEditorSDK.AutoCutGalleryConfiguration?
  public init(videoResolution: UnifiedVideoEditorSDK.VideoResolution, galleryItemConfiguration: UnifiedVideoEditorSDK.GalleryItemConfiguration, closeButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol, albumButtonConfiguration: UnifiedVideoEditorSDK.TextButtonConfiguration, albumArrowIconConfiguration: any UnifiedVideoEditorSDK.ImageConfigurationProtocol, collectionInfoHeaderConfiguration: UnifiedVideoEditorSDK.CollectionInfoHeaderConfiguration, galleryItemPreviewViewConfiguration: UnifiedVideoEditorSDK.GalleryItemPreviewViewConfiguration, nextButtonConfiguration: UnifiedVideoEditorSDK.SaveButtonConfiguration, noItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, layoutConfiguration: UnifiedVideoEditorSDK.GalleryLayoutConfiguration, topBarBlurColor: UIKit.UIColor, clearSelectionButtonConfiguration: any UnifiedVideoEditorSDK.ImageButtonConfigurationProtocol, galleryTypeButton: UnifiedVideoEditorSDK.TextButtonConfiguration, galleryTypeUnderlineColor: UIKit.UIColor, isPhotoSequenceAnimationEnabled: Swift.Bool, importItemsLabelConfiguration: UnifiedVideoEditorSDK.TextConfiguration, bottomViewConfiguration: UnifiedVideoEditorSDK.BackgroundConfiguration, isCloseButtonHidden: Swift.Bool, visibleTabsInGallery: [UnifiedVideoEditorSDK.GalleryMediaType] = [.video, .photo], backgroundColor: UIKit.UIColor, maximumSelectedCountFromGallery: Swift.Int, preferredStatusBarStyle: UIKit.UIStatusBarStyle, alertConfiguration: UnifiedVideoEditorSDK.AlertViewConfiguration, autoCutGalleryConfiguration: UnifiedVideoEditorSDK.AutoCutGalleryConfiguration? = nil)
  @objc deinit
}
public class VideoEditorImagesSequence {
  @objc deinit
  public init(imageAssets: [any UnifiedVideoEditorSDK.VideoEditorImageAssetProtocol])
}
public protocol Resource {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension UnifiedVideoEditorSDK.Resource {
  public func convertToSource(overrideCacheKey: Swift.String? = nil) -> UnifiedVideoEditorSDK.Source
}
public struct KFImageResource : UnifiedVideoEditorSDK.Resource {
  public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
  public let cacheKey: Swift.String
  public let downloadURL: Foundation.URL
}
extension Foundation.URL : UnifiedVideoEditorSDK.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
public struct DeviceVibrateManager {
  public static func vibrate(withPower power: UIKit.UIImpactFeedbackGenerator.FeedbackStyle)
}
public protocol VideoImageEffectDrawable {
  func draw(imageTexture: any Metal.MTLTexture, in pixelBuffer: CoreVideo.CVPixelBuffer, sampleTime: Foundation.TimeInterval, startTime: Foundation.TimeInterval, endTime: Foundation.TimeInterval, imageSize: CoreFoundation.CGSize)
}
public protocol SequencesServicing {
  var aspectRatio: UnifiedVideoEditorSDK.AspectRatio { get }
  var currentSequence: UnifiedVideoEditorSDK.VideoSequence? { get }
  var lastModifiedSequence: UnifiedVideoEditorSDK.VideoSequence? { get }
  var sequences: [UnifiedVideoEditorSDK.VideoSequence] { get }
  var draftedSequences: [UnifiedVideoEditorSDK.VideoSequence] { get }
  func createNewSequence(withMusicTrack musicTrack: UnifiedVideoEditorSDK.MediaTrack?, isSlideShow: Swift.Bool, editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep, maxVideoDuration: Foundation.TimeInterval) -> UnifiedVideoEditorSDK.VideoSequence
  func cancelAndRemoveCurrentSequence()
  @discardableResult
  func removeSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence) -> Swift.Bool
  @discardableResult
  func duplicateSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence, withSameName: Swift.Bool) -> (UnifiedVideoEditorSDK.VideoSequence, UnifiedVideoEditorSDK.VideoMetadata)
  func replaceSequenceWithId(_ sequenceId: Swift.String, withVideoSequence: UnifiedVideoEditorSDK.VideoSequence)
  func setupWithVideoSequence(_ videoSequence: UnifiedVideoEditorSDK.VideoSequence)
  func setEditingStep(_ editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep, forSequence videoSequence: UnifiedVideoEditorSDK.VideoSequence)
}
extension UnifiedVideoEditorSDK.SequencesServicing {
  public func createNewSequence(withMusicTrack musicTrack: UnifiedVideoEditorSDK.MediaTrack? = nil, isSlideShow: Swift.Bool = false, editingStep: UnifiedVideoEditorSDK.VideoSequenceEditingStep = .camera, maxVideoDuration: Foundation.TimeInterval) -> UnifiedVideoEditorSDK.VideoSequence
}
public typealias ExecutionQueue = UnifiedVideoEditorSDK.CallbackQueue
public enum CallbackQueue {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  public func execute(_ block: @escaping () -> Swift.Void)
}
public enum ImageTransition {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: ((UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: ((Swift.Bool) -> Swift.Void)?)
}
public typealias DownloadProgressBlock = ((_ receivedSize: Swift.Int64, _ totalSize: Swift.Int64) -> Swift.Void)
public struct RetrieveImageResult {
  public let image: UnifiedVideoEditorSDK.KFCrossPlatformImage
  public let cacheType: UnifiedVideoEditorSDK.CacheType
  public let source: UnifiedVideoEditorSDK.Source
  public let originalSource: UnifiedVideoEditorSDK.Source
  public let data: () -> Foundation.Data?
}
public struct PropagationError {
  public let source: UnifiedVideoEditorSDK.Source
  public let error: UnifiedVideoEditorSDK.KingfisherError
}
public typealias DownloadTaskUpdatedBlock = ((_ newTask: UnifiedVideoEditorSDK.DownloadTask?) -> Swift.Void)
public class KingfisherManager {
  public static let shared: UnifiedVideoEditorSDK.KingfisherManager
  public var cache: UnifiedVideoEditorSDK.ImageCache
  public var downloader: UnifiedVideoEditorSDK.ImageDownloader
  public var defaultOptions: UnifiedVideoEditorSDK.KingfisherOptionsInfo
  public init(downloader: UnifiedVideoEditorSDK.ImageDownloader, cache: UnifiedVideoEditorSDK.ImageCache)
  @discardableResult
  public func retrieveImage(with resource: any UnifiedVideoEditorSDK.Resource, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, downloadTaskUpdated: UnifiedVideoEditorSDK.DownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)?) -> UnifiedVideoEditorSDK.DownloadTask?
  @discardableResult
  public func retrieveImage(with source: UnifiedVideoEditorSDK.Source, options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.DownloadProgressBlock? = nil, downloadTaskUpdated: UnifiedVideoEditorSDK.DownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<UnifiedVideoEditorSDK.RetrieveImageResult, UnifiedVideoEditorSDK.KingfisherError>) -> Swift.Void)?) -> UnifiedVideoEditorSDK.DownloadTask?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class SlideInPresentationManager : ObjectiveC.NSObject, UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor(unsafe) public var backgroundViewInteractionHandler: (() -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public init(coverPercentage: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: UnifiedVideoEditorSDK.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool = false, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor(unsafe) public init(coverHeight: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: UnifiedVideoEditorSDK.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor(unsafe) @objc convenience override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc public func presentationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController?, source: UIKit.UIViewController) -> UIKit.UIPresentationController?
  @_Concurrency.MainActor(unsafe) @objc public func animationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController, source: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func animationController(forDismissed dismissed: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func interactionControllerForPresentation(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func interactionControllerForDismissal(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class WatermarkDrawSettings : ObjectiveC.NSObject {
  final public let translatePos: CoreFoundation.CGPoint
  final public let rotationAngle: CoreFoundation.CGFloat
  final public let drawRect: CoreFoundation.CGRect
  @objc deinit
}
@objc public enum WatermarkCornerPosition : Swift.Int {
  case topLeft
  case topRight
  case bottomRight
  case bottomLeft
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class WatermarkInfo : ObjectiveC.NSObject {
  @objc public init(image: UIKit.UIImage, corner: UnifiedVideoEditorSDK.WatermarkCornerPosition, offset: CoreFoundation.CGPoint, targetWidth: CoreFoundation.CGFloat)
  @objc public init(image: UIKit.UIImage, corner: UnifiedVideoEditorSDK.WatermarkCornerPosition, offset: CoreFoundation.CGPoint, targetNormalizedWidth: CoreFoundation.CGFloat)
  @objc public init(image: UIKit.UIImage, normalizedPosition: CoreFoundation.CGPoint, targetWidth: CoreFoundation.CGFloat)
  @objc public init(image: UIKit.UIImage, normalizedPosition: CoreFoundation.CGPoint, targetNormalizedWidth: CoreFoundation.CGFloat)
  @objc public func drawSettingsWithBoundsSize(_ boundsSize: CoreFoundation.CGSize, outputSettings: UnifiedVideoEditorSDK.VEOutputSettings) -> UnifiedVideoEditorSDK.WatermarkDrawSettings
  @objc deinit
}
public protocol ProgressAnimatableViewFactory {
  func makeProgressAnimatableView() -> any UnifiedVideoEditorSDK.ProgressAnimatableView
}
public class CircularProgressViewFactory : UnifiedVideoEditorSDK.ProgressAnimatableViewFactory {
  public var progressColor: UIKit.UIColor
  final public let shadowColor: UIKit.UIColor
  public init(progressColor: UIKit.UIColor = .white, shadowColor: UIKit.UIColor = UIColor(white: 0, alpha: 0.25))
  public func makeProgressAnimatableView() -> any UnifiedVideoEditorSDK.ProgressAnimatableView
  @objc deinit
}
public enum GiphyResolution {
  case medium
  case original
  public static func == (a: UnifiedVideoEditorSDK.GiphyResolution, b: UnifiedVideoEditorSDK.GiphyResolution) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CacheSerializer {
  func data(with image: UnifiedVideoEditorSDK.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  func image(with data: Foundation.Data, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
  var originalDataUsed: Swift.Bool { get }
}
extension UnifiedVideoEditorSDK.CacheSerializer {
  public var originalDataUsed: Swift.Bool {
    get
  }
}
public struct DefaultCacheSerializer : UnifiedVideoEditorSDK.CacheSerializer {
  public static let `default`: UnifiedVideoEditorSDK.DefaultCacheSerializer
  public var compressionQuality: CoreFoundation.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public var originalDataUsed: Swift.Bool {
    get
  }
  public init()
  public func data(with image: UnifiedVideoEditorSDK.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: UnifiedVideoEditorSDK.KingfisherParsedOptionsInfo) -> UnifiedVideoEditorSDK.KFCrossPlatformImage?
}
public protocol VideoEditorSDKServicing {
  var videoEditorService: UnifiedVideoEditorSDK.VideoEditorService { get }
}
public protocol AudioVideoEditorSDKServicing : UnifiedVideoEditorSDK.VideoEditorSDKServicing {
  var audioService: any UnifiedVideoEditorSDK.AudioServicing { get }
}
public protocol SDKVideoCompositionInstructionDataSource : AnyObject {
  func getEffects(at time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
  func getEffectsBefore(time: CoreMedia.CMTime) -> [any UnifiedVideoEditorSDK.EditorCompositionEditableEffectProtocol]
}
public enum Source {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(any UnifiedVideoEditorSDK.Resource)
  case provider(any UnifiedVideoEditorSDK.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension UnifiedVideoEditorSDK.Source : Swift.Hashable {
  public static func == (lhs: UnifiedVideoEditorSDK.Source, rhs: UnifiedVideoEditorSDK.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias DownloadEffectRequestId = Swift.UInt
extension Swift.UInt {
  public static var invalid: UnifiedVideoEditorSDK.DownloadEffectRequestId {
    get
  }
}
@objc public class BanubaARCloud : ObjectiveC.NSObject {
  @objc public static var effectsFolderURL: Foundation.URL {
    @objc get
  }
  @objc required public init(arCloudUrl: Swift.String, embeddedEffectURLs: [Foundation.URL]? = nil)
  @objc public func getAREffects(completion: @escaping ([any UnifiedVideoEditorSDK.AREffect]?, Foundation.NSError?) -> Swift.Void)
  @objc public func getArEffectPreview(_ effect: any UnifiedVideoEditorSDK.AREffect, completion: @escaping (UIKit.UIImage?, Foundation.NSError?) -> Swift.Void)
  @discardableResult
  @objc public func downloadArEffect(_ effect: any UnifiedVideoEditorSDK.AREffect, downloadProgress: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Foundation.URL?, Foundation.NSError?) -> Swift.Void) -> UnifiedVideoEditorSDK.DownloadEffectRequestId
  @objc public func cancelDownloadingEffect(withRequestId requestId: UnifiedVideoEditorSDK.DownloadEffectRequestId)
  @objc public static func application(_ application: UIKit.UIApplication, handleEventsForBackgroundURLSession identifier: Swift.String, completionHandler: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol AnimatableView : UIKit.UIView {
  func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  func stop()
}
public protocol CountdownTimerAnimatableView : UnifiedVideoEditorSDK.AnimatableView {
  var countdownDigit: Swift.Int { get set }
}
public protocol ProgressAnimatableView : UIKit.UIView {
  var progress: Swift.Float { get set }
}
@available(*, deprecated, renamed: "AuthenticationChallengeResponsible", message: "Typo. Use `AuthenticationChallengeResponsible` instead")
public typealias AuthenticationChallengeResponsable = UnifiedVideoEditorSDK.AuthenticationChallengeResponsible
public protocol AuthenticationChallengeResponsible : AnyObject {
  func downloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  func downloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension UnifiedVideoEditorSDK.AuthenticationChallengeResponsible {
  public func downloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  public func downloader(_ downloader: UnifiedVideoEditorSDK.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public enum ContentLocationType : Swift.Int {
  case remote
  case local
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol EffectViewModel : AnyObject {
  var type: UnifiedVideoEditorSDK.EffectType { get }
  var image: UIKit.UIImage? { get set }
  var title: Swift.String { get }
  var id: Swift.UInt { get }
  var progress: Swift.Float? { get set }
  var progressHandler: ((_ progress: Swift.Float, _ failed: Swift.Bool) -> Swift.Void)? { get set }
  var downloadType: UnifiedVideoEditorSDK.ContentLocationType { get }
  var lutFileName: Swift.String? { get }
  func isEqual(to model: any UnifiedVideoEditorSDK.EffectViewModel) -> Swift.Bool
}
extension UnifiedVideoEditorSDK.EffectModel : UnifiedVideoEditorSDK.EffectViewModel {
  public var lutFileName: Swift.String? {
    get
  }
  public var downloadType: UnifiedVideoEditorSDK.ContentLocationType {
    get
  }
  public var progress: Swift.Float? {
    get
    set
  }
  public var progressHandler: ((_ progress: Swift.Float, _ failed: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  public func isEqual(to model: any UnifiedVideoEditorSDK.EffectViewModel) -> Swift.Bool
  public var type: UnifiedVideoEditorSDK.EffectType {
    get
  }
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var title: Swift.String {
    get
  }
}
extension UnifiedVideoEditorSDK.VideoEditorFilterModel : UnifiedVideoEditorSDK.EffectViewModel {
  public var lutFileName: Swift.String? {
    get
  }
  public var downloadType: UnifiedVideoEditorSDK.ContentLocationType {
    get
  }
  public var progress: Swift.Float? {
    get
    set
  }
  public var progressHandler: ((_ progress: Swift.Float, _ failed: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  public func isEqual(to model: any UnifiedVideoEditorSDK.EffectViewModel) -> Swift.Bool
  public var type: UnifiedVideoEditorSDK.EffectType {
    get
  }
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var title: Swift.String {
    get
  }
}
public let exportCancelledError: Foundation.NSError
public enum KingfisherError : Swift.Error {
  public enum RequestErrorReason {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: UnifiedVideoEditorSDK.SessionDataTask, token: UnifiedVideoEditorSDK.SessionDataTask.CancelToken)
  }
  public enum ResponseErrorReason {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: any Swift.Error)
    case dataModifyingFailed(task: UnifiedVideoEditorSDK.SessionDataTask)
    case noURLResponse(task: UnifiedVideoEditorSDK.SessionDataTask)
    case cancelledByDelegate(response: Foundation.URLResponse)
  }
  public enum CacheErrorReason {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: any Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: any Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: any Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: any Swift.Error)
    case cannotSerializeImage(image: UnifiedVideoEditorSDK.KFCrossPlatformImage?, original: Foundation.Data?, serializer: any UnifiedVideoEditorSDK.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: any Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: any Swift.Error)
    case diskStorageIsNotReady(cacheURL: Foundation.URL)
  }
  public enum ProcessorErrorReason {
    case processingFailed(processor: any UnifiedVideoEditorSDK.ImageProcessor, item: UnifiedVideoEditorSDK.ImageProcessItem)
  }
  public enum ImageSettingErrorReason {
    case emptySource
    case notCurrentSourceTask(result: UnifiedVideoEditorSDK.RetrieveImageResult?, error: (any Swift.Error)?, source: UnifiedVideoEditorSDK.Source)
    case dataProviderError(provider: any UnifiedVideoEditorSDK.ImageDataProvider, error: any Swift.Error)
    case alternativeSourcesExhausted([UnifiedVideoEditorSDK.PropagationError])
  }
  case requestError(reason: UnifiedVideoEditorSDK.KingfisherError.RequestErrorReason)
  case responseError(reason: UnifiedVideoEditorSDK.KingfisherError.ResponseErrorReason)
  case cacheError(reason: UnifiedVideoEditorSDK.KingfisherError.CacheErrorReason)
  case processorError(reason: UnifiedVideoEditorSDK.KingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: UnifiedVideoEditorSDK.KingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension UnifiedVideoEditorSDK.KingfisherError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension UnifiedVideoEditorSDK.KingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
public struct MusicEditorConfig {
  public var mainMusicViewControllerConfig: UnifiedVideoEditorSDK.MainMusicViewControllerConfig
  public var videoTrackLineEditControllerConfig: UnifiedVideoEditorSDK.VideoTrackLineEditViewControllerConfig
  public var audioTrackLineEditControllerConfig: UnifiedVideoEditorSDK.AudioTrackLineEditViewControllerConfig
  public var audioRecorderViewControllerConfig: UnifiedVideoEditorSDK.AudioRecorderViewControllerConfig
  public init()
  public init(mainMusicViewControllerConfig: UnifiedVideoEditorSDK.MainMusicViewControllerConfig, videoTrackLineEditControllerConfig: UnifiedVideoEditorSDK.VideoTrackLineEditViewControllerConfig, audioTrackLineEditControllerConfig: UnifiedVideoEditorSDK.AudioTrackLineEditViewControllerConfig, audioRecorderViewControllerConfig: UnifiedVideoEditorSDK.AudioRecorderViewControllerConfig)
}
public typealias KingfisherOptionsInfo = [UnifiedVideoEditorSDK.KingfisherOptionsInfoItem]
public enum KingfisherOptionsInfoItem {
  case targetCache(UnifiedVideoEditorSDK.ImageCache)
  case originalCache(UnifiedVideoEditorSDK.ImageCache)
  case downloader(UnifiedVideoEditorSDK.ImageDownloader)
  case transition(UnifiedVideoEditorSDK.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  case callbackQueue(UnifiedVideoEditorSDK.CallbackQueue)
  case scaleFactor(CoreFoundation.CGFloat)
  case preloadAllAnimationData
  case requestModifier(any UnifiedVideoEditorSDK.AsyncImageDownloadRequestModifier)
  case redirectHandler(any UnifiedVideoEditorSDK.ImageDownloadRedirectHandler)
  case processor(any UnifiedVideoEditorSDK.ImageProcessor)
  case cacheSerializer(any UnifiedVideoEditorSDK.CacheSerializer)
  case imageModifier(any UnifiedVideoEditorSDK.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(UnifiedVideoEditorSDK.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case diskStoreWriteOptions(Foundation.Data.WritingOptions)
  case memoryCacheExpiration(UnifiedVideoEditorSDK.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(UnifiedVideoEditorSDK.ExpirationExtending)
  case diskCacheExpiration(UnifiedVideoEditorSDK.StorageExpiration)
  case diskCacheAccessExtendingExpiration(UnifiedVideoEditorSDK.ExpirationExtending)
  case processingQueue(UnifiedVideoEditorSDK.CallbackQueue)
  case progressiveJPEG(UnifiedVideoEditorSDK.ImageProgressive)
  case alternativeSources([UnifiedVideoEditorSDK.Source])
  case retryStrategy(any UnifiedVideoEditorSDK.RetryStrategy)
  case lowDataMode(UnifiedVideoEditorSDK.Source?)
}
public struct KingfisherParsedOptionsInfo {
  public var targetCache: UnifiedVideoEditorSDK.ImageCache?
  public var originalCache: UnifiedVideoEditorSDK.ImageCache?
  public var downloader: UnifiedVideoEditorSDK.ImageDownloader?
  public var transition: UnifiedVideoEditorSDK.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: UnifiedVideoEditorSDK.CallbackQueue
  public var scaleFactor: CoreFoundation.CGFloat
  public var requestModifier: (any UnifiedVideoEditorSDK.AsyncImageDownloadRequestModifier)?
  public var redirectHandler: (any UnifiedVideoEditorSDK.ImageDownloadRedirectHandler)?
  public var processor: any UnifiedVideoEditorSDK.ImageProcessor
  public var imageModifier: (any UnifiedVideoEditorSDK.ImageModifier)?
  public var cacheSerializer: any UnifiedVideoEditorSDK.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: UnifiedVideoEditorSDK.KFCrossPlatformImage??
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var diskStoreWriteOptions: Foundation.Data.WritingOptions
  public var memoryCacheExpiration: UnifiedVideoEditorSDK.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: UnifiedVideoEditorSDK.ExpirationExtending
  public var diskCacheExpiration: UnifiedVideoEditorSDK.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: UnifiedVideoEditorSDK.ExpirationExtending
  public var processingQueue: UnifiedVideoEditorSDK.CallbackQueue?
  public var progressiveJPEG: UnifiedVideoEditorSDK.ImageProgressive?
  public var alternativeSources: [UnifiedVideoEditorSDK.Source]?
  public var retryStrategy: (any UnifiedVideoEditorSDK.RetryStrategy)?
  public var lowDataModeSource: UnifiedVideoEditorSDK.Source?
  public init(_ info: UnifiedVideoEditorSDK.KingfisherOptionsInfo?)
}
public typealias PrefetcherProgressBlock = ((_ skippedResources: [any UnifiedVideoEditorSDK.Resource], _ failedResources: [any UnifiedVideoEditorSDK.Resource], _ completedResources: [any UnifiedVideoEditorSDK.Resource]) -> Swift.Void)
public typealias PrefetcherSourceProgressBlock = ((_ skippedSources: [UnifiedVideoEditorSDK.Source], _ failedSources: [UnifiedVideoEditorSDK.Source], _ completedSources: [UnifiedVideoEditorSDK.Source]) -> Swift.Void)
public typealias PrefetcherCompletionHandler = ((_ skippedResources: [any UnifiedVideoEditorSDK.Resource], _ failedResources: [any UnifiedVideoEditorSDK.Resource], _ completedResources: [any UnifiedVideoEditorSDK.Resource]) -> Swift.Void)
public typealias PrefetcherSourceCompletionHandler = ((_ skippedSources: [UnifiedVideoEditorSDK.Source], _ failedSources: [UnifiedVideoEditorSDK.Source], _ completedSources: [UnifiedVideoEditorSDK.Source]) -> Swift.Void)
@_hasMissingDesignatedInitializers public class ImagePrefetcher : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  convenience public init(urls: [Foundation.URL], options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.PrefetcherProgressBlock? = nil, completionHandler: UnifiedVideoEditorSDK.PrefetcherCompletionHandler? = nil)
  convenience public init(urls: [Foundation.URL], options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, completionHandler: UnifiedVideoEditorSDK.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any UnifiedVideoEditorSDK.Resource], options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.PrefetcherProgressBlock? = nil, completionHandler: UnifiedVideoEditorSDK.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any UnifiedVideoEditorSDK.Resource], options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, completionHandler: UnifiedVideoEditorSDK.PrefetcherCompletionHandler? = nil)
  convenience public init(sources: [UnifiedVideoEditorSDK.Source], options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, progressBlock: UnifiedVideoEditorSDK.PrefetcherSourceProgressBlock? = nil, completionHandler: UnifiedVideoEditorSDK.PrefetcherSourceCompletionHandler? = nil)
  convenience public init(sources: [UnifiedVideoEditorSDK.Source], options: UnifiedVideoEditorSDK.KingfisherOptionsInfo? = nil, completionHandler: UnifiedVideoEditorSDK.PrefetcherSourceCompletionHandler? = nil)
  public func start()
  public func stop()
  @objc deinit
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ imageConfiguration: (any UnifiedVideoEditorSDK.ImageConfigurationProtocol)?)
}
extension UnifiedVideoEditorSDK.GalleryItemType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.GalleryItemType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.GalleryItemType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.TransitionType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TransitionType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TransitionType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.EffectPlayerRenderMode : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EffectPlayerRenderMode : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EffectPlayerRenderMode : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AudioTrackLinePosition : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AudioTrackLinePosition : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AudioTrackLinePosition : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.CameraModuleSessionType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CameraModuleSessionType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.CameraModuleSessionType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.EditButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EditButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.EditCompositionButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EditCompositionButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditCompositionButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.ControlButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.ControlButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ControlButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.BackButtonConfiguration.Position : Swift.Equatable {}
extension UnifiedVideoEditorSDK.BackButtonConfiguration.Position : Swift.Hashable {}
extension UnifiedVideoEditorSDK.BackButtonConfiguration.Position : Swift.Sendable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnit : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnit : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnitParameter : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AVAudioEngineUnitParameter : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VoiceEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VoiceEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VoiceEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.RenderBehaviorAdapter : Swift.Equatable {}
extension UnifiedVideoEditorSDK.RenderBehaviorAdapter : Swift.Hashable {}
extension UnifiedVideoEditorSDK.RenderBehaviorAdapter : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.SharingServiceModel.SharingType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SharingServiceModel.SharingType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VisualEffectApplicatorType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VisualEffectApplicatorType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VisualEffectApplicatorType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.RenderContentMode : Swift.Equatable {}
extension UnifiedVideoEditorSDK.RenderContentMode : Swift.Hashable {}
extension UnifiedVideoEditorSDK.RenderContentMode : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.OutputServiceError : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OutputServiceError : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SDKEventScreen : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SDKEventScreen : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SDKEventScreen : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.SDKEventName : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SDKEventName : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SDKEventName : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.BanubaCameraModule.MethodInJson : Swift.Equatable {}
extension UnifiedVideoEditorSDK.BanubaCameraModule.MethodInJson : Swift.Hashable {}
extension UnifiedVideoEditorSDK.BanubaCameraModule.MethodInJson : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.EffectSpeed : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EffectSpeed : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EffectSpeed : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AspectRatio : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AspectRatio : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AspectRatio : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.VideoSequenceEditingStep : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VideoSequenceEditingStep : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoSequenceEditingStep : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.CaptionsLanguage : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CaptionsLanguage : Swift.Hashable {}
extension UnifiedVideoEditorSDK.CaptionsLanguage : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint : Swift.Equatable {}
extension UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint : Swift.Hashable {}
extension UnifiedVideoEditorSDK.PresentEventOptions.EntryPoint : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.OverlayAddButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.OverlayEditButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.OverlayControlButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.CacheType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CacheType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.CaptureButtonViewMode : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CaptureButtonViewMode : Swift.Hashable {}
extension UnifiedVideoEditorSDK.CaptureButtonViewState : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CaptureButtonViewState : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DraftActionType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DraftActionType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditorEffectKey : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EditorEffectKey : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditorEffectKey : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.SpeedEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SpeedEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SpeedEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.TransitionEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TransitionEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TransitionEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.CameraSessionType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CameraSessionType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.CameraSessionType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.Connection : Swift.Equatable {}
extension UnifiedVideoEditorSDK.Connection : Swift.Hashable {}
extension UnifiedVideoEditorSDK.RecorderPreviewScalingMode : Swift.Equatable {}
extension UnifiedVideoEditorSDK.RecorderPreviewScalingMode : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TrimVideoCompositionEditItem.TrimVideoCompositionEditItemType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TrackDonwloadStatus : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TrackDonwloadStatus : Swift.Hashable {}
extension UnifiedVideoEditorSDK.TrackDonwloadStatus : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.DrawableFigure : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DrawableFigure : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DrawableFigure : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.DeviceModel : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DeviceModel : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DeviceModel : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.ContentMode : Swift.Equatable {}
extension UnifiedVideoEditorSDK.ContentMode : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AssetRotation : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AssetRotation : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AssetRotation : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.EditorEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EditorEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EditorEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.Position : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AdditionalEffectsButtonConfiguration.ButtonType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.TitlePosition : Swift.Equatable {}
extension UnifiedVideoEditorSDK.TitlePosition : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DraftsFeatureConfig : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DraftsFeatureConfig : Swift.Hashable {}
extension UnifiedVideoEditorSDK.DraftsFeatureConfig : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type` : Swift.Equatable {}
extension UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type` : Swift.Hashable {}
extension UnifiedVideoEditorSDK.FilterControlButtonConfig.`Type` : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.DraftMenuItemType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.DraftMenuItemType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AlertViewController.ButtonType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AlertViewController.ButtonType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ImageFormat : Swift.Equatable {}
extension UnifiedVideoEditorSDK.ImageFormat : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoResolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VideoResolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoResolution : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.CameraVideoResolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.CameraVideoResolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.EffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.EffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AudioBrowserMusicSource : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AudioBrowserMusicSource : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AudioBrowserMusicSource : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.ExportVideoInfo.Resolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.ExportVideoInfo.Resolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ExportVideoInfo.Resolution : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.VoiceChangerError : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VoiceChangerError : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoRecordSpeed : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VideoRecordSpeed : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoRecordSpeed : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.FeedbackAlertViewController.ActionTypes : Swift.Equatable {}
extension UnifiedVideoEditorSDK.FeedbackAlertViewController.ActionTypes : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Equatable {}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Hashable {}
extension UnifiedVideoEditorSDK.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.AnalyticsEffectType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.AnalyticsEffectType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.AnalyticsEffectType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.VideoTextAlignment : Swift.Equatable {}
extension UnifiedVideoEditorSDK.VideoTextAlignment : Swift.Hashable {}
extension UnifiedVideoEditorSDK.VideoTextAlignment : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment : Swift.Equatable {}
extension UnifiedVideoEditorSDK.GalleryItemConfiguration.DurationLabelAlignment : Swift.Hashable {}
extension UnifiedVideoEditorSDK.RenderBehavior : Swift.Equatable {}
extension UnifiedVideoEditorSDK.RenderBehavior : Swift.Hashable {}
extension UnifiedVideoEditorSDK.GalleryMediaType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.GalleryMediaType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.GalleryMediaType : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.FileExtension.Video : Swift.Equatable {}
extension UnifiedVideoEditorSDK.FileExtension.Video : Swift.Hashable {}
extension UnifiedVideoEditorSDK.FileExtension.Video : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.PIPSwitchLayoutSettings : Swift.Equatable {}
extension UnifiedVideoEditorSDK.PIPSwitchLayoutSettings : Swift.Hashable {}
extension UnifiedVideoEditorSDK.PIPSwitchLayoutSettings : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.PIPCameraLayoutSettings : Swift.Equatable {}
extension UnifiedVideoEditorSDK.PIPCameraLayoutSettings : Swift.Hashable {}
extension UnifiedVideoEditorSDK.PIPCameraLayoutSettings : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.PIPPlayerLayoutSettings : Swift.Equatable {}
extension UnifiedVideoEditorSDK.PIPPlayerLayoutSettings : Swift.Hashable {}
extension UnifiedVideoEditorSDK.PIPPlayerLayoutSettings : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.PIPShapeAdapter : Swift.Equatable {}
extension UnifiedVideoEditorSDK.PIPShapeAdapter : Swift.Hashable {}
extension UnifiedVideoEditorSDK.PIPShapeAdapter : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition : Swift.Equatable {}
extension UnifiedVideoEditorSDK.WatermarkConfiguration.WatermarkPosition : Swift.Hashable {}
extension UnifiedVideoEditorSDK.WatermarkCornerPosition : Swift.Equatable {}
extension UnifiedVideoEditorSDK.WatermarkCornerPosition : Swift.Hashable {}
extension UnifiedVideoEditorSDK.WatermarkCornerPosition : Swift.RawRepresentable {}
extension UnifiedVideoEditorSDK.GiphyResolution : Swift.Equatable {}
extension UnifiedVideoEditorSDK.GiphyResolution : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ContentLocationType : Swift.Equatable {}
extension UnifiedVideoEditorSDK.ContentLocationType : Swift.Hashable {}
extension UnifiedVideoEditorSDK.ContentLocationType : Swift.RawRepresentable {}
